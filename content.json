{"meta":{"title":"BL's Blog","subtitle":"Welcome To My World!","description":"BL的个人博客","author":"LiuBL","url":"https://selamangit.github.io/ZaNot.github.io","root":"/ZaNot.github.io/"},"pages":[{"title":"about","date":"2021-10-21T12:32:28.000Z","updated":"2021-10-21T12:32:52.809Z","comments":true,"path":"about/index.html","permalink":"https://selamangit.github.io/ZaNot.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-21T12:30:59.000Z","updated":"2021-10-21T12:31:42.531Z","comments":true,"path":"categories/index.html","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2021-10-21T12:36:50.000Z","updated":"2021-10-21T12:37:16.798Z","comments":true,"path":"404/index.html","permalink":"https://selamangit.github.io/ZaNot.github.io/404/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-10-21T12:33:16.000Z","updated":"2021-10-21T12:34:09.974Z","comments":true,"path":"contact/index.html","permalink":"https://selamangit.github.io/ZaNot.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-21T12:32:04.000Z","updated":"2021-10-21T12:32:21.063Z","comments":true,"path":"tags/index.html","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-10-21T12:34:41.000Z","updated":"2021-10-21T12:34:55.714Z","comments":true,"path":"friends/index.html","permalink":"https://selamangit.github.io/ZaNot.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"《EfficientNet》","slug":"《EfficientNet》","date":"2022-09-09T07:13:38.682Z","updated":"2022-09-09T07:13:38.683Z","comments":true,"path":"2022/09/09/efficientnet/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/efficientnet/","excerpt":"","text":"EfficientNet论文理解摘要（Abstract）前言介绍了卷积神经网络的训练机制，也就是卷积神经网络在固定计算资源下得到一定的学习模型，当计算资源扩大时，就会对卷积层进行扩展以提高准确性。而这篇论文让我们系统地研究模型的缩放，来确定仔细平衡网络深度、宽度、分辨率三个维度可以为模型带来更好的性能。基于这个角度，一种新的缩放方法被提出来，这种方法就是通过一个简单而高效的复合系数来统一缩放深度/宽度/分辨率 他们使用神经网络结构搜索来设计一个新的基准网络，并对该基准网络进行扩展来获得一系列的模型，这些模型被称EfficentNet，经ImageNet上的图片分类测试，该模型达到了84.4%top-1和97.1%top-5的准确率，模型大小比现存（2019）最好的卷积神经网络小8.4倍，推理速度快6.1倍。 ==网络比对图==： 简介（Introduction）论文指出对卷积神经网络扩展的过程从没有得到很好的理解，对卷积网络结构的常见操作是按其深度或宽度来扩展模型，按分辨率来扩展模型也是可以但是不太常用，虽然可以任意放缩两三个维度或三个维度，但是任意放缩维度需要手动调整，并且会经常导致次优的精度和效率。 因此，他们在想一个问题：是否存在一种概念模型来放缩卷积神经网络来达到更高的准确性和效率？ 经过实验研究，他们发现平衡三个维度非常重要，而且可以通过一个恒定的比率来简单地放缩这三个维度来实现这中平衡 不像常规的放缩模型的方法，EfficientNet通过一个固定的放缩复合系数统一地放缩网络的深度和宽度以及分辨率 例如：如果我们想多使用$\\boldsymbol{2^N}$倍的计算资源，则可以简单地将网络深度增加$\\boldsymbol{\\alpha^N}$倍，宽度增加$\\boldsymbol{\\beta^N}$倍，图片大小（分辨率）增加$\\boldsymbol{\\gamma^N}$倍，其中$\\boldsymbol{\\alpha、\\gamma、\\beta}$是在原始小模型上通过小网格搜索确定的常数。 ==网络模型不同放缩方式的对比图==： 直观上，这种复合系数放缩模型的方法是有意义的，因为如果输入图像较大时，网络需要更多层来增加感受野、更多的通道更大的图片上来捕捉更多的细粒度（细节特征）的图案在，实际上，在之前就有人提出理论：网络的深度和宽度之间有一定的关系，但他们是第一个根据经验量化网络深度和宽度以及分辨率三个维度之间的关系的人。 值得注意的是：模型扩展的有效性在很大程度上取决于基线网络，EfficentNet就是通过==神经网络结构搜索==开发的基线网络并将该基线网络进行扩展获得的一系列模型。 从卷积神经网络的效率来说：深层的卷积神经网络通常会过度参数化（参数过多），为了减少模型的参数量，一种常用的方法就是模型压缩，通过以准确性为代价来减少模型大小，还有设计轻量级网络也可以通过手工设计卷积核的大小以达到减少网络参数的目的。最近==神经网络结构搜索==在设计高效的卷积核的卷积神经网络中越来越流行，而且==神经网络结构搜索==通过广泛地调整网络宽度和深度以及卷积核的类型和大小来达到比手工制作的移动式的卷积神经网络更高效。 尽管有了这些减少模型参数的方法，但是不知道如何将这些技术应用于设计空间更大、调整成本更高的大型模型，因此在这篇论文中，他们的目的在于研究超大型卷积神经网络的模型效率，该模型的准确率超过了最高的准确率。","categories":[{"name":"论文阅读理解笔记","slug":"论文阅读理解笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"《Deep Retinex Decomposition for Low-Light Enhancement》解读","slug":"《Deep Retinex Decomposition for Low-Light Enhancement》解读","date":"2022-09-09T07:13:38.680Z","updated":"2022-09-09T07:13:38.681Z","comments":true,"path":"2022/09/09/deep-retinex-decomposition-for-low-light-enhancement-jie-du/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/deep-retinex-decomposition-for-low-light-enhancement-jie-du/","excerpt":"","text":"《Deep Retinex Decomposition for Low-Light Enhancement》解读 这是一种基于Retinex理论的卷积神经网络模型——RetinexNet，该模型是2018年发表在BMVC上的 Retinex理论-图像分解任何一副图像可以分解为光照图像和反射图像 ，反射图像是物体的本身性质决定的即为不变的部分，光照图则受外界影响比较多，可以去除光照影响或者对光照图像进行校正，则可以达到图像增强的目的。 摘要基于Retinex的模型低光照图像增强的好帮手，==模型假设观察到的图像能被分解为反射图像和光照图像==，大部分现有的基于Retinex的模型都针对这种高度不适的分解精心设计了手工制作的约束和参数，这些参数当被应用于各种场景时，可能会受到模型容量的限制，这篇论文采用的数据集是LOL（Low-Light dataset），并在这个数据集中训练出深层次的Retinex-Net，这个网络包括用于分解的Decom-Net和用来照明调整的Enhance-Net，在Decom-Net的训练过程中，没有分解反射和照明的ground truth，这个网络仅通过通过合适的损失函数就可以将一对低光照和正常光照的条件下的图像中，共享的一致反射信息和平滑的光照信息分解出来。基于分解后的图像，通过增强网络Enhance-Net对光照进行后续的亮度增强，对反射图像进行联合降噪。Retinex-Net是端到端可训练的，因此学习到的分解对于调节亮度自然是有利的，论文指出：经过大量实验表明，这个网络模型不仅可以达到视觉愉悦的低光照增强效果，而且还可以很好地表示图像的分解。 目的在捕获的图像中光照不足会显著地降低图像的可见度，图像中丢失的细节和图像的低对比度不仅会让人感觉到不愉快，还不利于大多为正常光线图像设计的计算机视觉系统的性能。造成照明不足的原因很多，例如：光线不足的环境，摄影设备的性能有限或者设备的配置不当。为了使隐藏的细节显现出来，提高当前计算机视觉系统的主观体验和可用性，需要进行弱光图像增强。 低光照图像增强的方法（对比）在过去的几十年里，许多研究人员致力于解决弱光图像增强的问题，也已经开发了许多技术来改善低光照图像的主观和客观质量，例如:直方图均衡（HE）及其变体可以限制输出图像的直方图来满足某些约束条件、基于去雾的方法利用光照不足的图像与朦胧环境中的图像之间的逆向光系。 弱光增强的另一类方法是基于Retinex理论，它假设观察到的彩色图像可以分解为反射图像和光照图像。作为早期的尝试，单尺度Retinex（Single-scale-Retinex）通过高斯滤波器将光照图像约束为平滑；多尺度Retinex（MSRCR）通过多尺度高斯滤波器和色彩恢复扩展了SSR。其中，有一个团队提出了一种利用亮度阶数误差度量保持照明自然性的方法，另一个团队建议融合原始光照图像的多个推导，他们使用加权变分模型同时估计反射信息和光照信息。在操作完光照后，可以恢复目标结果。另一方面LIME算法只使用结构先验估计光照，并使用反射图像信息作为最终的增强结果 早期增强办法的局限性虽然上面提到的方法在某些情况下可能会产生令人鼓舞的结果，但它们仍然受到模型对于反射和照明的分解能力的限制，很难设计出良好的约束条件适用于各种场景的图像分解。而且，分解出来的光照图像上的操作也是手工完成的，这些方法的性能通常取决于仔细的参数调整。 论文中采取的方案随着神经网络的快速发展，CNN倍广泛应用于低照度图像处理上，例如：实现超分辨率图像，除雨，去雾，等等。为了同时进行低照度增强和降噪，有一团队使用了堆叠的稀疏去噪自动编码器，但是没有考虑低照度图像的性质。 为了克服这些困难，论文作者提出了一种数据驱动的Retinex分解模型，叫做——Retinex-Net，一个深层次的神经网络，这个网络将图像分解和一系列连续的图像增强操作整合在一起。 首先一个子网络Decom-Net将观察到的图像分为照明独立的反射信息和结构感知的平滑光照信息。Decom-Net具有两个约束条件：第一个是低光照和正常光照条件下共享同样的反射信息；第二个是光照图像应该是平滑的，但保留主要结构，这是通过结构感知的总变化损失获得的 接着，另一个网络叫做Enhance-Net，这个网络用来调整分解出来的光照图像在大区域内保持一致性，同时通过多尺度级联调整局部分布。由于噪声在黑暗区通常较大，甚至在图像增强过程中被放大，因此要引入反射图像去噪。 Retinex-Net总体框架图 Retinex框架解读：低照度图像增强步骤分为：$\\boldsymbol{\\text{分解}\\Rightarrow\\text{调整}\\Rightarrow\\text{重建}}$$\\text{分解}$：子网络Decom-Net将输入图像分解为反射信息和光照信息 $\\text{调整}$：基于编码器-解码器的Enhance-Net增强了照明效果，引入了多尺度级联，以从多尺度的角度调整光照，在这个步骤中反射图像上的噪声也会被消除 $\\text{重建}$：重建调整后的光照信息和反射信息以获得增强的结果 作者提出了一种结构感知的总变化约束用于深度图像分解。通过减轻梯度强烈的地方的总变化影响，该约束成功地平滑了光照图像并保留了主要结构。 Retinex-Net对低照度增强具体操作 经典的Retinex理论为人类的色彩感知建模，它假设原始图像可以分解为两个部分，即反射信息和光照信息，公式为：$$\\boldsymbol{S=R\\ \\circ I}$$其中$\\boldsymbol{S}$表示原始图像信息，$\\boldsymbol{R}$表示反射图像信息，$\\boldsymbol{I}$表示光照图像信息，反射图像信息描述了所捕获对象的固有属性，认为任何光照条件下该属性都是一致的；光照图像信息表示所捕获对象上的各种光照信息。 分解阶段分解步骤是Retinex-Net的第一步，它在训练阶段以一对低光照 \\ 正常光照的图像作为输入，在测试阶段则以低光照图像作为输入。 在弱光 \\ 普通光图像共享相同的反射信息和平滑的光照信息的约束下，Decom-Net在大量的数据中学会提取==不同光照图像之间的一致性== 调整阶段Enhance-Net被用来增强光照图像上的信息，这个网络采用了编解码器的整体框架。它在集中注意力调整局部分布的同时，采用多尺度级联的方法来保持光照与大区域内信息之间的全局一致性，发生在低光照条件下的放大噪声如果需要的话也会被消除 重建阶段最后，调整后的光照信息和反射信息通过逐元素相乘整合在一起，也就是$\\boldsymbol{S=R\\ \\circ I}$ 数据驱动的图像分解Retinex理论的核心在于$\\boldsymbol{S=R\\ \\circ I}$，但是如何从人眼观测到的图像$\\boldsymbol{S}$，计算出真实的恒常性的图像$\\boldsymbol{R}$？这是一个病态的问题，很难设计出一个适合的约束来适应不同的场景，因此论文的作者选择了一种数据驱动的方式来解决这个问题。 在训练阶段，Decom-Net每次都会获取成对的弱光/正常光图像，并在弱光/正常光图像所共享的反射图像信息的指导下学习从弱光图像中分解出相对应正常光图像中的反射图像信息，在这个阶段，不需要提供图像中反射图像信息和光照图像信息的ground truth，这个网络最重要的知识包括：反射图像信息的一致性和光照图像信息的平滑度，这些体现在损失函数上。 虽然这个问题和固有图像分解的形式有一定的相似，但是本质上它们是不同的。在Retinex-Net的任务中，它不需要准确地获取实际的固有图像，就可以对将弱光图像很好地接近固有图像，因此，作者让Retinex-Net学会低光照图像和它相对应的增强结果之间的一致性。 如Retinex-Net框架图所示，Decom-Net将低光照图像$\\boldsymbol{S_{low}}$和正常光照图像$\\boldsymbol{S_{normal}}$作为输入，然后分别估计$\\boldsymbol{S_{low}}$的反射图像信息$\\boldsymbol{R_{low}}$和光照图像信息$\\boldsymbol{I_{low}}$以及$\\boldsymbol{S_{normal}}$的反射图像信息$\\boldsymbol{R_{normal}}$和光照图像信息$\\boldsymbol{I_{normal}}$，它首先使用了一个$\\boldsymbol{3\\times 3}$的卷积层从输入图像中提取特征，然后使用了几个以$\\boldsymbol{ReLU}$为激活函数的$\\boldsymbol{3\\times 3}$卷积层将$\\boldsymbol{RGB}$图像映射为反射图像信息和光照图像信息的特征图，接着一个$\\boldsymbol{3\\times 3}$的卷积层将反射图像信息和光照图像信息的特征图映射为反射图像信息和光照图像信息，最后用一个$\\boldsymbol{Sigmoid}$函数将反射图像信息的矩阵信息和光照图像的矩阵信息约束到$\\boldsymbol{[0,1]}$的范围内 Decom-Net的损失函数包括三个部分：重建损失$\\boldsymbol{\\mathcal{L}{recon}}$反射图像信息的一致性的损失$\\boldsymbol{\\mathcal{L}{ir}}$和光照图像信息的平滑度损失$\\boldsymbol{\\mathcal{L}{is}}$：$$\\boldsymbol{\\mathcal{L}=\\mathcal{L}{recon}+\\lambda_{ir} \\mathcal{L}{i r}+\\lambda{i s} \\mathcal{L}{i s}}$$这里的$\\boldsymbol{\\lambda{ir}}$和$\\boldsymbol{\\lambda_{is}}$是用来平衡反射图像信息的一致性和光照图像信息的平滑度 基于$\\boldsymbol{R_{low}}$和$\\boldsymbol{R_{high}}$都可以使用相应的光照图像信息来重建图像的假设，重建损失函数$\\boldsymbol{\\mathcal{L}{recon}}$表示为：$$\\boldsymbol{\\mathcal{L}{recon}=\\sum_{i={low,normal}} \\sum_{j={low,normal}} \\lambda_{i j}\\left|R_{i} \\circ I_{j}-S_{j}\\right|_{1}}$$ 反射图像信息的一致性的损失$\\boldsymbol{\\mathcal{L}{ir}}$被用来约束反射图像信息的一致性：$$\\boldsymbol{\\mathcal{L}{ir}=|R_{low}-R_{normal}|{1}}$$光照图像信息的平滑度损失$\\boldsymbol{\\mathcal{L}{is}}$在接下来的部分将进行细致的描述 结构感知的平滑度损失对光照图像信息的一个基本假设就是：局部一致性和结构意识。换句话说，光照图像信息的一个好的处理方案应该是在局部纹理细节上保持平滑，同时仍然可以保留整个结构的边界。 整个图像梯度的总变化的最小化（Total variation minimization，TV）通常在进行各种图像恢复任务时，被当作平滑度。但是，在图像结构较完整或亮度变化剧烈的区域直接使用TV来作为损失函数将会失去效果。这是因为无论是在纹理细节还是明显的边缘，图像梯度都是在一致的减少的。也就是说TV损失对于图像的整体结构并不敏感，这样导致光照图像信息是模糊的，反射图像信息上留下了明显的黑色边缘,如下图所示： 为了使损失体现出对图像结构的感知，原始的TV函数通过反射图像梯度进行加权$\\boldsymbol{\\mathcal{L}{is}}$表示为：$$\\boldsymbol{\\mathcal{L}{is}=\\sum_{i=l o w, n o r m a l}\\left|\\nabla I_{i} \\circ \\exp \\left(-\\lambda_{g} \\nabla R_{i}\\right)\\right|}$$这里$\\boldsymbol{\\nabla}$表示梯度包括$\\boldsymbol{\\nabla_h}$（水平方向）和$\\boldsymbol{\\nabla_v}$（垂直方向），$\\boldsymbol{\\lambda_g}$表示平衡感知强度的系数，通过权值$\\boldsymbol{\\exp \\left(-\\lambda_{g} \\nabla R_{i}\\right)}$，$\\boldsymbol{\\mathcal{L}_{is}}$放松了反射图像信息中图像梯度变化不均匀的区域中平滑度的约束，也就是说，图像结构分布和光照分布应该是不均匀的。 虽然LIME也是考虑通过加权后的TV约束将图像结构保持在光照图像信息中，但是论文作者认为它的做法和自己的做法是不一样的。对于LIME来说，图像梯度的总变化的约束是通过初始光照图像信息来进行加权的，这个初始光照图像信息就是原始图像中RGB通道中每个像素的最大强度，和论文中使用反射图像信息作为来为结构感知平滑度加权不相同。由于反射图像信息被假设为图像的物理特性，因此在LIME中使用静态初始估计不能像反射图像信息那样描述图像的结构。因为Decom-Net是off-line的方式来训练的，数据量很大，所以在训练阶段可以同步更新光照图像信息和权重（反射图像信息） 多尺度光照调整光照增强网络采用了编码-解码器的总体框架，为了分层调整光照图像信息，作者引进了多尺度级联的方法。通过编解码器获取一个大区域内的上下文信息，输入图像被连续地下采样到一个较小的尺寸，这是为了让网络能看到图像更大的区域中光照图像信息的分布（涉及感受野的知识），这使得网络具有一定的自适应调整的能力，利用大面积的光照图像信息，上采样就可以重建局部的光照分布。通过逐元素求和将 Skip connection 从下采样块引入到其对应的镜像上采样块中去，从而使网络学习残差，具体流程可以看上面的总体框架图。 为了分层调整照明，这意味着在调整局部照明分布的同时保持全局照明的一致性，引入了多尺度级联的方法。如果存在$\\boldsymbol{M}$个逐级上采样的块，每个块都提取一个通道数为$\\boldsymbol{C}$的特征图，接着通过最近邻插值以不同的比例调整这些特征的大小到最终的比例，并将这些特征连接成一个通道数为$\\boldsymbol{C\\times M}$的特征图，然后通过一个$\\boldsymbol{1\\times1}$的卷积层将连接后的特征图降维到通道数为$\\boldsymbol{C}$的特征图。接着是一个$\\boldsymbol{3\\times 3}$的卷积层来重建光照图像$\\boldsymbol{\\tilde{I}}$ 下采样层是由一个stride为2的卷积层和ReLU激活函数构成，上采样层是由最近邻插值运算和一个stride为1的卷积层和ReLu激活函数构成，经过证明这样可以避免出现棋盘格图案的伪影 Enhance-Net网络由重建损失$\\boldsymbol{\\mathcal{L}{recon}}$和光照图像平滑度损失$\\boldsymbol{\\mathcal{L}{is}}$构成，$\\boldsymbol{\\mathcal{L}{recon}}$意味着生成正常光照图像$\\boldsymbol{\\tilde{s}}$$$\\boldsymbol{\\mathcal{L}{recon}=\\left|R_{low} \\circ \\hat{I}-S_{normal}\\right|{1}}$$$$\\boldsymbol{\\mathcal{L}{is}=\\sum_{i=l o w, n o r m a l}\\left|\\nabla I_{i} \\circ \\exp \\left(-\\lambda_{g} \\nabla R_{i}\\right)\\right|}$$ 注意$\\boldsymbol{\\hat{I}}$是由$\\boldsymbol{R_{low}}$的图像梯度来加权得到的。 反射图像信息的去噪在分解阶段，作者往网络中加入了一些约束，例如加入光照图像信息中的结构感知的平滑度。当预测出来的光照图像是平滑的时候，所有的细节都保留在反射图像信息上，包括增强的噪声。因此在利用光照图像信息重建输出图像之前，可以对反射图像信息进行去噪处理。鉴于在分解阶段中暗区的噪声会根据亮度强度进行放大，因此应该使用与光照有关的降噪方法。 细节实现Retinex-Net在485对来自真实摄影的图像对和1000张合成的图像对的基础上训练，作者根据经验来看这个网络是轻量的，在Decom-Net部分共采用了5个带激活函数的卷积层，这些卷积层被两个没有带激活函数的卷积层所包围；Enhance-Net由3个下采样层和3个上采样层组成。首先训练Decom-Net和Enhance-Net，然后使用具有多个曝光级别的随机梯度下降对网络进行端到端的微调 联合低光照增强和降噪考虑到综合表现，BM3D在Retinex-Net被用来作为降噪的手段","categories":[{"name":"论文阅读理解笔记","slug":"论文阅读理解笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"端口映射","slug":"端口映射","date":"2022-09-09T07:13:38.679Z","updated":"2022-09-09T07:13:38.679Z","comments":true,"path":"2022/09/09/duan-kou-ying-she/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/duan-kou-ying-she/","excerpt":"","text":"什么是端口映射?","categories":[{"name":"计算机网络学习笔记","slug":"计算机网络学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"什么叫数据帧","slug":"什么叫数据帧","date":"2022-09-09T07:13:38.677Z","updated":"2022-09-09T07:13:38.678Z","comments":true,"path":"2022/09/09/shi-me-jiao-shu-ju-zheng/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shi-me-jiao-shu-ju-zheng/","excerpt":"","text":"什么叫数据帧数据帧（Data frame），就是数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。其中，帧头和帧尾包含一些必要的控制信息，比如同步信息、地址信息、差错控制信息等；数据部分则包含网络层传下来的数据，比如IP数据包，等等。 参考资料","categories":[{"name":"计算机网络学习笔记","slug":"计算机网络学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"HTTP协议","slug":"HTTP协议","date":"2022-09-09T07:13:38.577Z","updated":"2022-09-09T07:13:38.579Z","comments":true,"path":"2022/09/09/http-xie-yi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/http-xie-yi/","excerpt":"","text":"什么是Http协议 HTTP协议(超文本传输协议HyperText Transfer Protocol)，它是基于TCP协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则","categories":[{"name":"计算机网络学习笔记","slug":"计算机网络学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"类快排寻找第k小元素","slug":"类快排寻找第k小元素","date":"2022-09-09T07:13:38.576Z","updated":"2022-09-09T07:13:38.576Z","comments":true,"path":"2022/09/09/lei-kuai-pai-xun-zhao-di-k-xiao-yuan-su/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/lei-kuai-pai-xun-zhao-di-k-xiao-yuan-su/","excerpt":"","text":"类快排算法寻找第k小元素 类快排是一种基于快排来寻找元素的算法，与快排的区别在于：快排是先将元素全部排好序之后，再去寻找，因此快排是一种排序算法，但是接下来介绍的类快排算法则是在排序的过程中就开始寻找元素 为什么说类快排是基于快排的呢？我们来回忆一下快速排序，选取第一个或者最后一个元素作为比较风向标，每一次循环结束的标志是前面的指针（变量）和后面的指针（变量）指向同一个位置的时候，当指向同一个位置时就将比较风向标的值放入这个位置中，这时候比较风向标的位置是已经确定下来了的，类快排就是利用了这个比较风向标所放置的位置，假如这个位置在数组中的位置刚好是k，那就皆大欢喜了，你已经成功找到了这个第k小的元素了 #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; void Swap(int *x,int *y); int Search(int a[], int left, int right,int k); int main() { int k; int a[10] = {9,8,7,6,5,4,3,2,1,0}; int result; printf(\"请输入k的值：\"); scanf(\"%d\",&amp;k); result = Search(a,0,9,k); printf(\"第%d小的元素是%d\",k,result); return 0; } void Swap(int *x,int *y) { int temp; temp = *x; *x = *y; *y = temp; } int Search(int a[], int left, int right,int k) { if(left &gt;= right) { return a[left]; } int i = left; int j = right + 1; int pivot = a[left]; //比较风向标 while(1) { do{ i = i+1; } while(a[i] &lt; pivot); //寻找比风向标大的元素的下标 do{ j = j-1; }while(a[j] &gt; pivot); //寻找比风向标小的元素的下标 if(i &gt;= j) //直到找到风向标放置的下标i==j或者风向标放在最后面 { break; } Swap(&amp;a[i],&amp;a[j]); } if(j-left+1 == k) { return pivot; } a[left] = a[j]; a[j] = pivot; if(j-left+1&lt;k) //左边的元素个数比k还小说明第k小的不在左边的数组中，到右边数组寻找 { return Search(a,j+1,right,k-j+left-1); } else{ return Search(a,left,j-1,k); } }","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"排列的字典序","slug":"排列的字典序","date":"2022-09-09T07:13:38.574Z","updated":"2022-09-09T07:13:38.575Z","comments":true,"path":"2022/09/09/pai-lie-de-zi-dian-xu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/pai-lie-de-zi-dian-xu/","excerpt":"","text":"分治法求解排列的字典序 问题描述：$n$个元素有$n！$个不同的排序，将这$n！$个排列按字典序排列，并编号为$0,1,…,n-1$。每个排列的编号为其字典序值。例如，当$n=3$时，6个不同排列的字典序值如下： 字典序值 0 1 2 3 4 5 排列 123 132 213 231 312 321 输入：第一个正整数n。第二行是n个元素{1,2,…,n}的一个排列输出：第一行为字典序值。 第二行为按字典序排列的下一个排列 输出的字典序列的值可以用排列来求，难点在于：如何求解字典序列的下一个排列？可以使用以下方法： 以输入：8，26458173为例，看看如何找到26458173的下一个排列，P[i]表示为排列中的第i位 从尾部向前找到第一个P[i-1]&lt;P[i]的位置 如：264581&lt;–7&lt;–3，第一个后一个元素小于前一个元素的元素是1，最终找到1是第一个变小的数字，记录下1的下标为i-1 接着从尾部往前找到第一个大于1的数 26458173，明显是3，记录下3为m的下标 交换下标为i-1和m的值 得：26458371 倒序i位置后得所有数据 得：26458317，这就是结果 代码和理论都没怎么搞懂 #include&lt;stdio.h&gt; int main() { int a; scanf(\"%d\",&amp;a); int data[a]; for(int i=0;i&lt;a;i++) { scanf(\"%d\",&amp;data[i]); } int c = S(data,a,0); printf(\"%d\\n\",c); next(data,a); for(int i=0;i&lt;a;i++) { printf(\"%d\",data[i]); } return 0; } int A(int n,int m) //排列的计算公式 { int sum = 1; for(int i=1;i&lt;=m;i++) { sum *= n-i+1; } return sum; } int S(int a[],int n,int h) //计算排列的字典序 { int sum = 0; int count = 0; if(n&lt;1) { return 0; } int p = a[h]; for(int i=0;i&lt;h;i++) { if(a[i]&lt;p) { count++; //用来计数，记录当前数小于p的数的个数 } } for(int i=0;i&lt;p-count-1;i++) //之前小于p的数不会参与排列 { sum+=A(n-1,n-1); } if(n&gt;1) { sum+=S(a,n-1,h+1); } return sum; } void reverse(int a[],int min, int n) //数组反转 { int i,j,temp; for(i=min,j=n-1;i&lt;j;i++,j--) { temp = a[i]; a[i] = a[j]; a[j] = temp; } } void next(int a[],int n) //求下一个排列 { int min,max,temp; for(int i=n-1;i&gt;=0;i--) { if(a[i-1]&lt;a[i]) //从尾部开始，找出第一个变小的数的位置，记为min { min = i-1; break; } } for(int i=n-1;i&gt;=0;i--) //从尾部开始，找出第一个大于a[min]的数的位置，记为max { if(a[i]&gt;a[min]) { max = i; break; } } temp = a[min]; a[min] = a[max]; a[max] = temp; reverse(a,min+1,n); } 代码参考","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"回溯法求解八皇后问题","slug":"回溯法求解八皇后问题","date":"2022-09-09T07:13:38.573Z","updated":"2022-09-09T07:13:38.574Z","comments":true,"path":"2022/09/09/hui-su-fa-qiu-jie-ba-huang-hou-wen-ti/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/hui-su-fa-qiu-jie-ba-huang-hou-wen-ti/","excerpt":"","text":"回溯法求解N皇后问题1. 八皇后问题 问题描述：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法？ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define N 8 //定义最多求解8皇后问题 int arr[N]; //arr用来存放N个皇后在对应列的所在行数 int isPlaceOk(int k); void PrintQueen(int n); void Queen(int n); int main() { for(int i=0;i&lt;N;i++) { arr[i] = -1; } Queen(N); system(\"pause\"); return 0; } //判断是否能放置皇后在该列 int isPlaceOk(int k) { for(int i=0;i&lt;k;i++) { if(arr[i]==arr[k]||abs(i-k) == abs(arr[i]-arr[k])) return 1; //冲突,返回1 } return 0; //不冲突,返回0 } void PrintQueen(int n) { for(int i=0;i&lt;n;i++) { printf(\"%5d\",arr[i]+1); } printf(\"\\n\"); } void Queen(int n) { int k = 0,num = 0; while(k &gt;= 0) //死循环 { arr[k]++; //回溯后的皇后，将摆放在下一列 while(arr[k] &lt; n &amp;&amp; isPlaceOk(k) == 1) //冲突的话继续向下一列试探 { arr[k]++; } if(arr[k]&lt;n &amp;&amp; k == n-1) { printf(\"第%d个解是：\\n\",++num); PrintQueen(n); } else if(arr[k]&lt;n &amp;&amp; k&lt;n-1) { k = k + 1; } else { arr[k--] = -1; //重置arr[k],回溯,重新摆放下一个皇后 } } } 代码参考 2. 12皇后问题 问题描述：求解N=12皇后问题，要求前k个皇后的位置是随机投放，剩下的N-k个皇后再逐步一列一列的试探，任意两个皇后都不能处于同一行、同一列或同一斜线上","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"回溯法","slug":"回溯法","date":"2022-09-09T07:13:38.570Z","updated":"2022-09-09T07:13:38.570Z","comments":true,"path":"2022/09/09/hui-su-fa/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/hui-su-fa/","excerpt":"","text":"回溯法理论1. 什么是回溯法回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 在数据结构的学习中在讲解利用栈求解迷宫问题的时候就使用了回溯法，简单来说：就是先选择一个方向先入栈来前进，当发现无法继续走下去，且还没有走出迷宫，则退回上一步重新选择，和深度优先搜索有点相似 在迷宫问题中，每一步选择的方向（选优条件）的顺序是确定了的，不知回溯法有多少种选优条件？ 2. 回溯法求解过程 状态空间树：每次扩大当前部分解时，都面临一个可选的状态集合，新的部分解就通过在该集合中选择构造而成。这样的状态集合，其结构是一棵多叉树，每个树结点代表一个可能的部分解，它的儿子是在它的基础上生成的其他部分解。 从开始结点（根结点）出发，以深度优先搜索整个状态空间。这个开始结点成为活结点，同时也成为当前的扩展结点。在当前扩展结点处，搜索向纵深方向移至一个新结点。这个新结点成为新的活结点，并成为当前扩展结点。如果在当前扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的活结点处，并使这个活结点成为当前扩展结点。回溯法以这种工作方式递归地在状态空间中搜索，直到找到所要求的解或解空间中已无活结点时为止。 3. 回溯和穷举的联系和区别联系它们都是基于试探的 区别穷举法要将一个解的各个部分全部生成后，才检查是否满足条件，若不满足，则直接放弃该完整解，然后再尝试另一个可能的完整解，它并没有沿着一个可能的完整解的各个部分逐步回退生成解的过程。而对于回溯法，一个解的各个部分是逐步生成的，当发现当前生成的某部分不满足约束条件时，就放弃该步所做的工作，退到上一步进行新的尝试，而不是放弃整个解重来。 4. 回溯法解空间应用回溯法求解问题时，首先应明确定义问题的解空间，该解空间应至少包含问题的一个最优解。在定义了问题的解空间后，还需要将解空间有效地组织起来，使得回溯法能方便地搜索整个解空间，通常将解空间组织成树或图的形式。例如，对于n= 3的0-1 背包问题，其解空间可以用一棵完全二叉树表示 5. 回溯法解题的关键要素 针对给定的问题，定义问题的解空间； 确定易于搜索的解空间结构；（一般都是树形结构，也有可能是图结构） 以深度优先方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"动态规划求解背包问题","slug":"动态规划求解背包问题","date":"2022-09-09T07:13:38.566Z","updated":"2022-09-09T07:13:38.567Z","comments":true,"path":"2022/09/09/dong-tai-gui-hua-qiu-jie-bei-bao-wen-ti/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/dong-tai-gui-hua-qiu-jie-bei-bao-wen-ti/","excerpt":"","text":"1. 背包问题 问题描述：给定一组物品，每种物品都有自己的重量和价格，在==限定的总重量==内，我们如何选择，才能==使得物品的总价格最高== （1）0-1背包问题 问题描述：一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？ 分析： 每件物品都存在装入和不装入两种情况，所以总的时间复杂度是$O(2^N)$，这是不可接受的。而使用动态规划可以将复杂度降至$O(NW)$。我们的目标是书包内物品的总价值，而变量是物品和书包的限重，所以我们可定义状态dp:dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, 0&lt;=i&lt;=N, 0&lt;=j&lt;=W 首先在背包中没有任何物品的时候，背包为空，背包内的物品的价值也是0，因此置状态dp数组的dp[0][……]=0，这一步相当于初始化状态dp数组 在背包开始装入物品的时候，即i&gt;0的情况下，就要考虑第i件物品放入背包（前提是能装得下）后使背包价值的变化，也就是更新状态dp数组： 不装入第i件物品，即dp[i−1][j] 装入第i件物品（前提是能装下），即dp[i−1][j−w[i]] + v[i] 状态转移方程为：dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i]) 动态规划的核心思想避免重复计算在01背包问题中体现得淋漓尽致。第i件物品装入或者不装入而获得的最大价值完全可以由前面i-1件物品的最大价值决定 Tip:空间优化： 动态规划中常使用滚动数组来对空间进行优化，就是去掉状态dp数组的第一维，但是需要注意的是，为了防止上一层循环的状态dp数组dp[0,……,j-1]被覆盖，循环的时候j只能逆向迭代 假设有以下例题求出其动态规划的状态数组： 首先根据状态转移方程填表得： 接着根据代码实现算法得： 可以看到和我所填的表是一样的，从而验证了正确性 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void FindMax(); void FindWhat(int i,int j); void Print(); void ShowPath(); int Max(int x,int y); int row = 6; int col = 16; int Vol = 15; int w[6] = {0,3,4,7,8,9}; int v[6] = {0,4,5,10,11,13}; int item[6]; int dp[6][16]={{0}};//初始化dp数组 int main() { FindMax(); FindWhat(5,15); Print(); ShowPath(); return 0; } void ShowPath() { printf(\"装入背包的物品是：\"); for(int i = 1;i&lt;row;i++) { if(item[i] == 1) { printf(\"%d\",i); } } printf(\"\\n\"); } void FindMax() { for(int i = 1;i&lt;row;i++) { for(int j = 1;j &lt; col; j++) { if(j&lt;w[i]) { dp[i][j] = dp[i-1][j]; } else { dp[i][j] = Max(dp[i-1][j], dp[i-1][j-w[i]]+v[i]); } } } } void FindWhat(int i,int j) { if(i&gt;=0) { if(dp[i][j] == dp[i-1][j]) //不装入的状态 { item[i] = 0; FindWhat(i-1,j); } else if(j-w[i] &gt;= 0 &amp;&amp; dp[i][j] == dp[i-1][j-w[i]]+v[i]) //装入的状态 { item[i] = 1; FindWhat(i-1,j - w[i]); } } } void Print() { for(int i=0;i&lt;row;i++) { for(int j=0;j&lt;col;j++) { printf(\"%3d \",dp[i][j]); } printf(\"\\n\"); } } int Max(int x,int y) { int max; max = x&gt;y?x:y; return max; } 代码参考 （2）完全背包问题（3）多重背包问题（4）背包问题最优解回溯通过上面的方法可以求出背包问题的最优解，但还不知道这个最优解由哪些物品组成，故要根据最优解回溯找出解的组成，根据状态数组dp可以有如下的寻解方式： dp[i][j] = dp[i-1][j]时，说明没有选择第i个物品，则回到dp[i-1][j] dp[i][j] = dp[i−1][j−w[i]] + v[i]时，说明选择了第i个物品，该物品是最优解组成的一部分，随后我们得回到装该物品之前，即回到dp[i−1][j−w[i]] 一直遍历到i＝0结束为止，所有解的组成都会找到 同样以上面例题来理解： 通过代码实现的算法检测得： 可以看到结果和图示结果一样","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"动态规划求解矩阵连乘的最佳序列和最少次数","slug":"动态规划求解矩阵连乘的最佳序列和最少次数","date":"2022-09-09T07:13:38.564Z","updated":"2022-09-09T07:13:38.565Z","comments":true,"path":"2022/09/09/dong-tai-gui-hua-qiu-jie-ju-zhen-lian-cheng-de-zui-jia-xu-lie-he-zui-shao-ci-shu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/dong-tai-gui-hua-qiu-jie-ju-zhen-lian-cheng-de-zui-jia-xu-lie-he-zui-shao-ci-shu/","excerpt":"","text":"动态规划求解矩阵连乘的最佳序列和最少次数 问题描述:给定n个矩阵${A_1…..A_n}$；其中$A_1….A_{i+1}$是可以连乘的，先要求怎么样给这些矩阵加括号改变他们原来的乘积顺序使得最终相乘的次数达到最小 例如： 计算三个矩阵连乘${A1，A2，A3}$；维数分别为$10 \\times 100$ , $100\\times5$ , $5\\times50$ 按此顺序计算需要的次数$((A1\\times A2)\\times A3)$:$10\\times 100\\times 5+10\\times 5\\times 50=7500次$ 按此顺序计算需要的次数$(A1\\times (A2\\times A3))$:$10\\times 5\\times 50+10\\times 100\\times 50=75000次$ 所以要解决的问题是：如何确定矩阵连乘积$A_1,A_2,……,A_n$的计算次序，使得按此计算次序计算矩阵连乘积需要的数乘次数达到最小化 分析： 我们想要求解$A_1\\times A_2\\times……\\times A_n$的最少乘法次数就要利用括号将其中某些矩阵合起来一起计算，也就是将矩阵连乘分成几个部分，因此我们假设中矩阵$A_1\\sim A_n$中间有一个能将矩阵最好的划分为两个部分是划分矩阵$A_k,k \\in (1\\sim n)$，将矩阵连乘划分为$A_1\\times A_2\\times……\\times A_k$和$A_{k+1}\\times A_{k+2}\\times……\\times A_n$，分别对这两部分继续进行划分，从而得到$A_1\\times A_2\\times……\\times A_k$和$A_{k+1}\\times A_{k+2}\\times……\\times A_n$的乘法次数，将两者加起来即可得到$A_1\\times A_2\\times……\\times A_n$连乘的最小次数 递归公式如下：$$m[i,j]=\\left{\\begin{array}{l}0&amp;,&amp;i=j\\min_{i\\leq k\\leq j}{m[i,k]+m[k+1,j]+p_{i-1}\\times p_k\\times p_j}&amp;,&amp;i\\le j\\end{array}\\right.$$其中$m[i,j]$表示的是矩阵$A_i$连乘到$A_j$的最小乘法次数，$p_{i-1}$表示$m[i,k]$最后一个矩阵的第二维度的数目，$p_k$为矩阵划分点$A_k$的第一维度的数目，$p_j$是最后一个矩阵$A_j$的第二维度的数目，$p_{i-1}\\times p_k\\times p_j$是$A_1\\times A_2\\times……\\times A_k$和$A_{k+1}\\times A_{k+2}\\times……\\times A_n$相乘的乘法次数 这种方式实际上就是递归将原问题拆分为子问题，这也体现出动态规划的特点，但是如何体现出动态规划不用重复计算子问题的特点呢？当然是像其他动态规划求解一样使用一个状态矩阵作为辅助了，那么这个状态矩阵应该保存哪些信息呢？记录的是$m[i,j]$ 如果还要求解矩阵连乘的最佳划分序列，还要使用一个辅助矩阵来保存最优的划分点$A_k$的位置k参考博客 1. 画图理解例如有以下矩阵： $A_1$ $A_2$ $A_3$ $A_4$ $A_5$ $A_6$ $5\\times 10$ $10\\times 3$ $3\\times 12$ $12\\times 5$ $5\\times 50$ $50\\times 6$ $m[1,2]=min\\left{\\begin{array}{l}m[1,1]+m[2,2]+p_0\\times p_1\\times p_2=150\\\\end{array}\\right.$ $m[2,3]=min\\left{\\begin{array}{l}m[2,2]+m[3,3]+p_1\\times p_2\\times p_3=360\\\\end{array}\\right.$ $m[3,4]=min\\left{\\begin{array}{l}m[3,3]+m[4,4]+p_2\\times p_3\\times p_4=180\\\\end{array}\\right.$ $m[4,5]=min\\left{\\begin{array}{l}m[4,4]+m[5,5]+p_3\\times p_4\\times p_5=3000\\\\end{array}\\right.$ $m[5,6]=min\\left{\\begin{array}{l}m[5,5]+m[6,6]+p_4\\times p_5\\times p_6=1500\\\\end{array}\\right.$ $m[1,3]=min\\left{\\begin{array}{l}m[1,1]+m[2,3]+p_0\\times p_1\\times p_3=\\m[1,2]+m[3,3]+p_0\\times p_2\\times p_3=\\end{array}\\right.$ $m[2,4]=min\\left{\\begin{array}{l}m[2,2]+m[3,4]+p_1\\times p_2\\times p_4\\m[2,3]+m[4,4]+p_1\\times p_3\\times p_4\\end{array}\\right.$ $m[3,5]=min\\left{\\begin{array}{l}m[3,3]+m[4,5]+p_2\\times p_3\\times p_5\\m[3,4]+m[5,5]+p_2\\times p_4\\times p_5\\end{array}\\right.$ $m[4,6]=min\\left{\\begin{array}{l}m[4,4]+m[5,6]+p_3\\times p_4\\times p_6\\m[4,5]+m[6,6]+p_3\\times p_5\\times p_6\\end{array}\\right.$ $m[1,4]=min\\left{\\begin{array}{l}m[1,1]+m[2,4]+p_0\\times p_1\\times p_4\\m[1,2]+m[3,4]+p_0\\times p_2\\times p_4\\m[1,3]+m[4,4]+p_0\\times p_3\\times p_4\\\\end{array}\\right.$ $m[2,5]=min\\left{\\begin{array}{l}m[2,2]+m[3,5]+p_1\\times p_2\\times p_5\\m[2,3]+m[4,5]+p_1\\times p_3\\times p_5\\m[2,4]+m[5,5]+p_1\\times p_4\\times p_5\\\\end{array}\\right.$ $m[3,6]=min\\left{\\begin{array}{l}m[3,3]+m[4,6]+p_2\\times p_3\\times p_6\\m[3,4]+m[5,6]+p_2\\times p_4\\times p_6\\m[3,5]+m[6,6]+p_2\\times p_5\\times p_6\\\\end{array}\\right.$ $m[1,5]=min\\left{\\begin{array}{l}m[1,1]+m[2,5]+p_0\\times p_1\\times p_5\\m[1,2]+m[3,5]+p_0\\times p_2\\times p_5\\m[1,3]+m[4,5]+p_0\\times p_3\\times p_5\\m[1,4]+m[5,5]+p_0\\times p_4\\times p_5\\\\end{array}\\right.$ $m[2,6]=min\\left{\\begin{array}{l}m[2,2]+m[3,6]+p_1\\times p_2\\times p_6\\m[2,3]+m[4,6]+p_1\\times p_3\\times p_6\\m[2,4]+m[5,6]+p_1\\times p_4\\times p_6\\m[2,5]+m[6,6]+p_1\\times p_5\\times p_6\\\\end{array}\\right.$ $m[1,6]=min\\left{\\begin{array}{l}m[1,1]+m[2,6]+p_0\\times p_1\\times p_6\\m[1,2]+m[3,6]+p_0\\times p_2\\times p_6\\m[1,3]+m[4,6]+p_0\\times p_3\\times p_6\\m[1,4]+m[5,6]+p_0\\times p_4\\times p_6\\m[1,5]+m[6,6]+p_0\\times p_5\\times p_6\\\\end{array}\\right.$ 2. 代码实现#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define MAX 50 #define INF 32767 int p[MAX+1]; //存储第一个矩阵的第一维度的数目和其他矩阵的第二维度的数目 int m[MAX][MAX]; //m[i][j]存储子问题的最优解 int s[MAX][MAX]; //s[i][j]存储子问题的最佳分割点 int n; //存储矩阵个数 void PrintMatrix(int leftindex,int rightindex); void Matrix(); int main() { int i; printf(\"请输入矩阵相乘的矩阵个数：\"); scanf(\"%d\",&amp;n); printf(\"请依次输入矩阵的行和烈（如A*B，A=20*30，B=30*40，即输入20 30 40)\\n\"); for(i=0;i&lt;n+1;i++) { scanf(\"%d\",&amp;p[i]); } Matrix(); printf(\"矩阵连乘最小次数\\t%d\\n\",m[0][n-1]); PrintMatrix(0,n-1); printf(\"\\n\"); return 0; } void Matrix() { int i,j,k; for(int i=0;i&lt;n;i++) { m[i][i] = 0; //矩阵自己和自己相乘产生的最小乘法次数为0,最小子问题只含一个矩阵时，对角线的元素全部为0 } //这种写法值得学习 for(i=2;i&lt;=n;i++) { for(j=0;j&lt;n-i+1;j++) //i-1表示当前对角线的起始列下标 { m[j][j+i-1] = INF; //以对角线的形式初始化 for(k=0;k&lt;i-1;k++) //寻找i和j之间的最佳分割点k { if(m[j][j+i-1]&gt;(m[j][j+k]+m[j+k+1][j+i-1]+p[j]*p[j+k+1]*p[j+i])) { m[j][j+i-1] = (m[j][j+k]+m[j+k+1][j+i-1]+p[j]*p[j+k+1]*p[j+i]); //更新状态矩阵m s[j][j+i-1] = k; //记录分割点 } } } } } void PrintMatrix(int leftindex,int rightindex) { if(leftindex == rightindex) { printf(\"A%d\",leftindex); } else { printf(\"(\"); PrintMatrix(leftindex,leftindex+s[leftindex][rightindex]); PrintMatrix(leftindex+s[leftindex][rightindex]+1,rightindex); printf(\")\"); } } 参考代码","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"动态规划求解最长公共子序列问题","slug":"动态规划求解最长公共子序列问题","date":"2022-09-09T07:13:38.560Z","updated":"2022-09-09T07:13:38.560Z","comments":true,"path":"2022/09/09/dong-tai-gui-hua-qiu-jie-zui-chang-gong-gong-zi-xu-lie-wen-ti/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/dong-tai-gui-hua-qiu-jie-zui-chang-gong-gong-zi-xu-lie-wen-ti/","excerpt":"","text":"动态规划法求解最长公共子序列1. 基本概念首先最长公共子序列（longest common sequence）和最长公共子串（longest common substring）不是一回事儿 子序列指的是字符串中不一定连续但先后顺序一致的n个字符，即可以去掉字符串中的部分字符，但不可改变其前后顺序。如abcdefg中，acdg，bdf属于它的子序列，而bac，dbfg则不是，因为它们与字符串的字符顺序不一致。 公共子序列如果序列C既是序列A的子序列，同时也是序列B的子序列，则称它为序列A和序列B的公共子序列。如对序列 1,3,5,4,2,6,8,7和序列 1,4,8,6,7,5 来说，序列1,8,7是它们的一个公共子序列。 字符子串指的是字符串中连续的n个字符，如abcdefg中，ab，cde，fg等都属于它的字串。 最长公共子序列：就是A和B的公共子序列中长度最长的（包含元素最多的）仍然用序列1,3,5,4,2,6,8,7和序列1,4,8,6,7,5为例，它们的最长公共子序列有1,4,8,7和1,4,6,7两种，但最长公共子序列的长度是4。由此可见，最长公共子序列也不一定唯一。但很显然，对于固定的两个数组，虽然最长公共子序列不一定唯一，但最长公共子序列的长度是一定的 最长公共子序列与查找最长公共子串的问题不同的地方在于：子序列不需要在原序列中占用连续的位置。最长公共子串（要求连续）和最长公共子序列是不同的 设字符串$X=[x_1,x_2,x_3,x_4,……,x_m]$，字符串$Y=[y_1,y_2,y_3,y_4,……,y_n]$，$Z=[z_1,z_2,z_3,z_4,……,z_k]$是两个字符串的任意公共子序列分析： 如果$x_m=y_n$，则$z_k=x_m=y_n$且$[z_1,z_2,z_3,……z_{k-1}]$是$[x_1,x_2,x_3,……,x_{m-1}]$和$[y_1,y_2,y_3,……,y_{n-1}]$的一个最长公共子序列 如果$x_m!=y_n$且$z_k!=x_m$，则$Z=[z_1,z_2,z_3,z_4,……,z_k]$是$[x_1,x_2,x_3,……,x_{m-1}]$和$Y=[y_1,y_2,y_3,y_4,……,y_n]$的最长公共子序列 如果$x_m!=y_n$且$z_k!=y_n$，则$Z=[z_1,z_2,z_3,z_4,……,z_k]$是$[x_1,x_2,x_3,……,x_{m}]$和$Y=[y_1,y_2,y_3,y_4,……,y_{n-1}]$的最长公共子序列 2. 填表以ABCD和BDCA来讲解填表的方法，很明显可以看出这两个字符串的最长公共子序列就是BD 首先画出如图所示的表格，大小根据字符串的长度来确定，然后比较红色箭头指向的两个元素的值，如果两个元素的值大小相等的话，则将两个箭头交叉处的表格置为：左上角元素值+1，否则置为：max{左边元素值，上方元素值}，接着移动上方的红色箭头，继续与左侧箭头指向的元素比较，直到比较完才移动左侧红色箭头 填完所有的表格得到： 那么如何根据这张图找到最长公共子序列呢？就是从表格最右下角的元素值逆推，找到使得元素值变化的元素位置 得到结果：BD 动态规划体现在哪里？ 左边和上边记录了最长字串信息？ 3. 代码实现","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"动态规划求解多段图最短路径问题","slug":"动态规划求解多段图最短路径问题","date":"2022-09-09T07:13:38.556Z","updated":"2022-09-09T07:13:38.558Z","comments":true,"path":"2022/09/09/dong-tai-gui-hua-qiu-jie-duo-duan-tu-zui-duan-lu-jing-wen-ti/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/dong-tai-gui-hua-qiu-jie-duo-duan-tu-zui-duan-lu-jing-wen-ti/","excerpt":"","text":"动态规划求解多段图的最短路径问题 问题描述：若存在一个有向加权图G，且G能分出起点和终点以及中间的n的阶段，求起点到终点的最短（长）距离。 分析： 根据多段图的性质，我们可以将这种特殊的图结构划分为多个子集，例如如图所示的多段图就可以分成 5 个子集，在图中以 5 种不同颜色来表示。可以明显地看到想要到达某一个子集的顶点，就必须从上一个相邻顶点集的顶点出发，不相邻的子集之间不存在可达的边。 例如我想要到达顶点 10，那就必须要先到达顶点 8 或者顶点 9。换句话说，到达顶点 10 的最短距离就是在到达顶点8的最短距离 d(1,8) 加上边 (8,10) 的权重，和到达顶点 9 的最短距离 d(1,9) 加上边 (9,10) 的权重中取最小值。因为不相邻的顶点集之间不存在边，所以到达顶点 10 的方式有且仅有上述 2 种。设 C 为某条边的权重，d(m,n) 为从点 m 到点 n 的最短距离，则使用数学语言的描述如下：$$d(1,10) = min(d(1,8)+C_{8,10},d(1,9)+C_{9,10})$$ 同理可以求出起点到图中任意点的最短距离，因此可得公式：$$\\left{\\begin{array}{l}d(s,v) = C_{s,v}&amp;,&amp;(&lt;s,v&gt;\\in E)\\d(s,v) = min{d(s,u)+C_{u,v}}&amp;,&amp;(&lt;u,v&gt;\\in E)\\end{array}\\right.$$ 与前面的背包问题不一样的是：背包问题的目标是使目标值得到最大值，而最短路径问题则是使目标值最小，因此状态方程也有了改变：MinCost[i]=min{MinCost[i],MinCost[……]+graph-&gt;AdjMatrix[……][i]} 问题求解： 求解此类问题除了邻接矩阵二维数组之外，还需要两个一维数组：MinCost[MAXVERTEX]来记录从起点开始到每个顶点的最小路径和Path[MAXVERTEX]来记录每个顶点的前驱顶点 寻找起点到终点的最短路径的方式就是从Path数组的最后一位开始向前找它的前驱顶点，直到找到起点为止，如此一来就可以得到一条起点到终点的路径，这条路径就是起点到终点的最短路径#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #define MAXVERTEX 99 #define MAXINF 32767 typedef struct { int Vertex[MAXVERTEX]; int AdjMatrix[MAXVERTEX][MAXVERTEX]; int vex,arc; }Graph; Graph graph; int Path[MAXVERTEX] = {0}; //用一个一维数组来保存当前顶点的前驱顶点 int MinCost[MAXVERTEX] = {0}; //用一个一维数组来保存最小到当前顶点的最短路径 void CreateGraph(Graph *graph); void PrintGraph(Graph *graph); void MinCostInit(Graph *graph); void MinimunPath_MultiSection(Graph *graph); void PrintPath(int len); int main() { Graph graph; CreateGraph(&amp;graph); MinCostInit(&amp;graph); MinimunPath_MultiSection(&amp;graph); return 0; } void CreateGraph(Graph *graph) { printf(\"请输入图中顶点的个数：\"); scanf(\"%d\",&amp;graph-&gt;vex); printf(\"请输入图中的边的个数:\"); scanf(\"%d\",&amp;graph-&gt;arc); for(int i=1;i&lt;=graph-&gt;vex;i++) { for(int j=1;j&lt;=graph-&gt;vex;j++) { graph-&gt;AdjMatrix[i][j] = 0; } } int n,m,w; for(int i = 0;i&lt;graph-&gt;arc;i++) { printf(\"请输入边的两个顶点以及边的权值：\"); scanf(\"%d %d %d\",&amp;n,&amp;m,&amp;w); graph-&gt;AdjMatrix[n][m] = w; } for(int i=1;i&lt;=graph-&gt;vex;i++) { for(int j=1;j&lt;=graph-&gt;vex;j++) { printf(\"%4d \",graph-&gt;AdjMatrix[i][j]); } printf(\"\\n\"); } } void MinCostInit(Graph *graph) { //起点到起点的距离为0，且为最小了 MinCost[1] = 0; for(int i=2;i&lt;=graph-&gt;vex;i++) { MinCost[i] = MAXINF; } } void MinimunPath_MultiSection(Graph *graph) { for(int i=2;i&lt;=graph-&gt;vex;i++) { //为什么是j&lt;i,因为要从起点开始寻找到graph-&gt;Vertex[i]的最短距离 for(int j=1;j&lt;i;j++) { if(graph-&gt;AdjMatrix[j][i] != 0) { int cost; cost = graph-&gt;AdjMatrix[j][i]+MinCost[j]; if(cost&lt;MinCost[i]) { MinCost[i] = cost; Path[i] = j; //记录前驱顶点 } } } } PrintPath(graph-&gt;vex); } void PrintPath(int num) { for(int i=1;i&lt;=num;i++) { printf(\"到顶点%d的最短路径为：%d,路径为：%d\",i,MinCost[i],i); int pre; pre = i; while(Path[pre]) { printf(\"&lt;-%d\",Path[pre]); pre = Path[pre]; } printf(\"\\n\"); } } 参考博客","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"动态规划","slug":"动态规划","date":"2022-09-09T07:13:38.554Z","updated":"2022-09-09T07:13:38.556Z","comments":true,"path":"2022/09/09/dong-tai-gui-hua/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/dong-tai-gui-hua/","excerpt":"","text":"动态规划理论1. 什么是动态规划在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。 这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法。 2. 动态规划的思想动态规划与分治法类似，都是==把大问题拆分成小问题==，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在==新问题里需要用到的子问题可以直接提取，避免了重复计算==，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于==填表==，表填写完毕，最优解也就找到。 所谓的最优性原理是指：多阶段决策过程的最优决策序列具有这样的性质：不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言（当前出发点），其后各阶段的决策序列必须构成最优策略。 3. 动态规划的作用动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间 Questions动态规划怎么保证每个子问题的决策都是对最优结果的最好的决策呢？动态规划记住的状态一定是最优的吗？","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"分治算法求解循环赛日程表问题","slug":"分治算法求解循环赛日程表问题","date":"2022-09-09T07:13:38.551Z","updated":"2022-09-09T07:13:38.552Z","comments":true,"path":"2022/09/09/fen-zhi-suan-fa-qiu-jie-xun-huan-sai-ri-cheng-biao-wen-ti/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/fen-zhi-suan-fa-qiu-jie-xun-huan-sai-ri-cheng-biao-wen-ti/","excerpt":"","text":"分治法求解循环赛日程表 问题描述：设有$N=2^k$（如果不是$2^k$则将N转化为$2^k$）个运动员（队伍），要进行循环赛。现在要设计一个满足以下要求的比赛日程表，每个选手（队伍）必须与其他N-1个选手（队伍）各赛一场，每个选手一天只能赛一次，循环赛一共进行N-1天 分析： 因为比赛需要两个对手，而且一个选手每天只能比赛一次，因此在一天之中，参与比赛的选手数只能是：0，2，4，6，…..等均为偶数，如果是奇数则需要将其转化为偶数 用一个二维表来表示每位选手与其他选手在每一天的比赛记录，例如在一天两个选手（选手1和选手2）开始了比赛可以表示为： 在一天中，8个人参加比赛了表示为： 循环赛开始了8-1=7天，每个选手在每天的参赛情况可以表示为： 二维表中的第一列表示的是选手的编号，从第二列开始到N-1列表示的是该行选手在第i天的对手 可以看到从分治算法的角度很容易得到解，首先分治将8个人的比赛分为4个人的比赛，4个人的比赛一个人一天只能比一场，因此一个选手要和其他3位选手比完，需要3天的时间，因此刚好是$4\\times4$的二维数组 而4个人的比赛还可以分为2个人的比赛 这就是分治在循环赛这个问题上的体现 它是怎样获取和其他选手在第二天的比赛的呢？ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #define MAXSIZE 64 int arr[MAXSIZE][MAXSIZE]; int main() { int realteam; int team; int virtualteam = 0; //轮空的队伍数 printf(\"请输入队伍数：\"); scanf(\"%d\",&amp;realteam); if(IsTwoPower(realteam) == 0) { team = ChangeToTwoPower(realteam); virtualteam = team - realteam; } CompetitionStart(team, 0); printf(\"赛程安排如下：\\n\"); printf(\"编号 \"); for(int i = 1; i&lt;team; i++) { printf(\"第%d天\",i); } printf(\"\\n\"); for(int i = 0; i&lt;team; i++) { for(int j = 0; j&lt;team; j++) { printf(\"%4d\",arr[i][j]); if(((j+1)%team) == 0) { printf(\"\\n\"); } } } //判断是否需要补充提?说明轮空 if(virtualteam != 0) { printf(\"其中\"); for(int i=realteam;i&lt;team;i++) { printf(\"队%d\",i+1); } printf(\"属于轮空\"); } return 0; } //判断一个数是否是2的n次幂 int IsTwoPower(int num) { int flag=0; if(((num) &amp;&amp; (num-1)) == 0) //为什么是&amp;&amp; { flag = 1; } else { flag = 0; } return flag; } int ChangeToTwoPower(int num) { int i=0; do{ i++; }while(num&gt;pow(2,i)); return pow(2,i); } int CompetitionStart(int n, int k) { if(n == 2) { arr[k][0] = k+1; arr[k][1] = k+2; arr[k+1][0] = k+2; arr[k+1][1] = k+1; } else //递归分治 { CompetitionStart(n/2, k); CompetitionStart(n/2, k+n/2); //n/2为当前参赛人数分一半的数目 for(int i = k; i&lt;k+n/2 ;i++) //填充表的右上角 { for(int j = n/2; j&lt;n; j++) //循环的次数为n/2次 { arr[i][j] = arr[i+n/2][j-n/2]; } } for(int i=k+n/2; i&lt;k+n; i++) //填充表的右下角 { for(int j=n/2;j&lt;n;j++) { arr[i][j] = arr[i-n/2][j-n/2]; } } } } 以代码来理解就是（继续以8只队伍为例）： 递归到深处（递归出口）会返回下面形状的矩阵，当然可能k值不一样，数值会不一样 接着就需要填充完这4个队伍，变成： 就是填充使得一支队伍表示出与其他队伍在不同天内的比赛，因为用于填充的队伍对于当前行的队伍来说都是前面已经参与比赛的了（这样讲可能有点难理解，但是我不懂如何表达了） 产生过程大致如此： 最后只需要填充完即可","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"分治算法","slug":"分治算法","date":"2022-09-09T07:13:38.548Z","updated":"2022-09-09T07:13:38.549Z","comments":true,"path":"2022/09/09/fen-zhi-suan-fa/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/fen-zhi-suan-fa/","excerpt":"","text":"分治算法理论1. 什么是分治？分治就是将一个复杂的问题分解成若干个规模较小的子问题，这些子问题之间相互独立且与原问题性质相同。通过求解子问题的解，从而得到原问题的解 分治求解的典型问题就是：斐波那契数列，阶乘问题等","categories":[{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"深度学习_过拟合","slug":"深度学习_过拟合","date":"2022-09-09T07:13:38.545Z","updated":"2022-09-09T07:13:38.546Z","comments":true,"path":"2022/09/09/shen-du-xue-xi-guo-ni-he/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shen-du-xue-xi-guo-ni-he/","excerpt":"","text":"过拟合 泛化能力：模型通过训练集中的数据的训练学到一种概念，当这种概念能普遍适用于其他的机器学习任务中，就可以称该模型具有较好的泛化能力，因此泛化能力是评估一个模型优劣的一个指标 采样数据：在机器学习任务中，通常来说，训练集和测试集都采用自某个相同的数据分布$\\boldsymbol{p(x)}$，采样到的样本是相互独立的，但是又来自于相同的分布，这样的采样条件叫做独立同分布假设。 模型表达能力：当模型表达能力较弱时，只能学习到线性模型，无法较好地逼近非线性模型，例如：单层线性层；但模型的表达能力过强时，就有可能把训练集的噪声模式也学到，导致在模型上表现不佳的现象（也称为模型的泛化能力较差）， 因此针对不同的任务，设计相应的模型算法才能取得较好的泛化能力。 ##模型的容量模型的容量或表达能力，是指模型拟合复杂函数的能力。一种体现模型容量的指标为模型的假设空间的大小（Hypothesis Space），即模型可以表示的函数集的大小。假设空间越大越完备，从假设空间中搜索出逼近真实模型的函数也就越有可能；反之，如果假设空间非常有限，就很难从中找到逼近真实模型的函数。 假设空间的理解可以类比用==泰勒多项式==来近似一个复杂的函数，搜索假设空间实际上是找出近似多项式前的==系数==，例如：采样自真实分布的$$\\boldsymbol{P_{data}={(x,y)|y=sin(x),x\\in[-5,5]}}$$的数据集，其中包含了观测误差$\\boldsymbol{\\varepsilon}$，这里选取的观测误差符合正太分布假如现在只搜索出所有1次多项式的模型关系，令偏置为0，即$\\boldsymbol{y=ax}$，如下图所示1次多项式的直线，很难找到一条直线较好地逼近真实数据的分布；接下来稍微增大假设空间，令假设空间为所有的==3次多项式函数==，即$\\boldsymbol{y=ax^3+bx^2+cx}$，显然此假设空间中的函数明显多于1次多项式的假设空间，因此可以找到一条曲线，能比1次多项式模型更好地反映了数据的关系；但是还不够好，因此再次增大假设空间，使得可以搜索的函数为==5次多项式==，即$\\boldsymbol{y=ax^5+bx^4+cx^3+dx^2+ex}$,在此假设空间中，能搜索到一个较好的函数。如图所示，函数的假设空间越大，就越有可能找到一个函数更逼近真实分布的函数模型。但是过大的假设空间会增加搜索难度和计算代价，在有限的计算资源的约束下，较大的假设空间并不一定能搜索出更好的函数模型，同时由于观测误差的存在，较大的假设空间中可能包含了大量表达能力过强的函数，能够将训练样本的观测误差也学习进来，从而伤害了模型的泛化能力。 ##过拟合和欠拟合 由于真实数据的分布往往是未知而且复杂的，无法判断出其分布函数的类型和相关参数，因此人们在选择模型容量时，往往会根据经验值来选择较大的模型容量，但是模型的容量较大时，有可能出现在训练样本上表现较好，但在测试样本上的表现较差，当模型的容量较小时，有可能出现在训练样本和测试样本表现皆不佳的现象。 下图为过拟合与欠拟合的示意图：####如何设计合适的模型容量？在已知的真实模型得情况下，我们可以设计容量合适的函数假设空间，从而获得不错的学习模型，但是在现实生活中，真实模型往往是无法得知的，因此设计的假设空间如果过小，导致无法搜索到合适的学习模型；设计得假设空间过大，导致模型泛化能力过差。 那么该如何去选择模型得容量？统计学习理论给我提供了一些思路，其中VC维度是一个应用比较广泛得度量函数容量的方法。==尽管这些方法给机器学习提供了一定程度得理论保证，但是这些方法却很少应用到深度学习中去，一部分原因是神经网络过于复杂，很难去确定网络结构背后的数学模型的VC维度。== 尽管统计学习理论很难给出神经网络所需要的最小容量，但是我们却可以根据奥卡姆剃刀原理来指导神经网络的设计和训练。奥卡姆剃刀原理的核心思想：切勿浪费较多东西，去做“用较少东西，同样可以做好的事情”，也就是说，如果两层的神经网络结构能够很好的表达真实模型，那么三层的神经网络也能够很好的表达，但是我们应该优先选择使用更简单的两层神经网络，因为它的参数量更少，更容易训练，更容易通过较少的训练样本获得不错的泛化误差###欠拟合当模型容量较小时，模型不能够很好地学习到训练集数据的模态，导致训练集上表现不佳，同时在未见得样本上表现也不佳，这种现象叫做欠拟合。 欠拟合的表征：当我们发现当前的模型在训练集上面误差一直维持较高的状态，很难优化减少，同时在测试集上也表现不佳时，我们可以考虑是否出现欠拟合。 欠拟合的解决方法：可以通过增加神经网络的层数、增大中间维度的大小等手段，比较好地解决欠拟合的问题，对于现在的神经网络，很容易就能达到较深的层数，因此模型的容量一般来说是足够的，在实际应用中常见的是过拟合 ###过拟合当模型容量较大时，网络模型除了学习到训练集数据的模态之外，还把额外的观测误差也学习进来，导致学习的模型在训练集上面表现较好，但是在未见的样本上表现不佳，也就是泛化能力偏弱。这种现象叫做过拟合。 ###如何有效检测并减少过拟合现象呢？####数据集的划分一开始将数据集划分为训练集和测试集，但是为了挑选模型超参数和检测过拟合现象，一般需要将原来的训练集再次切分为新的训练集和验证集，即数据集需要切分为训练集、验证集和测试集3个子集。#####验证集和超参数之前介绍了要将数据集划分为训练集和测试集，训练集是为了用于训练模型参数，测试集用于测试模型的泛化能力，但是将数据集划分为训练集和测试集是不够的，**==由于测试集的性能不能作为模型训练的反馈（即测试集中的样本不能参与模型的训练，防止模型“记住”数据的特征）==，而我们需要在模型训练时能够挑选出较合适的模型超参数，判断模型是否过拟合等，因此需要将训练集再次切分为训练集和验证集，划分过的训练集与原来的训练集的功能一致，用于训练模型参数，而验证集则用于选择模型的超参数（称为 模型选择，Model selection）** ==模型超参数与模型参数的区别==： 模型参数： 模型参数是模型内部的配置变量，可以用优化算法来更新的参数 模型参数一般不需要实践者手动设置 模型参数用数据估计或数据学习得到 模型超参数： 模型超参数通常由实践者手动直接设定 模型超参数通常可以使用启发式方法来设置，就像由验证集得出 模型超参数通常根据给定的预测建模问题而调整 ==超参数的功能包括==： 根据验证集的性能表现来调整学习率，权值衰减系数，训练次数等 根据验证集的性能表现来重新调整网络拓扑结构 根据验证集的性能表现判断是否欠拟合和过拟合 ==超参数主要包括==： 学习率 正则化参数 神经网络的层数 每一个隐藏层中神经元的个数j 学习的回合数Epoch 小批量数据minibatch的大小 输出神经元的编码方式 代价函数的选择 权重初始化方法 神经元激活函数的种类 参加训练模型数据的规模 因此根据验证集和测试集的区别在于：算法设计人员可以根据验证集的表现来调整模型的各种超参数的设置，提升模型的泛化能力；但是测试集的表现却不能用来反馈模型的调整，否则测试集将和验证集的功能重合，因此在测试集上面的性能表现将无法代表模型的泛化能力。在参加比赛时不能用测试集来挑选最好的模型。#####提前停止 我们把对训练集中的一个batch运算更新一次叫做一个step，对训练集的所有样本循环迭代一次叫做一个epoch。验证集可以在数次step或数次epoch后使用。验证的步骤过于频繁，能够精准地观测模型的训练情况，但是也会引入额外的计算代价，一般在几个epoch后进行一次验证运算以分类任务为例，在训练时，一般关注的指标由训练误差，训练准确率等，相应地，验证时也有验证误差和验证准确率，测试时也有测试误差和测试准确率。测试时也有测试误差，测试准确率。通过观测训练准确率和验证准确率可以大致推断模型是否过拟合和欠拟合。如果模型的训练误差较低，训练准确率较高 但是验证误差较高，准确率较低，那么可能出现欠拟合现象。 实际上，由于网络的实际容量可以随着训练的进行发生改变，因此在相同的网络设定下，随着训练的进行，可能观测到不同的过拟合/欠拟合状况。如下图：在相同的网络结构下 ，前期随着训练的进行，训练准确率和测试准确率都呈现增大的趋势，但是在训练的后期，由于模型的实际容量发生改变，可以观察到了过拟合的现象（训练准确率呈现增大的趋势，测试的准确率呈现下降的趋势，模型的泛化能力下降），==这是因为神经网络的有效容量和网络参数的状态息息相关，神经网络的有效容量可以很大，也可以通过稀疏化参数，添加正则化等手段降低==。 由图可知，竖直虚线所处的网络状态最佳，没有出现明显的过拟合现象，网络的泛化能力最佳，随后，epoch数增加，模型的泛化能力随之降低，因此可以选择最佳的epoch来提前停止训练，那么如何选取合适的epoch就停止训练，避免出现过拟合现象？ 可以通过观察验证指标的变化，来预测最适合的epoch可能的位置，具体地，对于分类问题，可以记录模型的验证准确率，并监控验证准确率的变化，当发现验证准确率连续P个epoch没有下降，可以预测已经达到了最适合的epoch附近，从而提前终止训练。##正则化 设计不同层数、大小的网络模型可以为优化算法提供初始的函数假设空间，但是模型的实际容量可以随着网络参数的优化更新而产生变化。以多项式函数模型为例：$$\\boldsymbol{y=\\beta_0+\\beta_1x+\\beta_2x^2+\\beta_3x^3+…+\\beta_nx^n+\\varepsilon}$$上述模型的容量可以通过$\\boldsymbol{n}$简单衡量。如果网络参数$\\boldsymbol{\\beta_{k+1}+…+\\beta_n=0}$，那么网络的实际容量退化到k次多项式的函数容量。**==因此，通过限制网络参数的稀疏性，可以来约束网络的实际容量==**。 这种约束一般通过==在损失函数上==添加额外的参数稀疏性惩罚项实现，在未加约束之前的优化目标是：$$\\boldsymbol{Minimize L(f_\\theta(x),y),(x,y)\\in \\mathbb{D}^{train}}$$对模型的参数添加额外的约束后，优化的目标变为：$$\\boldsymbol{Minimize L(f_{\\theta}(x),y)+\\lambda*\\Omega(\\theta),(x,y)\\in \\mathbb{D}^{train}}$$其中$\\boldsymbol{\\Omega(\\theta)}$表示对网络参数$\\boldsymbol{\\theta}$的稀疏性约束函数。一般地，参数$\\boldsymbol{\\theta}$的稀疏性约束通过约束参数$\\boldsymbol{\\theta}$的$\\boldsymbol{L}$范数实现，即：$$\\boldsymbol{\\Omega(\\theta)=\\sum_{\\theta_i}\\Vert\\theta_i\\Vert_l}$$###$\\boldsymbol{L0}$正则化$\\boldsymbol{L0}$正则化是指采用$\\boldsymbol{L0}$范数作为稀疏性惩罚项$\\boldsymbol{\\Omega(\\theta)}$的正则化方式，即：$$\\boldsymbol{\\Omega(\\theta)=\\sum_{\\theta_i}\\Vert\\theta_i\\Vert_0}$$其中$\\boldsymbol{L0}$范数$\\boldsymbol{\\Vert \\theta_i\\Vert_0}$定义为$\\boldsymbol{\\theta_i}$中非零元素的个数。通过约束$\\boldsymbol{\\sum_{\\theta_i}\\Vert \\theta_i\\Vert_0}$的大小可以迫使网络中的连接权值大部分为0，从而降低网络的实际参数量和网络容量。但是由于$\\boldsymbol{L0}$范数$\\boldsymbol{\\Vert \\theta_i\\Vert_0}$并不可导，不能利用梯度下降算法进行优化，在神经网络中使用的并不多。###$\\boldsymbol{L1}$正则化$\\boldsymbol{L1}$正则化是指采用$\\boldsymbol{L1}$范数作为稀疏性惩罚项$\\boldsymbol{\\Omega(\\theta)}$的正则化方式，即：$$\\boldsymbol{\\Omega(\\theta)=\\sum_{\\theta_i}\\Vert\\theta_i\\Vert_1}$$其中$\\boldsymbol{L1}$范数$\\boldsymbol{\\Vert \\theta_i\\Vert_1}$定义为张量$\\boldsymbol{\\theta_i}$中所有元素的绝对值之和。$\\boldsymbol{L1}$正则化也叫$\\boldsymbol{Lasso\\ Regularization}$，它是==连续可导的==，在神经网络中使用广泛。 在TensorFlow中可以实现如下: \"创建网络参数w1，w2\" w1 = tf.random.normal([4,3]) w2 = tf.random.normal([4,2]) \"计算L1正则化项\" loss_reg = tf.reduce_sum(tf.math.abs(w1))+tf.reduce_sum(tf.math.abs(w2)) ###$\\boldsymbol{L2}$正则化$\\boldsymbol{L2}$正则化是指采用$\\boldsymbol{L2}$范数作为稀疏性惩罚项$\\boldsymbol{\\Omega(\\theta)}$的正则化方式,即：$$\\boldsymbol{\\Omega(\\theta)=\\sum_{\\theta_i}\\Vert\\theta_i\\Vert_2}$$其中$\\boldsymbol{L2}$范数$\\boldsymbol{\\Vert \\theta_i\\Vert_2}$定义为张量$\\boldsymbol{\\theta_i}$中所有元素的平方和，$\\boldsymbol{L2}$正则化也叫$\\boldsymbol{Ridge\\ Regularization}$，它和$\\boldsymbol{L1}$正则化一样，也是==连续可导的==，在神经网络中使用广泛 loss_reg = tf.reduce_sum(tf.square(w1))+tf.reduce_sum(tf.square(w2)) ###正则化在训练网络中的应用在进行实际训练时，一般先尝试较小的正则化系数$\\boldsymbol{\\lambda}$，观测网络是否出现过拟合现象。然后尝试逐渐增大$\\boldsymbol{\\lambda}$参数来增加网络参数稀疏性，提高泛化能力。但是过大的$\\boldsymbol{\\lambda}$参数有可能导致网络不收敛，需要根据实际任务调节。","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"深度可分离卷积","slug":"深度可分离卷积","date":"2022-09-09T07:13:38.544Z","updated":"2022-09-09T07:13:38.544Z","comments":true,"path":"2022/09/09/shen-du-ke-fen-chi-juan-ji/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shen-du-ke-fen-chi-juan-ji/","excerpt":"","text":"深度可分离卷积 与常规卷积相比，参数量更少","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"深层的神经网络","slug":"深层的神经网络","date":"2022-09-09T07:13:38.337Z","updated":"2022-09-09T07:13:38.338Z","comments":true,"path":"2022/09/09/shen-ceng-de-shen-jing-wang-luo/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shen-ceng-de-shen-jing-wang-luo/","excerpt":"","text":"#前提概念：希腊字符(α：alpha，θ：theta)####噪声数据(无意义的数据)：噪声数据是指数据中存在着错误或异常(偏离期望值)的数据，这些数据对数据的分析造成了干扰。影响：很多算法，特别是线性算法，都是通过迭代来获取最优解的，如果数据中含有大量的噪声数据，将会大大的影响数据的收敛速度，甚至对于训练生成模型的准确也会有很大的副作用。处理方法：1.回归如果变量之间存在依赖关系，即，那么我们可以设法求出依赖关系f，从而根据x来预测y，这也是回归问题的实质。实际中更常见的假设是，N是正态分布。假设y是观测值且存在噪声，如果我们能求出x和y之间的依赖关系，从而根据x来更新y的值，就可以去除其中的随机噪声，这就是回归去噪的原理 [1] 。2.异常值检测数据中的噪声可能有两种，一种是随机误差，另外一种可能是错误，比如我们手上有一份顾客的身高数据，其中某一位顾客的身高纪录是20m，很明显，这是一个错误，如果这个样本进入了我们训练数据可能会对结果产生很大影响，这也是去噪中使用异常值检测的意义所在。当然，异常值检测远不止去噪这么一个应用，网络入侵检测、视频中行人异常行为检测、欺诈检测等都是异常值检测的应用。####加权平均1.一般来说，平均数反映了一组数据的一般水平，利用平均数，可以从横向和纵向两个方面对事物进行分析比较，从而得出结论。例如，要想比较同一年级的两个班同学学习成绩，如果用每个班的总成绩进行比较，会由于班级人数不同，而使比较失去真正意义。但是如果用平均分数去比较，就可以把各班的平均水平呈现出来。从纵向的角度来看，可以对同一个事物在不同的时间内的情况利用平均数反映出来，例如，通过两个不同时间人均年收入来比较人们生活水平、经济发展等状况。2.在一组数据里，一个数据出现的次数称为权，也可以认为是这个数据的占总体数据的概率，在一组数据中，不同的数据的权重可以不一样。加权平均数f1+f2+f3，…，+fk = 1f1，f2，…，fk叫做权算术平均实际上是一种特殊的加权平均，即权重相同的加权平均####数字图像的一阶微分和二阶微分一阶微分：（1）在恒定灰度区域的微分值为零； （2）在灰度台阶或斜坡处微分值非零； （3）沿着斜坡的微分值非零；二阶微分：（1）在恒定灰度区域的微分值为零； （2）在灰度台阶或斜坡起点处微分值非零； （3）沿着斜坡的微分值为零；对于一维函数f(x)，其一阶微分的基本定义是差值二阶微分的定义为： ###卷积神经网络概念：深度学习网络与常见的单一隐藏层神经网络的区别在于深度，深度学习网络中，每一个节点在前一层输出的基础上学习识别一组特定的特征。随着神经网络深度增加，节点所能识别的特征也就越来越复杂 CNN实际上也就是在每一层结构中设置一个滤波器不断提取特征，然后通过修改权值进行特征选择，接着进行分类的过程，卷积在CNN里，就是充当前排步兵，首先对原始图像进行特征提取。所以我们首先要弄懂卷积在干什么，才能弄懂CNN。 构建卷积神经网络的任务在于构建这些滤波器，也就是，将这些滤波器训练成能识别特定特征，让各个卷积层的滤波器能够组合起来最优化的检测特定的模式。 卷积公式(加权平均积)：卷积在图像处理中的应用：source pixel原始像素点convolution kernel 卷积核该图片选用3*3的卷积核，卷积核内共有九个数值，所以图片右上角公式中一共有九行，而每一行都是图像像素值与卷积核上数值相乘，最终结果-8代替了原图像中对应位置处的1。这样沿着图片一步长为1滑动，每一个滑动后都一次相乘再相加的工作，我们就可以得到最终的输出结果。除此之外，卷积核的选择有一些规则：1）卷积核的大小一般是奇数，这样的话它是按照中间的像素点中心对称的，所以卷积核一般都是3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。2）卷积核所有的元素之和一般要等于1，这是为了原始图像的能量（亮度）守恒。其实也有卷积核元素相加不为1的情况。3）如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。4）对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。注：同样提取某个特征，经过不同的卷积核卷积后的效果也不一样(卷积核的大小有讲究)边界补充问题卷积核的大小比图片小时，会造成卷积得到的图片比原图片小，为了避免这种情况，需要先对原图片进行边界填充处理。填充的大小要根据卷积核的大小来判断。填充方式有：1.补零填充(用零在除原始图片之外的位置填充)1.补零填充的好处：我们可以获得更多更细致的特征信息，可以获取到更多的图像边缘信息 2.可以控制卷积层输出的特征图像的大小，从而可以达到控制网络结构的作用，还可以为提取出来的特征图像添加多一层卷积层2.边界复制填充(以原始图片位置上元素的值为参照，在除原始图片之外的地方填充相应的元素)3.镜像填充(以原始图片为参照，在原始图片之外的位置作原始图片的镜像填充)4.块填充(在原始图片之外的位置填充与原始图片一样的元素)####如何理解卷积神经网络的结构（Structure）？神经网络的评判标准：以最少的代价，使神经网络获得最好的准确率(关键词：代价，准确率)如何让机器去检测图片呢？实际上就是将所有的像素点放入一个神经网络(全连接层)，如果直接把所有像素点放到全连接层，单单是一个3通道32×32的图片，就会得到3 * 32 * 32 * 1024+1024 * 512+512 * 10+1024（bias）+512 ( bias )= 3676672 个参数，运算量十分巨大，但我们只要主要提取边缘特征，对于灰色和黑色这种冗余或者不重要的的区域特征，我们尽量丢弃或者少保留，那么这样可能会减少参数或者减少提参数的过程。所以我们要在全连接层前面，对输入图像进行预处理，也就是加一个采样层采样层的作用：对卷积层提取的特征数据进行特征选择，尽量减少参数 对我们人类的大脑来说，如果把一张图片按照一定的规律分割后，我们的大脑还是有能力还原图片进行识别的也就是说，我们发现了两个现象：1.如果我们只知道局部的图片，以及局部的相对位置，只要我们能将它正确组合起来，我们也可以对物体进行识别2.同时局部与局部之间关联性不大，也就是局部的变化，很少影响到另外一个局部我们还要解决两个问题：1.输入的只是原始图片，我们还没有提取图片的特征2.我们目前要处理的参数仍然非常多，我们需要对原始输入进行降维或者减少参数因此我们要在采样层前面加一层卷积层，我们得到以下神经网络卷积层的作用：对原始数据进行特征提取，再将提取的特征数据传给采样层####一张图片特征这么多，一个卷积层提取的特征数量有限的，提取不过来啊！我怎么知道最后采样层选出来的特征是不是重要的呢？在这里就要引入一个新概念————级联分类器从一堆弱分类器里面，挑出一个最符合要求的弱分类器，用着这个弱分类器把不想要的数据剔除，保留想要的数据。列如：AdaBoost算法一种迭代算法，针对同一个训练集训练不同的分类器(弱分类器)，然后**把这些弱分类器集合起来，构成一个更强的最终分类器(强分类器)**，对上一级保留的数据，把不想要的数据剔除，保留想要的数据。针对上面的问题，我们可以级联一个卷积层和采样层，这样一个最简单的神经网络就诞生了，这个最简单的卷积神经网络说到底，终究是起到一个分类器的作用CNN的三种模块：1.卷积层2.采样层3.全连接层 大致上可以理解为： 通过第一个卷积层提取最初特征，输出特征图（feature map）通过第一个采样层对最初的特征图（feature map ）进行特征选择，去除多余特征,重构新的特征图第二个卷积层是对上一层的采样层的输出特征图（feature map）进行二次特征提取第二个采样层也对上层输出进行二次特征选择全连接层就是根据得到的特征进行分类 ####激活函数从上图可以看出从采样层提取出来的特征是再次进入一个卷积层，但事实上，从下采样层出来的结果，不是又到了一个卷积层，而是进入了一个激活函数(activation function) 在现实生活中，我们用神经网络来解决的分类问题，一般都不是简单的线性二分类，一般是非线性的分类，可以想到是否可用多个简单神经网络来逼近一个非线性的函数，由于神经网络的公式是线性的，线性函数具有可加性齐次性，任意线性函数连接都可以等价为一个单一线性函数，因此即使由多个简单的神经网络叠加形成的复杂的神经网络也是一个线性的表达式那么我们是否能将线性的神经网络转成非线性的？我们引入一个概念特征组合特征组合是指通过两个或多个输入特征相乘来对特征空间中非线性规律进行编码的合成特征eg.X1和X2是两个输入特征，我们定义X3=X1*X2为X1和X2组合形成的一个特征组合。特征组合的种类就是将不同的输入特征两个或两个以上组合在一起形成的特征组合，特征组合还可以是两个同样的输入特征组合在一起(表示对单个特征的值求平方)机器学习模型会经常组合独热特征矢量，将独热特征矢量视为逻辑连接，对每个特征进行独热编码就会生成具有多元特征的矢量，将这些独热编码进行特征组合就可以得到可解读为逻辑连接的多元特征。经过特征组合最终获得的预测能力远远超过任一特征单独的预测能力常见的激活函数在选取激活函数时要考虑输入和输出以及数据变化，如ReLu的输入只能大于0，如果输入有负数，ReLu就不适合，但对于图片格式ReLu还是很常用的。激活函数的好处提高模型的鲁棒性，非线性表达能力，缓解梯度消失问题，将特征图映射到新的特征空间从而更有利于训练，加速模型收敛等问题都有较好的帮助。 ####卷积层是如何提取特征的？卷积核(滤波器，convolution kernel)是可以用来提取特征的，图像和卷积核卷积，就可以得到特征值(destination value)卷积核放在神经网络里，就代表对应的权重（weight)卷积核和图像进行点乘（dot product), 就代表卷积核里的权重单独对相应位置的Pixel进行作用这里我想强调一下点乘，虽说我们称为卷积，实际上是位置一一对应的点乘，不是真正意义的卷积比如图像位置（1,1）乘以卷积核位置（1,1），仔细观察右上角你就会发现了至于为什么要把点乘完所有结果加起来，实际上就是把所有作用效果叠加起来,RGB图像就是由红绿蓝分量叠加起来构成的卷积核里的数相当于权重，权值与反向传播算法有关神经网络公式：先定义bias = 0，我们分别对三个分量的其中一个3×3的九宫格进行卷积，下图是在分量的中间找一个3×3的九宫格W1output = 1*(-1) +1* 1+1* 0+0*(-1)+1* 0+2* 1+0*(-1)+1* 1+2*(-1) =1W2output = 2* 1+2 * 0+1* 1+1* 1+0* 1+0* 2+0* 1+0* 0+11=5W3output = 1(-1)+1*(-1)+0*(-1)+0* 2+0*(1)+0* 2+1* 0+1* 1+0*1 = -1Bias = 0Final_output =W1output + W2output+W3output+bias= 1+5-1+0 = 5三个卷积核为什么要叠加在一起？可以理解为三个颜色特征分量叠加成RGB特征分量对于图像的卷积操作有一定的顺序，不能随机找图像的像素点进行卷积由于卷积输出的特征图除了特征值本身外，还包含相对位置信息，因此提取出相应的特征值也是按照这个顺序排列的。卷积移动的距离称为步长，在进行卷积时它的步长可由我们自己定义。","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"如何理解卷积神经网络","slug":"如何理解卷积神经网络","date":"2022-09-09T07:13:38.335Z","updated":"2022-09-09T07:13:38.335Z","comments":true,"path":"2022/09/09/ru-he-li-jie-juan-ji-shen-jing-wang-luo/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/ru-he-li-jie-juan-ji-shen-jing-wang-luo/","excerpt":"","text":"","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"卷积神经网络的结构和卷积原理","slug":"卷积神经网络的结构和卷积原理","date":"2022-09-09T07:13:38.167Z","updated":"2022-09-09T07:13:38.168Z","comments":true,"path":"2022/09/09/juan-ji-shen-jing-wang-luo-de-jie-gou-he-juan-ji-yuan-li/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/juan-ji-shen-jing-wang-luo-de-jie-gou-he-juan-ji-yuan-li/","excerpt":"","text":"###卷积神经网络在图像识别的任务 在利用卷积神经网络在训练图像识别，目标检测等任务上时，要首先明白，所训练出来的模型是人们想要这个模型能预测的指向方向，可以类比自然界中的一些生物，生物所看到的景象并非世界的原貌，而是长期进化出来的适合自己生存环境的一种感知方式，就像蛇的感知系统与人类的不一样，因为蛇的猎物一般是在夜晚出现。任何视觉系统都是将图像反光与脑中所出现的概念进行关联，因此训练的目的就是让模型学习这种概念。通过训练集的数据输入，以及损失函数的指正，让训练模型具备一定的预测能力。 ####图像识别的输入数据上图是一张正常图像的结构，depth代表这张图像的通道数（RGB），height代表这张图像的高度，width代表这张图像的宽度，每张图像都是由若干个像素点组成，在计算机中用矩阵表示图像，将每张图像的矩阵作为输入数据来训练模型####画面不变性 平移不变性 旋转和视角不变性 尺寸不变性 光元素不变性 在人们的视野里，一个物体不论在图像的的任何位置中显示，以任何角度显示，以任何比例显示，亦或者以添加了任何的色素，人们都能很容易地分辨出这个物体。但现在的计算机还未达到真正的人工智能的地步，因此我们所训练的模型希望可以尽可能的满足这些目标，这些特点称为画面不变性，卷积神经网络对处理画面不变性有很大的贡献。 ###卷积神经网络的结构####卷积层 卷积操作是卷积神经网络的重点，卷积核是进行卷积操作的工具，卷积核也是一个矩阵，卷积核的大小可以自己定义，不同大小的卷积核扫描出来的Feature Map蕴含的信息也不同，卷积核也可以称为权重矩阵，刚开始的卷积核的数值是随机的，随着训练的进行，通过BP反向传播权重，更新参数，到模型收敛时，能更好地拟合，训练卷积神经网络模型实际上是训练出每个卷积核的参数。 在卷积神经网络中的每层结构中对数据的处理，一般是将图像矩阵转化为一个一维向量，但是要将图像矩阵中的每个像素点进行编号，便于当卷积核扫描到相应编号的像素点时能判断与哪个权重相乘，这些像素点的值与权重相乘得出的结果，卷积后的输出要将向量转化为矩阵（Feature Map），这样的目的在于：防止丢失图像平面结构信息，这个图像矩阵再作为下一层结构的输入，最后经过（二分类用sigmoad函数来进行归一化，多分类问题用Softmax函数）Softmax函数将输出归一化到（0，1）区间内，可以看成是概率来理解，接着通过交叉熵损失函数来判断，是否为最好的达到拟合，如果不是没有达到，则反向传播误差，用来更新卷积核的权重。 ####卷积操作 用卷积核（filter）扫描过图像矩阵的每个地方，将所扫描到图像矩阵的部分区域上的像素点（局部感受野（local receptive fields））的值与卷积核上相应位置上的相乘得出一个值（下一层上的神经元），这个卷积核根据步长（stride）的大小，在图像矩阵上移动，直到扫描完整个图像矩阵才结束。卷积操作如图所示：Feature Map 尺寸：$(input_size + 2 * padding_size − filter_size)/stride+1$ depth维的处理根据上面介绍的图像的结构是三维张量的形式，卷积核的卷积操作也应该对其depth维数据进行操作，因此卷积核的depth维数与图像depth维数是相同的，假设filter size：n×n，depth维:m(与图像的depth维数相同),则图像上的n×n×m个像素点被filter给贯穿，这些输入节点连接到一个输出节点上注意：卷积核depth维上的三个卷积权重不是相同的，不同通道数用的是自己的权重，但在不同的局部感受野上这三个权重是共享的。 ####概念抓取 训练卷积神经网络的目的就是为了让训练模型具备一定的分析能力，所以让它学习概念的根本。上面已经介绍了卷积的操作，卷积操作输出的是输入数据经过卷积核的侧重所得到的特征图。将特征图（输出数据）与样本的真实输出相比，然后求得误差来更新卷积核的权重 多个filter提取特征一般来说，CNN每层之间有多个卷积核来提取特征，但filter的数量并不是越多越好，按理说越多特征提取器提取的特征会更多更有利于拟合，但过多的特征会使特征维数爆炸，还可能给训练模型引入过多的冗余特征。每增加一个filter来提取特征，Feature Map也会多一个，这样卷积层的输出不再是depth为1的平面，而是一个立体的长方体，这个长方体还会作为输入数据传给下一个卷积层进行处理。 ###池化层（Pooling） 通常使用的池化操作为平均值池化（average pooling）和最大值池化（max—pooling）。池化不需要学习权重参数，进行池化时只需要指定池化的类型（平均值池化和最大值池化）、池化操作的核的大小和步长即可 ####池化的目的 在经过卷积后，得出一张张特征图，下一步就要利用这些特征去做分类，但是如果直接用这些特征去训练分类器，维度还是太高，计算量太大，然而通过池化操作可以实现降低特征的维度，减少过拟合的出现。 池化并不仅仅是将特征的维度降低，不同的池化类型所起的效果也不一样，平均值池化可以很大程度上保留图像背景的信息，最大值池化能突出卷积层所提取的特征。 Average-pooling公式：$$y_{i^{l+1},j^{l+1},d^{l+1}}=\\frac{1}{HW}\\sum_{0\\leqslant{i}&lt;{H},0\\leqslant{j}&lt;{W}}x^l_{i^{l+1}\\times{H}+i,j^{l+1}\\times{W}+j,d^l}$$$l$表示当前层数，$i,j,d$分别表示Height维，weight维，depth维，相当与这个长方体的坐标表示，$H,W$表示池化选取核的长和宽，求和公式表示被池化核所包围的区域内的数值进行求和，最后再取平均。Max-pooling公式：$$y_{i^{l+1},j^{l+1},d^{l+1}}=\\max_{0\\leqslant{i}&lt;{H},0\\leqslant{j}&lt;{W}}x^l_{i^{l+1}\\times{H}+i,j^{l+1}\\times{W}+j,d^l}$$表示在被池化核所包围的区域内的数值取最大值。###激活函数 激活函数可以为神经网络加入非线性变化，卷积操作中的矩阵点乘的操作属于线性运算，如果没有激活函数的帮忙，该训练模型最终会变成一个线性函数映射，但在现实中并不是所有关系之间都是线性的，因此引入非线性可以增强网络的表达能力。 线性的神经网络模型连下面最简单的分类问题都解决不了：没有激活函数的帮助，线性分类器最大程度能做到这样：这样的线性边界并不能最好的把两个映射划分开来，但是加入激活函数后，激活函数扭曲空间，这样得到的线性边界就能很好的把两部分区分开来：sigmoid函数二分类一般使用这个函数 公式：$$\\sigma(x)=\\frac{1}{1+e^{-x}}$$ 它能把$\\boldsymbol{x\\in R}$的输入“压缩”到$\\boldsymbol{x\\in [0,1]}$区间，这个区间的数值一般用来表示以下意义： 概率分布$[0,1]$区间的输出和概率的分布范围契合，可以通过Sigmoid函数将输出转译为概率输出 信号强度一般可以将0~1理解为某种信号的强度，如像素的颜色强度，1表示当前通道颜色最强，0表示当前通道无颜色，抑或代表门控值的强度，1表示当前门控值全部开放，0表示门控关闭 ==注意：Sigmoid函数在输出层将输出压缩到$\\boldsymbol{[0,1]}$，但是不会考虑输出节点之间的关系。== Relu函数==Sigmoid函数在输入值较大或较小时容易出现梯度值接近于0的现象，称为梯度弥散现象，使得网络参数长时间得不到更新，因此很难训练出较深层次的网络模型。==Relu对于小于0的值全部抑制为；对于正数则直接输出，这种单边抑制特性来源于生物学，这样的函数具有优良的梯度特性 LeakyRelu函数==Relu函数在$\\boldsymbol{x&lt;0}$时梯度值恒为0，也可能会造成梯度弥散现象，为了克服这个问题，LaeaktRelu函数被提出== $$\\text {LeakyReLU}=\\left{\\begin{array}{c}x \\quad x \\geq 0 \\p * x \\quad x&lt;0\\end{array}\\right.$$==其中p为用户自己设置的某较小数值的超参数，如0.02.当p=0时LeakyRelu函数会退化为Relu函数；当p≠0时，x&lt;0能够获得较小的梯度值p从而避免出现梯度弥散现象== 在TensorFlow中可以通过tf.nn.leaky_relu函数来实现 tanh函数公式：$$tanh(x)=\\frac{e^x-e^{-x}}{e^x+e^{-x}}$$ softmax函数这个函数一般用来处理多分类的情况公式：$$\\sigma(x)i=\\frac{e^{z_i}}{\\sum^{N}{j=1}e^{z_j}}$$ TensorFlow中提供了一个接口，可以将Softmax和交叉熵损失函数同时实现，防止出现数值溢出的问题，维持了数值的稳定，函数式接口为：==tf.keras.losses,categorical_crossentropy(y_true,y_pred,from_logits=False)==，其中y_true代表了one-hot编码后的真实标签，y_pred表示网络的预测值，当from_logits设置为True时，y_pred表示须为未经过Softmax函数的变量z；当from_logits设置为False时，y_pred表示经过Softmax函数的输出###全连接层（fully connected layers） 全连接层在神经网络中起到“分类器”的作用。如果说之前的卷积，激活，池化等操作是为了将原始数据映射到隐层特征空间的话，全连接层则是将这些隐层特征空间映射到样本的标记空间（线性可分的空间） 全连接层具体操作实际上也是卷积操作，对前一层是全连接层的输出，此时全连接层可以转化为卷积核为1×1的卷积，如果前一层是卷积层的输出，则全连接层可以转化为$n$个卷积核，该卷积核的大小和前一层的输出的数据大小相同，$n$的取值取决于全连接层有多少个神经元，以VGG—16网络模型为例，最后一层卷积层输出为7×7×512的特征张量，若后一层是一层含4096个神经元的全连接层，则可以用一个7×7×512×4096的卷积层去实现全连接运算过程。 注意：==1×1的卷积==的通道数的和前一层的通道数相同时，实际上这也是一种全连接的表现，当==1×1的卷积==的通道数与前一层的特征图的通道数不相同的时候，使用1×1卷积可以实现降维、升维来改变训练参数的数量，1×1卷积还能为神经网络添加非线性表达能力，因为在进行卷积操作后还要进行池化和激活，相当于多进行一次激活。 全连接层将前一层输出的所有Feature Map（细节特征）通过权重矩阵与全连接层的神经元相连，该神经元代表着所有的这些Feature Map组合起来的特征（组合特征），根据权重矩阵的不同，组合起来的特征也不相同，最后一层全连接层将全连接层上的神经元（组合特征）输出。参考 全连接层的组成大部分的全连接层都是两层或者两层以上，这是为了让全连接层的输出去拟合数据分布，因为全连接层中的一层的一个神经元可以看成一个多项式，利用泰勒展开多项式去拟合光滑函数的原理。 import tensorflow as tf X = tf.random.normal([2,784]) W1 = tf.Variable(tf.random.truncated_normal([784,256])) b1 = tf.Variable(tf.zeros([256])) o1 = tf.matmul(X,W1) + b1 o1 = tf.nn.relu(o1) print(o1) ###目标函数 目标函数是用来判断卷积网络的预测值与样本实际值之间的误差的一个函数，常用的有均方代价损失函数和交叉熵损失函数。 全连接层中的输出通过激活函数的非线性映射，可以得到每个神经元的预测概率（多分类的情况下，二分类一般只有两个神经元输出），也就是神经网络训练出来的非线性函数的输出值，接着通过损失函数可以通过比较这个非线性函数值和实际样本的值来算出误差的大小。通过反向传播误差，可以使这个训练模型（非线性函数）能拥有更好的分辨能力，更拟合实际样本的值，并使得目标函数的误差值越来越小。 ###反向传播 前馈运算后神经网络通过目标函数得出输出层的误差，在训练模型时为了优化神经网络的性能，接下来就要利用这个输出层的误差求出前面层的误差。 假设这个目标函数是：$$\\boldsymbol{J(w,b)=\\frac{1}{2m}\\sum^m_{i=1}|a^l_i-y_i|^2}$$声明反向传播中要用到的一些函数：$$激活函数：\\boldsymbol{a^l_i=\\sigma(z^l_i)}$$ $$卷积层输出：\\boldsymbol{z^l_i=\\sum_ia^{l-1}*w^l_i+b^l_i}$$ $$误差计算：\\boldsymbol{\\delta^l_i=\\frac{\\partial J(w,b)}{\\partial z^l_i}}$$$l$表示当前所位于的层数$i$表示当前层的第$i$个神经元$*$表示卷积运算####传播过程输出层 通过目标函数知道预测值与实际样本之间的总误差$\\boldsymbol{J(w,b)}$,但是==卷积神经网络需要知道输入值$\\boldsymbol{w，b}$的改变对这个误差有多少影响==，这时就需要用到梯度来求解。先推导$\\boldsymbol{w}$的影响，利用公式：$$\\boldsymbol{\\frac{\\partial J(w,b)}{\\partial w^L}=\\frac{\\partial J(w,b)}{\\partial a^L}\\frac{\\partial a^L}{\\partial z^L}\\frac{\\partial z^L}{\\partial w^L}=(a_i-y_i)\\sigma’(z^L_i)a^{L-1}}$$再推到$\\boldsymbol{b}$的影响，利用公式：$$\\boldsymbol{\\frac{\\partial J(w,b)}{\\partial b}=\\frac{\\partial J(w,b)}{\\partial a^l}\\frac{\\partial a^l}{\\partial z^l}\\frac{\\partial z^l}{\\partial b^l}=(a_i-y_i)\\sigma’(z^L_i)}$$此时输出层的误差为$$\\boldsymbol{\\delta^L_i=\\frac{\\partial J(w,b)}{\\partial z^L_i}=\\frac{\\partial J(w,b)}{\\partial a^L_i}\\frac{\\partial a^L_i}{\\partial z^L_i}=(a_i-y_i)\\sigma’(z^L_i)}$$$L$表示输出层 全连接层 计算完输出层的误差后，就可以利用该误差计算推到上一层的误差，而输出层的上一层就是全连接层，现在来推导全连接层的反向传播的过程利用公式：$$\\boldsymbol{\\delta^l_i=\\frac{\\partial J(w,b)}{\\partial z^l_i}=\\frac{\\partial J(w,b)}{\\partial z^{l+1}_k}\\frac{\\partial z^{l+1}_k}{\\partial z^l_i}}$$$$\\boldsymbol{∵z^{l+1}k=\\sum_iw^{l+1}{ki}*a^l_i+b^{l+1}k=\\sum_iw^{l+1}{ki}*\\sigma(z^l_i)+b^{l+1}_k}$$$$\\boldsymbol{∴\\delta^l_i=\\frac{\\partial J(w,b)}{\\partial z^l_i}=\\frac{\\partial J(w,b)}{\\partial z^{l+1}_k}\\frac{\\partial z^{l+1}k}{\\partial z^l_i}=\\sum_kw^{l+1}{ki}\\delta^{l+1}\\sigma’(z^l_i)}$$也可以写为：$$\\boldsymbol{\\delta^l_i=((w^{l+1})^T\\delta^{l+1})\\odot\\sigma’(z^l)}$$$\\boldsymbol{k}$表示下一层的若干个神经元，$\\boldsymbol{\\odot}$表示点积运算 全连接层$\\rightarrow$池化层 由于池化层没有激活函数，可以令激活函数为$\\sigma(z)=z$，激活后就是它自身，该激活函数的导数为1，在前面已经得到全连接层的误差，接下来就要用该误差来推导池化层的误差，方法和上面说的一样，利用误差递推公式：$$\\boldsymbol{\\delta^l_i=((w^{l+1})^T\\delta^{l+1})\\odot\\sigma’(z^l)}$$$$\\boldsymbol{∵\\sigma(z^l)=1}$$$$\\boldsymbol{∴\\delta^l_i=(w^{l+1})^T\\delta^{l+1}}$$ 卷积层 ==因为池化层把卷积层的输出尺寸变小了，因此在得到池化层误差的前提下，要通过反卷积（upsample）的操作将误差的尺寸恢复到与卷积层的输出尺寸一致==例如：得到池化层的误差$\\boldsymbol{\\delta^{l+1}}$为：$$\\begin{pmatrix}1&amp;2\\3&amp;4\\end{pmatrix}$$接下来要对这个误差进行还原：如果是最大值池化，且在前馈运算的过程记录了最大值的位置分别是（左上、右下，左下，右上），则还原后为：$$\\begin{pmatrix}1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;2\\0&amp;0&amp;0&amp;4\\3&amp;0&amp;0&amp;0\\end{pmatrix}$$如果是平均值池化，则还原后为：$$\\begin{pmatrix}0.25&amp;0.25&amp;0.5&amp;0.5\\0.25&amp;0.25&amp;0.5&amp;0.5\\0.75&amp;0.75&amp;1&amp;1\\0.75&amp;0.75&amp;1&amp;1\\end{pmatrix}$$还原后的值就是上一层的$\\boldsymbol{\\frac{\\partial J(w,b)}{\\partial a^{l}_k}}$的值，而卷积层的误差由公式：$$\\boldsymbol{\\delta^{l}_k=(\\frac{\\partial a^{l}_k}{\\partial z^{l}_k})^T\\frac{\\partial J(w,b)}{\\partial a^{l}_k}=upsample(\\delta^{l+1}_k)\\odot\\sigma’(z^{l}_k)}$$ 卷积层$\\rightarrow$池化层 前馈运算中卷积层的输出为：$\\boldsymbol{a^l=\\sigma(a^{l-1}*w^l+b^l)}$，在知道卷积层的误差的前提下，可以推导出卷积层上一层的误差利用公式：$$\\boldsymbol{\\delta^l=\\frac{\\partial J(w,b)}{\\partial z^l}=(\\frac{\\partial z^{l+1}}{\\partial z^l})^T\\frac{\\partial J(w,b)}{\\partial z^{l+1}}=(\\frac{\\partial z^{l+1}}{\\partial z^l})^T\\delta^{l+1}=\\delta^{l+1}*rot180(w^{l+1})\\odot\\sigma’(z^{l-1})}$$$\\boldsymbol{rot180(w^{l+1})}$表示将卷积核上下翻转一次，再左右翻转一次","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"什么是算子","slug":"什么是算子","date":"2022-09-09T07:13:38.067Z","updated":"2022-09-09T07:13:38.068Z","comments":true,"path":"2022/09/09/shi-me-shi-suan-zi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shi-me-shi-suan-zi/","excerpt":"","text":"什么是算子？算子是一个函数空间到函数空间上的映射O：X→X。广义上的算子可以推广到任何空间，如内积空间等，总而言之，算子就是映射，就是关系，就是变换。特征值对于一个输入和输出函数类型相同的算子T，满足的k称为T的特征值，相应的称作T关于k的特征函数。 微分算子在数学中，微分算子是定义为微分运算之函数的算子。微分算子 拉普拉斯算子拉普拉斯算子（Laplace Operator）是n维欧几里德空间中的一个二阶微分算子，定义为梯度（▽f）的散度（▽·f）。拉普拉斯算子也可以推广为定义在黎曼流形上的椭圆型算子，称为拉普拉斯-贝尔特拉米算子。 幺正矩阵幺正矩阵表示的就是厄米共轭矩阵等于逆矩阵，对于实矩阵，厄米共轭就是转置，所以实正交矩阵是幺正矩阵的特例。定义若一n行n列的复数矩阵U满足：其中，为的共轭转置，为n阶单位矩阵，则称U为酉矩阵。判别准则酉矩阵的共轭转置和它的逆矩阵相等。性质和应用设有矩阵A，B，则1.若A是幺正矩阵，则A的逆矩阵也是幺正矩阵2.若A，B是幺正矩阵，则AB和BA也是幺正矩阵3.若A是幺正矩阵，则det(A) = 14.A是幺正矩阵的充分必要条件是，它的n个列向量是两两正交的单位向量可应用于特征降维广义幺正矩阵定义假定表示所有m×n复矩阵的集合，表示所有n阶复可逆矩阵的集合，表示所有m×n实矩阵的集合，，（,表示纯虚数）。性质定理1，若相似于一个酉矩阵U，则A是n阶P-广义酉矩阵。 推论1，若相似于一个酉矩阵U，则与相似。 定理2，已知A可对角化，则A为n阶P-广义酉矩阵的充分必要条件是A相似于一个酉矩阵。 定理3，已知A是n阶P-广义酉矩阵。如果λ≠0是A的特征值，那么1/λ是的特征值；当A为实矩阵时，1/λ也是A的特征值。 定理4，若A为广义P-酉矩阵，则A是广义PH-酉矩阵。 偏导数、微分、以及导数的关系与区别导数描述的是函数在一个点的变化快慢的趋势，是一个变化的速率微分描述的是函数从一个点(移动一个无穷小量)到另一个点的变化的量。偏导数描述多元函数在降维下的导数，即只对多元函数中的一个变量求导，固定其他变量不变。方向导数对于多元函数(有多个维度),函数图像上的点有无数条曲线经过，那么在该点必然有无数条切线，数学家们定义方向导数来表示这些切线的斜率，即导数，方向导数的实际是：在多元函数图像上的某一点上经过该点的无数条曲线的切线的斜率，每一条切线都代表一个变化的方向。梯度表示方向导数中最大的导数，梯度是一个向量全微分：多元函数从A到B的变化可以用一个线性变化来逼近，只要取的变化区间无穷小，总能找到一个多元的线性函数对这种变化的量进行逼近 矩阵的求导常见的矩阵求导的方式有:向量对向量求导，标量对向量求导，向量对标量求导1.向量对向量求导标量对向量求导3.向量对标量求导","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"YOLO-V3","slug":"YOLO-V3","date":"2022-09-09T07:13:37.982Z","updated":"2022-09-09T07:13:37.984Z","comments":true,"path":"2022/09/09/yolo-v3/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/yolo-v3/","excerpt":"","text":"YOLO-V3 YOLO-V3是比较完善的一个目标检测的框架，它经过一代一代的发展，一步步地完善，接下来介绍一些YOLO-V3在V2的基础上进行了哪些的改进，下图为我训练出来模型的检测效果 先验框的更新在V2中，先验框是由K-mean聚类算法得出的5种不同尺寸的先验框，在V3中考虑到Darknet-53会输出三种尺寸的预测，因此选取先验框时应该选取的是3的倍数，最终选择了9种先验框，每种尺寸都有三种不同形状的先验框。 先验框的选择仍然是通过K-mean聚类出9种，这9种聚类得出的先验框之间不是没有关系的，其中每种尺寸的特征图都有其专属的三种基本相同大小的先验框用来预测，例如：13×13尺寸的特征图中会有三种较大的先验框用来预测，26×26的特征图会有较中等的三种先验框用来预测，52×52的特征图则会有三种较小的先验框用来预测 K-mean聚类的距离度量方法仍然是利用IOU来计算，这些先验框都是根据groundtruth的数据聚类出来的 正负样本分配在前面的学习，我们已经知道除了要计算有物体的网格的损失，还要计算不含物体的网格的损失，因此就有了正负样本的说法 根据上面聚类出来的9种先验框，计算出三个尺寸所对应的三个先验框与groundtruth的IOU，具体做法为：每个尺寸用对应的三种大小的先验框去与这个尺寸的groundtruth计算IOU，如果计算出来的先验框的IOU值存在大于阈值，就标记这个先验框为这个尺寸下的正样本，并设该尺寸下IOU大于阈值的先验框的置信度为1；如果计算出来的IOU都不大于阈值，那就选取计算出来IOU最大的先验框作为正样本 以上的两种方法就是筛选正样本的方法，如果不满足这两种方法，剩下的先验框就标记为负样本。标记正负样本只会参与到置信度损失的计算中，不会参与到预测类别以及bbox位置预测的损失计算中 正负样本分配也需要遵循一些准则，那就是尽量使得正样本数和负样本数基本相等，这是为了让模型在预测时不会出现大量漏检的现象，按照我的理解就是：先验框计算出来的IOU只要大于阈值，就说明这个先验框是能检测到物体的，正样本数越多就说明这个区域内存在物体的概率更大，也就不至于出现大量漏检的现象 网络结构上的改进首先来看看它的主体网络：Darknet-53的结构图 网络结构的改变是YOLO-V3中比较大改进的地方 在YOLO-V2中使用的主体网络结构为： Darknet-19，在Darknet-19中使用卷积层来提取特征图，通过池化层来获取降低了特征维度后的特征图（具体结构请去看YOLO-V2），在经过Darknet-19全部提取完特征图之后，再将上一层池化之前的结果经过reorg之后再合并到一起，来实现特征融合，将感受野较小的特征图融合到感受野较大的特征图上面，可以使得较少的目标不至于丢失 在YOLO-V3中的Darknet-53不同于V2中的网络，它除了使用卷积层来提取特征图之外，还使用了卷积层来降低特征图的维度，而不是池化层。仔细想想确实可以用卷积层来代替池化层来实现特征的降维，而且这个网络的主要成分还是残差块$\\left(\\text{resn}\\right)$，残差块是由一层特征降维的卷积层和 $\\text{2n}$ 个提取特征图的卷积层组成，但是在每 $\\text{2}$ 个提取特征图的卷积层之后，都要将输出的 $\\text{conv}$ 和输入的 $\\text{conv}$ 相加 在Darknet-53的卷积降维中会提取出大小不同的特征图，以输入图片大小为416×416为例，网络会将其降维为13×13、26×26、52×52等尺寸。若是像V2的做法，会将尺寸较大的特征图拆分之后融入尺寸较大的特征图中去，但想想V2的做法真的合适吗？将检测小物体（感受野较小）的特征图融合到检测大物体（感受野较大）的特征图中去，可能会将本来检测大物体的功能减弱或者检测小物体的功能减弱 那么V3中是怎么做的呢？它将最后提取出来的三种不同尺寸的特征图进行处理，将尺寸小的特征图进行上采样，还原到上一层的尺寸大小，然后将该特征图拼接到上一层的特征图中去，例如：将13×13的特征图经过上采样变为26×26大小的特征图，然后拼接到26×26尺寸的特征图中去。 我的理解是：在Darknet-53中通过残差块提取的特征图中已包含了前面的信息，小物体的信息也提取出来了，经过参数的优化小物体的检测会得到一定效果，此时应该向感受野大的特征图获取一些全局信息（个人理解仍待考证） decode解码由于网络输出的预测值的范围是0~1之间，也就是说每一个网格输出的bbox的位置预测都是都被限制在这个网格内，这正是YOLO的划分，每个网格都来预测是否有物体中心点。而decode就是用来将特征预测值都还原到相应尺寸下的尺寸，具体做法就是：将坐标预测值（0 ~ 1之间）与网格左上角的坐标相加获得该bbox在相应尺寸下的坐标，以及将预测的宽高乘上相应的尺寸，从而获得bbox的宽高，这样就可以计算出bbox与groundtruth的IOU，那么bbox的置信度就得出来了，就可以预测此处是否存在物体了 处理解码后的bbox网络输出的预测值经过解码之后，会获取所有尺寸下的网格所输出三个预测框bbox的信息，这些预测出来的bbox有可能存在左上角的坐标比右下角坐标大的情况，或者bbox不存在的情况，在检测目标时需要将这些预测出来的bbox信息去除先，保留下那些bbox信息存在且不异常的 NMS筛选bbox（在预测阶段）NMS（Non-Maximum Suppression）抑制不是极大值的元素，说白了就是去除哪些重叠率较高并且score评分较低的bbox 处理了解码后的bbox，会保留下一些bbox的信息，但是不是每个bbox都去负责呢？仔细想想每个网格（对应尺寸下）会输出三个bbox，假如处理后的bbox信息都被保留下来了，那么一个物体就会有三个预测框去框住它，这样的展示效果就不太好了。 对于一个网格内的bbox，需要的是保存下那个能最好地检测出物体的那个bbox，就要用到NMS方法了方法就是： 首先判断边界框的数目是否大于0，如果不是大于0，说明没有bbox的信息被保留下来，就去检测下一个网格，直到所有尺寸下的网格都被检测完 在保留bbox时，会给每个bbox一个评分，对于一个网格内的bbox，根据评分，为这些bbox排序，（不放回的取）取出评分最大的那个bbox 把这个评分最高的bbox与同一网格下的其他bbox计算IOU，这是为了判断评分最大的bbox与同一网格下的其他bbox的重叠率，去除那些重叠率过高的，取到剩下的bbox为0为止 GIOU（广义IOU）这是一种优化边界框的方法，GIOU是衡量bbox与实际框之间对齐和重叠情况的一个指标IOU计算公式：$$ \\text{IOU }= \\left|\\frac{A \\cap B}{A\\cup B}\\right|$$GIOU的计算公式：$$\\text{GIOU }= \\left| \\frac{C/(A\\cup B)}{C} \\right|$$","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"YOLO-V2","slug":"YOLO-V2","date":"2022-09-09T07:13:37.818Z","updated":"2022-09-09T07:13:37.819Z","comments":true,"path":"2022/09/09/yolo-v2/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/yolo-v2/","excerpt":"","text":"YOLO-V2 人们在体验到YOLO-V1实时检测的甜头的时候，当然想要在原来YOLO-V1的基础上更精进一步或者添加更多的功能，于是YOLO-V2来了。YOLO-V2相对于YOLO-V1的改变主要在bounding box的选取方式和位置的定位和大小比例上的变化，论文中提出了一种联合训练目标检测和分类的方法，通过这种方法得出了YOLO9000，而且YOLO9000可以预测没有出现在训练集中的物体的类别，在ImageNet上进行检测时，得到19.7%的map，尽管没有多高的map，但是却是在只有44中类别的数据的情况下去预测具有200个类别的数据集 效果：在VOC2007上测试时，在FPS为67时的map为76.8%，在FPS为40时，map为78.6%，比采用了Resnet和SSD的Faster R-CNN更精确，而且仍能以更快的速度运行 YOLO-V2的改进从上图可以看出YOLO-V2的改进是在一些对数据处理的方式方面进行的优化，确实是这样的，YOLO-V2继续保持它的特性one-stage的方法来确保它在检测速度上的优势，在确保优势的前提下，在其他方面争取突破，接下来介绍一下它的一些具体的改进和改进之后的效果 New Network: Darknet-19YOLO-V2在网络结构上的改进就是把YOLO-V1中的全连接层全部丢弃，采取==全卷积==的方式来提取特征图，因为全连接层是可以通过卷积来实现的，而且全连接层限制了输入的特征图的参数和输出的参数，所以限制了原始输入图像的大小，仔细想一想，全连接层也是相当于通过一个权重矩阵将全部的特征子图组合起来输出一个结果，相当于用大小和特征子图相等的卷积核对特征子图进行全局卷积的过程举个例子：输入$\\boldsymbol{10\\times10\\times3}$的特征图，要输出$\\boldsymbol{10\\times10\\times1}$的结果 全连接层的做法：将这些特征图reshape为一维的300个输入神经元，通过权重矩阵$\\boldsymbol{[10\\times10\\times3,100]}$进行矩阵运算，得到输出$\\boldsymbol{[1,100]}$再将这个矩阵reshape为$\\boldsymbol{10\\times10\\times1}$的形状 卷积层的做法：直接使用100个$\\boldsymbol{10\\times10\\times3}$的卷积核，分别直接贴着输入的特征图来做全局卷积，得到100个一维的输出，然后输出reshape为$\\boldsymbol{10\\times10\\times1}$的形状 由此可见，只要设定合适的卷积核的个数，就可以用全卷积来替代全连接层，而且全连接层对输入的特征子图进行了flatten操作，丢失了原始图像中物体的位置信息，这样不利于目标的定位。 在Darknet-19的网络中在两个$\\boldsymbol{3\\times3}$的卷积核中还==有$\\boldsymbol{1\\times1}$的卷积==，现在来说一下$\\boldsymbol{1\\times1}$卷积的作用 ==1×1的卷积==的通道数的和前一层的通道数相同时，实际上这也是一种全连接的表现，当==1×1的卷积==的通道数与前一层的特征图的通道数不相同的时候，使用1×1卷积可以实现降维、升维来改变训练参数的数量，1×1卷积还能为神经网络添加非线性表达能力，因为在进行卷积操作后还要进行池化和激活，相当于多进行一次激活。 在这个网络的作用主要是减少网络的参数 可以看到Darknet-19中经过卷积后，输出的特征图的尺寸没有减小还是与输入时的特征图的尺寸相同，这是怎么做到的呢？这样做的好处在哪？ 经过分析Darknet-53的源代码（Darknet-19和Darknet-53在结构上相似）可以看到这个网络使用了==padding==，它的卷积实现的定义如下： def convolutional(input_layer, filters_shape, downsample=False, activate=True, bn=True): if downsample: input_layer = tf.keras.layers.ZeroPadding2D(((1, 0), (1, 0)))(input_layer) padding = 'valid' strides = 2 else: strides = 1 padding = 'same' conv = tf.keras.layers.Conv2D(filters=filters_shape[-1], kernel_size = filters_shape[0], strides=strides, padding=padding, use_bias=not bn, kernel_regularizer=tf.keras.regularizers.l2(0.0005), kernel_initializer=tf.random_normal_initializer(stddev=0.01), bias_initializer=tf.constant_initializer(0.))(input_layer) if bn: conv = BatchNormalization()(conv) if activate == True: conv = tf.nn.leaky_relu(conv, alpha=0.1) return conv 卷积中使用padding主要由两种方式： 假如要对下面的矩阵进行padding卷积，比较一下两种方式的卷积，假设卷积的步长为2，且卷积核的尺寸为$2\\times2$ 1 2 3 4 5 6 Valid： Valid方式下，卷积核先将矩阵的$2\\times2$的窗口覆盖了，由于接下来的步长为2，卷积核将超出矩阵的大小范围，Valid方式就是丢弃矩阵中不能被卷积核所覆盖的矩阵元素，这里是丢弃了第三列的元素 ==输入和输出的关系：==$$\\boldsymbol{n_{output}=\\frac{n_{input}-f+1}{S}}$$ 如果算出来的结果不是个整数的话，那就向下取整 2. Same： 而Same则没有丢弃矩阵中的任何元素，它将卷积核所覆盖不到的地方用0填充 ==输入和输出的关系：== $$\\boldsymbol{n_{output}=\\frac{n_{input}}{S}}$$ $\\boldsymbol{S}$表示步长，$\\boldsymbol{n_{input}}$表示输入的大小，$\\boldsymbol{f}$表示卷积核的大小 ==使用padding的好处在于：== 为了不丢弃原图的信息，同时还能保证卷积后输出的特征图大小与原图的大小相等 Batch Normalization相信这个结构大家都不陌生，这就是在卷积层之后经常出现的BN层，==YOLO-V2采用了BN网络层来对每次卷积后的输出进行归一化，这样做的好处就是可以提升模型的收敛速度，而且可以起到一定的正则化的效果，降低模型的过拟合==，这使得YOLO-V2的map提升了2.4% High Resolution ClassifierYOLO-V1在训练时是在ImageNet分类数据集上预训练模型的主体部分，ImageNet分类模型基本采用大小为$\\boldsymbol{224\\times224}$的特片作为输入，因此YOLO-V1在训练时输入的图片大小为$\\boldsymbol{224\\times224}$，但是在预测时却采用的是$\\boldsymbol{448\\times448}$，显然这样造成的结果就是模型难以快速适应高分辨率的输入图片。确实，在YOLO-V1这种方式不太符合逻辑，因此YOLO-V2在训练时增加了10个epoch的$\\boldsymbol{448\\times448}$输入图片的训练，使的模型能更适应高分辨率的输入图片，使用高分辨率分类器后，YOLO-V2的map提升了约4% Convolutional With Anchor BoxesYOLO-V1输入的图片最终会被划分为$\\boldsymbol{7\\times7}$个网格，每个cell产生两个bounding box，网络的输出是对bounding box的预测值，这个预测值包括$\\boldsymbol{(x,y,w,h,c)}$，经过之前讨论的YOLO-V1的缺点，可以知道尽管网络对预测框进行了微调，但是调节能力还是太差了，由于图片中可能存在不同尺寸和长宽比的物体，因此YOLO-V1不能很好地把bounding box的$\\boldsymbol{(w,h)}$很好地预测出来，这导致YOLO-V1在精准定位方面表现较差。YOLO-V2为了解决这个问题借鉴了Faster R-CNN中RPN网络的先验框（anchor boxes，prior boxes，SSD也采用了先验框）策略 RPN网络选取先验框的方式：人为地设计$\\boldsymbol{1:2,1:1,2:1}$三种比例三种尺度（大，中，小），共9种先验框，然后使用先验框匹配的方式，选出最匹配的anchor box作为目标的位置 采用先验框后发现相对于YOLO-V1，V2的map有0.3%的下降，但是recall大幅提升到88%，这可能是因为预测框的数量变多了，因为原来在YOLO-V1时每个cell只生成了两个预测框而且YOLO-V2没有采用全连接层来输出结果这意味着对于输入图片没有限制了，那么最后划分出的网格将会变得更多，现在引入anchor boxs后每个cell（假设是$\\boldsymbol{13\\times13}$个网格）将会产生$\\boldsymbol{13\\times13\\times9}$个bounding box，原来没有检测到的物体现在可以检测出来了所以recall提升了 Dimension Clusters提升map这个综合的指标才是最重要的，因此YOLO-V2的作者想：规定这样的$\\boldsymbol{1:2,1:1,2:1}$比例的先验框是否真的合适，现实图片中也会有很多不满足这样比例的物体，最后他提出一种解决方法：==聚类提取先验框== YOLO-V2是这样做的：对训练集中标注的边框进行K-mean聚类分析，以找出尽可能匹配样本的边框尺寸。聚类算法计算两个类别之间的差别通常采用的欧氏距离的方法，但是如果采用欧氏距离来计算两个类别之间中心点的差别对于大边框会产生更大的误差，因此选取欧氏距离作为两个类别的差别显然是不合理的，所以YOLO-V2选取两个边框之间的IOU来计算两个边框之间的“距离”$$\\boldsymbol{d(\\text{box},\\text {centroid})=1-I O U(\\text {box}, \\text {centroid})}$$$\\boldsymbol{centroid}$是聚类时作为中心的边框，$\\boldsymbol{box}$表示其他边框，IOU越大，“距离”越近，说明这个比例的bounding box作为预测框对于检测任务来说是最合适的。#####那么$\\boldsymbol{centroid}$是如何用K-mean聚类算法选取出来的呢？在YOLO-V2中，在训练的过程中，由于每个物体的grounTruth的位置是知道的，将数据集中每个grounTruth的比例全部放到一个集合中，然后将这个集合按照比例的大小划分为几个类别（聚类），然后将划分出来的几个类别作为bounding box的初始大小 选取多少类别才是最合适的呢?从上图可以看出随着划分的类别越多，平均的IOU越高，但是划分的bounding box的比例越多也就意味着要花费更多的时间去匹配最佳的bounding box，经过实验可以发现当划分的类别为5类时，也就是k=5时，是在召回率和模型复杂度之间的比较好的折中，因此在YOLO-V2中选取划分5类的bounding box的比例 使用聚类选取bounding box比例的好处这样可以使得bounding box能更快地微调到最匹配groundTruth的大小，能使得模型更快的达到收敛状态 选取出bounding box的比例后，在进行前向计算时就可以利用这些比例去微调以适应grounTruth，（在训练的过程中）至于由哪个比例的bounding box来负责该cell的预测，则需要根据上述公式$\\boldsymbol{d(\\text{box},\\text {centroid})=1-I O U(\\text {box}, \\text {centroid})}$来计算出两个框之间的最小的“距离”，进而选择“距离”最小的bounding box的比例，来负责该cell的预测 ==值得注意的是：== 由于在训练的过程中，参数还是在不断优化的，因此每次预测出来的bounding box的都是不一样的 Direct location prediction在YOLO-V1中，对于物体的位置是输出预测框中心相对于该cell左上角的偏移量，但是由于一开始网络的参数是随机的，因此这个偏移量一开始就会很大，大到什么程度呢？可能预测框中心点的位置会超出该cell的范围，这样对于YOLO的思想就不一样了啊，YOLO是每个cell去预测中心点落在自身范围内的物体，现在物体的中心超出了该cell的范围，显然是不好的，那么要怎么解决这个问题呢？ 前面说了YOLO-V2中的先验框的提取是借鉴Faster-RCNN提取先验框的思想，那么在预测先验框的位置未尝不可借鉴它的方法——预测边界框相对于先验框的==offsets== 在RPN网络中是这样预测的：预测框的中心位置$\\boldsymbol{(x,y)}$，需要根据预测的坐标偏移值$\\boldsymbol{(t_x,t_y)}$，先验框的尺寸$\\boldsymbol{(w_a,h_a)}$以及中心坐标$\\boldsymbol{(x_a,y_a)}$，来计算：$$\\boldsymbol{x=(t_x\\times w_a)+x_a}$$$$\\boldsymbol{y=(t_y\\times h_a)+y_a}$$$\\boldsymbol{t_x,t_y}$是要学习的参数，由于$\\boldsymbol{t_x,t_y}$的取值没有任何约束，因此预测框的中心可能出现在任何位置，因此在训练早期阶段不容易稳定 YOLO调整了预测公式，通过sigmoid函数将预测边框的中心约束在在自己的cell里面$$\\boldsymbol{b_x=\\sigma(t_x)+C_x}$$$$\\boldsymbol{b_y=\\sigma(t_y)+C_y}$$$$\\boldsymbol{b_w=p_we^{t_w}}$$$$\\boldsymbol{b_h=p_he^{t_h}}$$$$\\boldsymbol{Pr(object)*IOU(b,object)=\\sigma(t_c)}$$其中$\\boldsymbol{b_x,b_y,b_w,b_h}$是预测边框的中心和宽高，$\\boldsymbol{Pr(object)*IOU(b,object)}$是预测边框的置信度，在YOLO-V1中是直接预测置信度的值，这里对预测值参数$\\boldsymbol{t_c}$进行$\\sigma$变换后作为置信度的值。$\\boldsymbol{c_x,c_y}$是当前网格左上角到图像左上角的距离，要先将网格的大小归一化，即令一个网格的宽高都为1，$\\boldsymbol{p_w,p_h}$是先验框的宽高。$\\sigma$是sigmoid函数。$\\boldsymbol{t_x,t_y,t_w,t_h,t_c}$是要学习的参数，分别用于预测边框的中心和宽高，以及置信度。将预测框的中心点限制在网格中。能免除预测框中心点跑出网格范围再优化回来的过程，这样能减少优化参数的时间。 Fine-Grained Features在YOLO-V1中对于图像中的对象的大小检测中存在很大的误差，在大物体的检测方面没什么问题，但是对于小物体的检测就没那么准确了，于是YOLO-V2就打算进行优化这一过程。 在介绍YOLO-V2的做法之前，先来介绍一个CNN网络结构中的重要概念：感受野 感受野原指听觉、视觉等神经系统中的一些神经元的特性，即神经元只接受其所支配的刺激区域内的信号。而在卷积神经网络中的感受野表示==特征图中的一个像素点映射到原始图像中在原始图像中占的大小==，而且随着卷积层的增加，卷积输出的特征图每一个像素点映射到原始图像上所占的大小越来越大，这就意味着小卷积核通过多层叠加也可以取得与大卷积核同等规模的感受野例如：对于一个$\\boldsymbol{7\\times7}$大小的图像矩阵，用一个$\\boldsymbol{7\\times7}$大小的卷积核去卷积这个图像将输出一个像素点，这个像素点的感受野也就是$\\boldsymbol{7\\times7}$现在先用$\\boldsymbol{3\\times3}$的卷积核去卷积这个图片，卷积输出的结果为$\\boldsymbol{5\\times5}$大小的矩阵，矩阵中的每个像素点的感受野大小为$\\boldsymbol{3\\times3}$，接着再用$\\boldsymbol{3\\times3}$大小的卷积核去卷积$\\boldsymbol{5\\times5}$大小的矩阵，输出大小为$\\boldsymbol{3\\times3}$的矩阵，矩阵中每个像素点映射到原始图像中的感受野大小为$\\boldsymbol{5\\times5}$，接着继续用$\\boldsymbol{3\\times3}$的卷积核去卷积大小为$\\boldsymbol{3\\times3}$的矩阵，最后输出一个像素点，这个像素点映射到原始图像中的感受野的大小为$\\boldsymbol{7\\times7}$上述就是使用多层小卷积实现与大卷积核的感受野相同的过程，这样做不是很麻烦吗？明明一个大卷积核能完成的事，为什么要使用多个小卷积核来代替？是的，这样对于我们人来说确实是很麻烦，但是对于机器来说确实一件很舒服的事，因为$\\boldsymbol{7\\times7}$的卷积核有$\\boldsymbol{49}$个参数，但是3个$\\boldsymbol{3\\times3}$的卷积核的参数为$\\boldsymbol{27}$，这样做减少了模型需要训练的参数，使得模型训练起来不用那么累。 在YOLO-V2中输入图片大小为$\\boldsymbol{416\\times416}$，经过5次maxpooling后输出$\\boldsymbol{13\\times13}$大小的特征图，$\\boldsymbol{13\\times13}$大小的特征图像前面说的用来预测大物体是足够得了，但是这样就和YOLO-V1没什么区别了啊，YOLO-V2的做法就是牺牲一点特征图像素点对应的感受野的大小，因为感受野变小了，比较小的物体就能获得更多的关注了，那么YOLO-V2是怎么样实现减少像素点的感受野的大小的呢？ YOLO-V2提出了一张passthrough层来利用更精细的特征图，它将最后一层maxpooling$\\boldsymbol{26\\times26\\times512}$大小的输入特征图，将其拆成$\\boldsymbol{4\\times13\\times13\\times512}$直接传递（passthrough）到pooling后并将两者进行叠加 至于如何将将输入的特征图拆分为4份，可以参考下图： #### Multi-Scale Training 因为YOLO-V2中丢弃了全连接层，因此对于输入图片的尺寸大小也就没有要求了，为了增强模型的鲁棒性，YOLO-V2采用了多尺寸输入的训练策略，具体来说就是在训练时每间隔一定的iterations之后改变模型的输入图片的大小，但是这些尺寸有一个要求：输入图片的大小要选择一系列为32倍数的值。输入图片的最小为$\\boldsymbol{320\\times320}$，此时对应的特征图的大小为$\\boldsymbol{10\\times10}$，输入图片最大为$\\boldsymbol{608\\times608}$，对应的特征图的大小为$\\boldsymbol{19\\times19}$。 经过这样训练之后，YOLO-V2可以适应不同大小的图片，并且能预测出很好的效果 ### YOLO-V2的损失函数 $$ \\text { Loss }=\\lambda_{\\text {coord }} \\sum_{i=0}^{S^{2}} \\sum_{j=0}^{B} I_{i j}^{\\text {obj }}\\left[\\left(x_{i}^{j}-\\hat{x}_{i}^{j}\\right)^{2}+\\left(y_{i}^{j}-\\hat{y}_{i}^{j}\\right)^{2}\\right]+ \\\\ \\lambda_{\\text {coord }} \\sum_{i=0}^{S^{2}} \\sum_{j=0}^{B} I_{i j}^{o b j}\\left[\\left(w_{i}^{j}-\\hat{w}_{i}^{j}\\right)^{2}+\\left(h_{i}^{j}-\\hat{h}_{i}^{j}\\right)^{2}\\right]+ \\\\ \\sum_{i=0}^{S^{2}} \\sum_{j=0}^{B} I_{i j}^{o b j}\\left(C_{i}^{j}-\\hat{C}_{i}^{j}\\right)^{2}+ \\\\ \\lambda_{\\text {noob } j} \\sum_{i=0}^{S^{2}} \\sum_{j=0}^{B} I_{i j}^{\\text {noob } j}\\left(C_{i}^{j}-\\hat{C}_{i}^{j}\\right)^{2}+ \\\\ \\sum_{i=0}^{S^{2}} I_{i j}^{\\text {obj }} \\sum_{c \\in \\text { classes }}\\left(P_{i}^{j}(c)-\\hat{P}_{i}^{j}(c)\\right)^{2} $$ 这与V1不同的就在于改动了关于bbox的 $\\text{w}$ 和 $\\text{h}$ 的损失计算方式即 $\\sum_{i=0}^{S^2}\\sum_{j=0}^{B}I_{ij}^{obj}\\left[\\left( \\sqrt{w_i^j}-\\sqrt{\\hat{w}^j_i}\\right)^2+\\left( \\sqrt{h^j_i}-\\sqrt{\\hat{h}^j_i}\\right)^2\\right]$改为$\\sum_{i=0}^{S^2}\\sum_{j=0}^{B}I_{ij}^{obj}\\left[\\left(w_i^j-\\hat{w}^j_i\\right)^2+\\left( h^j_i-\\hat{h}^j_i\\right)^2\\right]$","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"YOLO-V1","slug":"YOLO-V1","date":"2022-09-09T07:13:37.589Z","updated":"2022-09-09T07:13:37.590Z","comments":true,"path":"2022/09/09/yolo-v1/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/yolo-v1/","excerpt":"","text":"#YOLO-V1####目标检测经典检测方法 one-stage（单阶段）：YOLO系列 two-stage（两阶段）：Faster-Rcnn、Mask-Rcnn系列 one-stage检测方法与two-stage检测方法的差别在于：two-stage方法在输出检测结果之前先产生几个预选框，接着对预选框进行判断预选框中是否存在物体，最后把检测结果输出。而YOLO采用的one-stage方法没有先选出预选框的过程，但实际上还是存在预判定框，直接对预判定框进行检测，比two-stage检测方法更快。 根据one-stage和two-stage的对比可以得出YOLO系列和其他系列的优劣： 优点：YOLO在检测速度上比其他系列更快，FPS（帧数）比其他检测网络更高，这样使得实时检测更轻松，而且它的准确率也是比较高的，因此它受到广大检测任务的欢迎 缺点：由于比two-stage少了一个阶段，因此在检测准确率上面当然要比其他two-stage网络要差一点==因此在选择网络来实现检测任务时，应根据检测任务需要来选择适合的网络模型，例如对实时性要求不是太高的检测任务可以选取类似Mask-Rcnn网络模型来检测== ###衡量指标####MAP 综合地去衡量检测效果的一个指标 两个衡量模型的指标 精确率（precision）：精确率是针对==预测结果==来说的，表示预测结果中真正为正的样本占预测结果样本的比例例如：现在有一个检测任务，需要在一堆水果中检测出西瓜的数目，这堆水果共有100个，其中50个为西瓜，20个为香蕉，30个为苹果，经过模型检测出来40个结果（网络模型认为是正样本），这40个结果中有20个为西瓜，10个为香蕉，10个为苹果，则$$\\boldsymbol{precision=\\frac{20(\\text{检测结果中真正的正样本的个数})}{40(\\text{网络认为是正样本的个数})}}$$公式为：$$\\boldsymbol{precision=\\frac{TP}{TP+FP}}$$$\\boldsymbol{TP}$理解为正确地将样本检测为正样本，$\\boldsymbol{FP}$理解为错误地将样本检测为正样本 召回率（recall）：召回率是针对==样本==来说的，表示预测结果中真正为正的样本占总正样本的比例还是上面的例子：$$\\boldsymbol{recall=\\frac{20(\\text{检测结果中真正的正样本的个数})}{50(\\text{总的正样本的个数})}}$$公式为：$$\\boldsymbol{recall=\\frac{TP}{TP+FN}}$$$\\boldsymbol{FN}$理解为网络模型将正样本检测为负样本的样本个数，也就是没有被网络模型检测到的正样本 单看这两个评价指标可不可以？ 显然不行，因为这两个指标是相互矛盾的，一个高另一个就低，此消彼长，只有这两个指标都有一定的高度才能说明这个模型是有效的，因此需要用MAP来综合评价这两个指标。 MAP的计算根据精确率和召回率所画的图，在每个阶段选取精度最高的点，算出点以下的面积，就可以计算出模型的MAP值。####IOU（交并比）分子是Ground Truth（物体所在真实检测框的位置）和Prediction（预测框的位置）之间的交集 分母是Ground Truth和Prediction两个框的并集的部分 IOU所反映的信息： 检测框与物体实际的框之间的吻合程度，交集看的是预测框和实际框之间的重合部分，并集表示的是预测框和实际框合起来的部分有多大，这两个集合的比值就可以表示预测的效果 ####confidence（置信度，预测准确程度）计算公式：$$\\boldsymbol{Pr(Object)*IOU^{truth}{pred}}$$其中$\\boldsymbol{Pr(Object)}$为这个bounding box含有物体的概率，$\\boldsymbol{IOU^{truth}{pred}}$为预测准确程度的信息，如果预测框中有物体则置信度选为1，否则为0。###YOLO-V1的核心思想 假设有一张待检测的图片，将这张图片分为$\\boldsymbol{S\\times S}$个网格，每个网格称为一个cell，图片中的==物体的中心点落在哪个网格，哪个网格就负责检测这个物体==，当然这个网格并不知道物体的实际的大小有多大，因此网络在这个网格周围会有两个预测框（bounding box），每个bounding box的参数有$\\boldsymbol{（x，y，w，h）}$，其中$\\boldsymbol{w、h}$表示bounding box的长和宽 由于在不同的图片上bounding box的位置以及长和宽都会不同，因此在进行检测时要调节这个bounding box的大小，但是在目标检测的过程中这个框的大小不可能是人为地去调节这个大小，需要网络模型自己去完成这个任务，因此让网络学会自己调节这个框的大小就属于==回归问题==了。 每个cell会产生两个预测框（在YOLO-V1中），每个预测框会有$\\boldsymbol{(x,y,w,h,c)}$，其中$\\boldsymbol{(x,y)}$表示bounding box中心点的位置，但是要注意一点：$\\boldsymbol{(x,y)}$是相对于每个cell左上角坐标的偏移值，$\\boldsymbol{c}$表示这个cell的bounding box的置信度，置信度计算公式：$$\\boldsymbol{Pr(Object)*IOU^{truth}{pred}}$$其中$\\boldsymbol{Pr(Object)}$在这个cell有物体时值为1，没有物体时值为0，在$\\boldsymbol{Pr(Object)}$为1时，置信度就可以用$\\boldsymbol{IOU^{truth}{pred}}$来表示，因为每个cell都要负责检测以下中心点落在它身上上的物体的类别，因此每个cell还要给出预测出$\\boldsymbol{C}$个类别的概率。因此网络的输出应包括这些部分的信息。 ==“物体的中心点落在哪个网格，哪个网格就负责检测这个物体”== 分为两阶段来看，包括训练和测试。 训练阶段，由于训练集中的groundtruth（物体在图片中的位置用框框起来）的位置是需要人为地一张张地标注出来的，因此在训练过程中中心点的位置为groundtruth的中心位置所决定的，如果中心点落在这个cell里面，就给这个cell打上一个标签label，这个标签包括$\\boldsymbol{(x,y,w,h)}$以及这个物体的类别。在前面也介绍过了YOLO的优势就是快，这是==因为每个cell都要负责去检测物体，并对物体进行识别（分类），因此在训练阶段就是训练每个cell的参数中的$\\boldsymbol{w,h}$的调节参数==，教会每个cell怎样去检测图像中的物体位置以及物体的类别，有一种一气呵成的感觉。 测试阶段，在训练阶段我们已经通过标注物体框的位置的方法，让每个cell懂得如何去检测物体以及判断物体的类别 ####网络模型可以看出YOLO-V1的网络是用卷积网络来提取特征，最后用两层全连接层来输出结果，输出的大小为$\\boldsymbol{7\\times7\\times30}$的张量，这表示把图片分为$\\boldsymbol{7\\times7}$的网格（cell），每个网格输出有30个元素，前20个元素为20个类别的概率，然后2个元素是bounding box的置信度，后8个元素为2个bounding box的$\\boldsymbol{(x,y,w,h)}$ 全连接层连接的网络输出为固定值，这要求网络的输入也要是固定的，因为一旦确定下来网络要输出的特征信息的大小，那么这个网络的全连接层的权重矩阵也就确定下来了，全连接层不仅仅需要输出的维度是确定的，还要求经过卷积的输出，输入到全连接层的维度也是确定的 为什么置信度的信息和bounding box的位置信息要分开排列呢？这是为了计算方便，这30个元素都是对应于一个cell，它们的排列顺序是可以任意的，但是分离排布，可以方便地提取每一个部分。假设网络输出的预测值是一个二维张量$\\boldsymbol{P}$，其shape为$\\boldsymbol{[batch,7\\times7\\times30]}$，那么$\\boldsymbol{P[:,0:7\\times 7\\times 20]}$就是类别概率部分，而$\\boldsymbol{P[:,7\\times7\\times20:7\\times7\\times(20+2)]}$表示置信度部分，$\\boldsymbol{P[:,7\\times7\\times(20+2):]}$为bounding box的预测结果的部分，因此这样的排布，对于提取每个部分都很方便####损失函数 在YOLO的输出维度中应该更重视bounding box位置的参数，即$\\boldsymbol{(x,y,w,h)}$因此要在bounding box位置的损失函数前面赋予更大的loss weight，记为$\\boldsymbol{\\lambda_{coord}}$，在pascal VOC训练中取5 对于没有object的bounding box的置信度损失，我们希望它对网络的参数没有太大的影响，所以我们希望它的损失值尽可能地小，因此在这些cell的损失函数前面赋予小的loss weight，记为$\\boldsymbol{\\lambda_{noobj}}$，在pascal VOC训练中取0.5 对于有object的bounding box的置信度损失和类别损失都正常取1 $\\boldsymbol{\\mathbb 1^{obj}{ij}}$表示判断第i个网格中第j个bounding box是否负责这个object，这也意味着只有负责预测这个cell的bounding box才被计算入误差中$\\boldsymbol{\\mathbb 1^{obj}{i}}$判断是否有object中心落在网格i中$$\\text { Loss }=\\lambda_{\\text {coord }} \\sum_{i=0}^{S^{2}} \\sum_{j=0}^{B} I_{i j}^{\\text {obj }}\\left[\\left(x_{i}^{j}-\\hat{x}{i}^{j}\\right)^{2}+\\left(y{i}^{j}-\\hat{y}{i}^{j}\\right)^{2}\\right]+ \\\\lambda{\\text {coord }} \\sum_{i=0}^{S^{2}} \\sum_{j=0}^{B} I_{i j}^{o b j}\\left[\\left(\\sqrt{w_{i}^{j}}-\\sqrt{\\hat{w}{i}^{j}}\\right)^{2}+\\left(\\sqrt{h{i}^{j}}-\\sqrt{\\hat{h}{i}^{j}}\\right)^{2}\\right]+ \\\\sum{i=0}^{S^{2}} \\sum_{j=0}^{B} I_{i j}^{o b j}\\left(C_{i}^{j}-\\hat{C}{i}^{j}\\right)^{2}+ \\\\lambda{\\text {noob } j} \\sum_{i=0}^{S^{2}} \\sum_{j=0}^{B} I_{i j}^{\\text {noob } j}\\left(C_{i}^{j}-\\hat{C}{i}^{j}\\right)^{2}+ \\\\sum{i=0}^{S^{2}} I_{i j}^{\\text {obj }} \\sum_{c \\in \\text { classes }}\\left(P_{i}^{j}(c)-\\hat{P}_{i}^{j}(c)\\right)^{2}$$注意到：对于bounding box的长宽的损失，采用了开根号的形式，这表示对于大物体的误差不太重视，更重视物体比较小的误差，可以结合下图： 至于为什么要计算没有object的cell的误差，我觉得这是为了让有object的cell计算出来的误差更精确，没有object的cell老老实实地输出尽量低的置信度###具体操作下面主要讨论训练过程中的网络训练，然后再说说预测过程中网络的具体流程。 ####bounding box的预测在训练过程中，一开始由于卷积网络的权值是随机初始化的，刚开始通过卷积输出的$\\boldsymbol{(x,y,w,h)}$所标定的预测框往往是不准确，通过损失函数作为标准，反向传播更新权值，使得预测框逐渐变得准确。 这个通过卷积得出$\\boldsymbol{(x,y,w,h)}$的过程也就是网络给出bounding box的过程，这个过程就是预测的过程，也是每个cell应该学好的东西。 实际上网络输出的$\\boldsymbol{(x,y,w,h)}$是经过归一化后输出的偏移量，那么偏移量如何计算呢？ 网络输出的$\\boldsymbol{(x,y)}$是相对于cell左上角的偏移量，在训练过程中，我们把一张张图片的物体（目标）用框框起来，通过框就可以计算框的中心点，接下来要==将原始图片中的中心点映射到grid网格中==，在YOLO中是这样做的：原始图片的大小为$\\boldsymbol{(weigh,height)}$，现在要将这张图片分为$\\boldsymbol{S\\times S}$的网格，那么可以算出每个网格所含有的像素点为：$\\boldsymbol{weight/S}$，假设物体中心点在原始图片上的坐标为$\\boldsymbol{(x’’,y’’)}$，那么该中心点在grid网格中的坐标为：$\\boldsymbol{x’=x’’\\times(S/weight)}$，偏移量$\\boldsymbol{x}$就是$\\boldsymbol{x’}$减去cell的坐标，同理$\\boldsymbol{y}$也是用这种方法算出####类别预测前面也介绍了网络输出的信息要包括物体的类别信息，在训练刚开始时，网络的参数都是随机化的，因此一开始网络的分类也不是部准确的，但是没关系，不仅仅是在bounding box预测的过程才会有损失函数，在传统的分类网络中都是要用损失函数作为标准，然后再通过反向传播一步步达到最优，那么在训练之前就要为每个目标打上类别的标签，假设有20个类别，那么就要在20维向量中对应该类别的位置上设置概率为1，这种方式类似于one—hot编码 注意上述的预测是要在有物体的中心点落在了该cell上，才会对cell中的bounding box以及bounding box里的物体类别进行预测 ####bounding box的选择由于每个cell都要去检测以下是否有物体的中心点落在自身上，检测就是通过产生两个bounding box去看看是否有物体，对于训练阶段，会有grountruth（实物框），因此每个cell产生的bounding box就能很轻松地计算出bounding box和goundtruth的IOU，YOLO一般的做法是选取一个值作为阈值，只有bounding的置信度超过阈值的bounding box才被考虑。 还有一种情况：当cell产生的两个bounding box的置信度都超过了阈值，==那么这个cell里的object由哪个bounding box负责呢？== 这也有置信度来决定，准确地来说是IOU，当两个bounding box都超过阈值时，选取IOU最大的那个bounding box来决定。####预测过程经过前面的训练过程，相信cell已经学习到一定的权值来正确地检测出落在该cell上的物体，光说不练都是花架子，现在就用学习好的模型去检测一下（理论上），现在有一张图片输入网络，按照之前的做法，将图片分为$\\boldsymbol{7\\times7}$个网格（cell），接着每个cell根据自己的所学所得去检测是否有物体落在自己身上，如果有那就根据学习到的权值参数将这个物体的位置预测出来以及将这个物体的类别预测出来（回归问题），在这个过程中每个cell还是和之前一样会生成两个bounding box，但是和训练过程不一样了，==现在没有groundtruth来计算IOU了，那该怎么办呢？== 没关系！因为在训练的过程中都会计算每个bounding box的置信度，网络也会为计算出该置信度初始化出一个权值，在训练网络的过程中也更新了这个权值，那么在预测时网络就会根据这个权值计算出算出每个cell的置信度，这样就有了评价的标准，训练过程就像是将一大堆的答案（数据）喂入一个机器中，然后机器将吐出一些规则（处理数据的方式），而预测过程就要利用这些规则去处理一些新的数据让它吐出答案，得到的这个答案和喂入的答案的形式是相同的。 ###YOLO-V1的缺点 由于每个cell只能检测一个物体，判断出一个类别，假如一个cell中有两个物体，或者物体在cell中很小很小，那样的话检测的效果也不是很好 bounding box长宽的调节能力太差，当同一类物体出现的新的不常见的长宽比和其他情况时，泛化能力较弱 由于损失函数的问题，bounding box的定位误差是影响检测效果的主要原因，尤其是在大小物体的处理上，大物体的IOU误差和小物体的IOU误差对网络训练中loss贡献值接近（虽然采用求平方根方式，但是没有解决问题）。因此，对于小物体，小的IOU误差也会对网络优化过程造成很大的影响，从而降低了物体检测的定位准确性","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"VOTT——数据集标注工具","slug":"VOTT——数据集标注工具","date":"2022-09-09T07:13:37.497Z","updated":"2022-09-09T07:13:37.498Z","comments":true,"path":"2022/09/09/vott-shu-ju-ji-biao-zhu-gong-ju/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/vott-shu-ju-ji-biao-zhu-gong-ju/","excerpt":"","text":"数据集标注工具——VOTT","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"VOC数据集转COCO数据集","slug":"VOC数据集转COCO数据集","date":"2022-09-09T07:13:37.411Z","updated":"2022-09-09T07:13:37.412Z","comments":true,"path":"2022/09/09/voc-shu-ju-ji-zhuan-coco-shu-ju-ji/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/voc-shu-ju-ji-zhuan-coco-shu-ju-ji/","excerpt":"","text":"VOC数据集转COCO数据集参考博客 划分VOC数据集 import os import random trainval_percent = 0.8 train_percent = 0.8 xmlfilepath = 'Annotations' txtsavepath = 'ImageSets\\Main' total_xml = os.listdir(xmlfilepath) num = len(total_xml) list = range(num) tv = int(num * trainval_percent) tr = int(tv * train_percent) trainval = random.sample(list, tv) train = random.sample(trainval, tr) ftrainval = open('ImageSets/Main/trainval.txt', 'w') ftest = open('ImageSets/Main/test.txt', 'w') ftrain = open('ImageSets/Main/train.txt', 'w') fval = open('ImageSets/Main/val.txt', 'w') for i in list: name = total_xml[i][:-4] + '\\n' if i in trainval: ftrainval.write(name) if i in train: ftrain.write(name) else: fval.write(name) else: ftest.write(name) ftrainval.close() ftrain.close() fval.close() ftest.close() VOC转成coco import os from tqdm import tqdm import xml.etree.ElementTree as ET import json class_names = ['天猫', '顺丰', '京东'] def voc2coco(data_dir, train_file, test_file, val_file): xml_dir = os.path.join(data_dir, 'Annotations') img_dir = os.path.join(data_dir, 'JPEGImages') with open(train_file, 'r') as f: train_fs = f.readlines() train_xmls = [os.path.join(xml_dir, n.strip() + '.xml') for n in train_fs] with open(test_file, 'r') as f: test_fs = f.readlines() test_xmls = [os.path.join(xml_dir, n.strip() + '.xml') for n in test_fs] with open(val_file, 'r') as f: val_fs = f.readlines() val_xmls = [os.path.join(xml_dir, n.strip() + '.xml') for n in val_fs] print('got xmls') train_coco = xml2coco(train_xmls) test_coco = xml2coco(test_xmls) val_coco = xml2coco(val_xmls) with open(os.path.join(data_dir, 'coco_train.json'), 'w') as f: json.dump(train_coco, f, ensure_ascii=False, indent=2) with open(os.path.join(data_dir, 'coco_test.json'), 'w') as f: json.dump(test_coco, f, ensure_ascii=False, indent=2) with open(os.path.join(data_dir, 'coco_val.json'), 'w') as f: json.dump(val_coco, f, ensure_ascii=False, indent=2) print('done') def xml2coco(xmls): coco_anno = {'info': {}, 'images': [], 'licenses': [], 'annotations': [], 'categories': [{'supercategory': j, 'id': i + 1, 'name': j} for i, j in enumerate(class_names)]} img_id = 0 anno_id = 0 for fxml in tqdm(xmls): try: tree = ET.parse(fxml) objects = tree.findall('object') except: print('err xml file: ', fxml) continue if len(objects) &lt; 1: print('no object in ', fxml) continue img_id += 1 size = tree.find('size') ih = int(float(size.find('height').text)) iw = int(float(size.find('width').text)) img_name = fxml.strip().split('\\\\')[-1].replace('xml', 'png') img_info = {} img_info['id'] = img_id img_info['file_name'] = img_name img_info['height'] = ih img_info['width'] = iw coco_anno['images'].append(img_info) for obj in objects: cls_name = obj.find('name').text bbox = obj.find('bndbox') x1 = int(float(bbox.find('xmin').text)) y1 = int(float(bbox.find('ymin').text)) x2 = int(float(bbox.find('xmax').text)) y2 = int(float(bbox.find('ymax').text)) if x2 &lt; x1 or y2 &lt; y1: print('bbox not valid: ', fxml) continue anno_id += 1 bb = [x1, y1, x2 - x1, y2 - y1] categery_id = class_names.index(cls_name) + 1 area = (x2 - x1) * (y2 - y1) anno_info = {} anno_info['segmentation'] = [] anno_info['area'] = area anno_info['image_id'] = img_id anno_info['bbox'] = bb anno_info['iscrowd'] = 0 anno_info['category_id'] = categery_id anno_info['id'] = anno_id coco_anno['annotations'].append(anno_info) return coco_anno if __name__ == '__main__': data_dir = r'D:\\百度网盘\\dataout\\VOCdevkit\\VOC2007' train_file = r'D:\\百度网盘\\dataout\\VOCdevkit\\VOC2007\\ImageSets\\Main\\train.txt' test_file = r'D:\\百度网盘\\dataout\\VOCdevkit\\VOC2007\\ImageSets\\Main\\test.txt' val_file = r'D:\\百度网盘\\dataout\\VOCdevkit\\VOC2007\\ImageSets\\Main\\val.txt' voc2coco(data_dir, train_file, test_file, val_file) VOC转tfrecord格式的数据参考","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"LeNet_5","slug":"LeNet_5","date":"2022-09-09T07:13:37.363Z","updated":"2022-09-09T07:13:37.364Z","comments":true,"path":"2022/09/09/lenet-5/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/lenet-5/","excerpt":"","text":"经典卷积神经网络：LeNet_5","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"img2col","slug":"img2col","date":"2022-09-09T07:13:37.355Z","updated":"2022-09-09T07:13:37.356Z","comments":true,"path":"2022/09/09/img2col/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/img2col/","excerpt":"","text":"img2col张量运算转换成矩阵运算（芯片层）","categories":[{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"线性回归","slug":"线性回归","date":"2022-09-09T07:13:37.347Z","updated":"2022-09-09T07:13:37.347Z","comments":true,"path":"2022/09/09/xian-xing-hui-gui/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/xian-xing-hui-gui/","excerpt":"","text":"###损失函数(loss function)是将随机事件或其有关随机变量的取值映射为非负实数以表示该随机事件的“风险”或“损失”的函数。损失函数常常作为学习准则与优化问题相联系，即通过最小化损失函数求解和评估模型，在机器学习和统计学中被用于模型的参数估计均方误差代价函数 均方误差代价函数的实际就是用一个一次线性函数来逼近一个复杂的非线性的函数 实际上我们是考虑这个差平方求和的平均数m是数据集中点的个数½是一个常量，这样是为了在求梯度的时候，二次方求导乘下来就和这里的½抵消了，自然就没有多余的常数系数，方便后续的计算，同时对结果不会有影响y 是数据集中每个点的真实y坐标的值h 是我们的预测函数，根据每一个输入x，根据Θ 计算得到预测的y值，即 交叉熵损失函数交叉熵描述的是两个概率分布之间的距离，距离越小表示这两个概率越接近，越大表示这两个概率差异越大。神经网络的输出，也就是前向传播的输出可以通过Softmax回归变成概率分布，接着就可以使用交叉熵损失函数来计算损失了。 概率p表示期望输出（样本实际），概率q表示预测输出，通过交叉熵函数来比较实际与预测之间的差异 两个损失函数之间的区别在于：均方误差损失函数比较适合用来处理回归问题，交叉熵损失函数比较适合用来处理分类问题。####偏导数在数学中，一个多变量函数的偏导数，就是它关于其中一个变量的导数而保持其他变量恒定(相对于全导数，其中的变量所有变量都允许发生变化)。偏导数是对含有多个自变量的函数的求导，由于函数有多个自变量，因此在不同的点函数变换快慢是不同的，偏导数反映的是函数沿坐标轴(X,Y)正方向的变化率。X方向的偏导设有二元函数 z=f(x,y) ，点(x0,y0)是其定义域D 内一点。把 y 固定在 y0而让 x 在 x0 有增量 △x ，相应地函数 z=f(x,y) 有增量（称为对 x 的偏增量）△z=f(x0+△x,y0)-f(x0,y0)。如果 △z 与 △x 之比当 △x→0 时的极限存在，那么此极限值称为函数 z=f(x,y) 在 (x0,y0)处对 x 的偏导数，记作 f’x(x0,y0)或函数 z=f(x,y) 在(x0,y0)处对 x 的偏导数，实际上就是把 y 固定在 y0看成常数后，一元函数z=f(x,y0)在 x0处的导数。Y方向的偏导同样，把 x 固定在 x0，让 y 有增量 △y ，如果极限存在那么此极限称为函数 z=(x,y) 在 (x0,y0)处对 y 的偏导数。记作f’y(x0,y0)。求法当函数 z=f(x,y) 在 (x0,y0)的两个偏导数 f’x(x0,y0) 与 f’y(x0,y0)都存在时，我们称 f(x,y) 在 (x0,y0)处可导。如果函数 f(x,y) 在域 D 的每一点均可导，那么称函数 f(x,y) 在域 D 可导。此时，对应于域 D 的每一点 (x,y) ，必有一个对 x (对 y )的偏导数，因而在域 D 确定了一个新的二元函数，称为 f(x,y) 对 x (对 y )的偏导函数。简称偏导数。按偏导数的定义，将多元函数关于一个自变量求偏导数时，就将其余的自变量看成常数，此时他的求导方法与一元函数导数的求法是一样的。几何意义表示固定面上一点的切线斜率。偏导数 f’x(x0,y0) 表示固定面上一点对 x 轴的切线斜率；偏导数 f’y(x0,y0) 表示固定面上一点对 y 轴的切线斜率。高阶偏导数：如果二元函数 z=f(x,y) 的偏导数 f’x(x,y) 与 f’y(x,y) 仍然可导，那么这两个偏导函数的偏导数称为 z=f(x,y) 的二阶偏导数。二元函数的二阶偏导数有四个：f”xx，f”xy，f”yx，f”yy。注意：f”xy与f”yx的区别在于：前者是先对 x 求偏导，然后将所得的偏导函数再对 y 求偏导；后者是先对 y 求偏导再对 x 求偏导。当 f”xy 与 f”yx 都连续时，求导的结果与先后次序无关。####梯度下降算法蓝色的云区就是“模型”部分，在这一部分中输入或多个特征(x)会返回一个预测(y’)作为输出红色框内就是运用损失函数来计算在该位置的损失值，然后将损失值传入绿色的区域绿色区域接收到损失值，根据这些损失值为模型更新模型的参数，然后机器学习系统将根据所有标签重新评估所有特征，再为损失函数生成一个新的值。这个过程是一个迭代的过程(选取的步长即不能太小也不能太大，避免错过最佳参数)，直到该算法发现损失可能最低的模型参数，也就是总体损失不再变化或至少变化极其缓慢位置，这时候，我们可以说该模型已收敛。梯度下降会得到一个局部的最优解，但是这与起始点的选取有关，起始点不同就会得到不同的最优解人们所说的梯度下降算法实际上是同步更新实现同步更新的正确和错误的做法两个参数的同步更新的公式梯度下降算法的关键就是处理好下面的公式，即求出均方误差代价函数的偏导数项梯度下降法的基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复采用同一个方法，最后就能成功的抵达山谷。我们同时可以假设这座山最陡峭的地方是无法通过肉眼立马观察出来的，而是需要一个复杂的工具来测量，同时，这个人此时正好拥有测量出最陡峭方向的能力。所以，此人每走一段距离，都需要一段时间来测量所在位置最陡峭的方向，这是比较耗时的。那么为了在太阳下山之前到达山底，就要尽可能的减少测量方向的次数。这是一个两难的选择，如果测量的频繁，可以保证下山的方向是绝对正确的，但又非常耗时，如果测量的过少，又有偏离轨道的风险。所以需要找到一个合适的测量方向的频率，来确保下山的方向不错误，同时又不至于耗时太多！梯度下降的基本过程就和下山的场景很类似。首先，我们有一个可微分的函数。这个函数就代表着一座山。我们的目标就是找到这个函数的最小值，也就是山底。根据之前的场景假设，最快的下山的方式就是找到当前位置最陡峭的方向，然后沿着此方向向下走，对应到函数中，就是找到给定点的梯度 ，然后朝着梯度相反的方向，就能让函数值下降的最快！因为梯度的方向就是函数之变化最快的方向(在后面会详细解释)所以，我们重复利用这个方法，反复求取梯度，最后就能到达局部的最小值，这就类似于我们下山的过程。而求取梯度就确定了最陡峭的方向，也就是场景中测量方向的手段。那么为什么梯度的方向就是最陡峭的方向呢？接下来，我们从微分开始讲起微分微分的意义：1.函数图像中，某点的切线斜率。2.函数的变化率梯度梯度实际上就是多变量微分的一般化由图可知梯度就是分别对每个变量进行微分，然后用逗号隔开，梯度是用&lt;&gt;包括起来，说明梯度其实是一个向量梯度是微积分中一个很重要的概念，之前提到过梯度的意义1.在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率2.在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向3.梯度是偏导数的矢量这就是为什么我们要求梯度，梯度的方向告诉我们函数在给定点上升最快的方向，那么梯度的反方向就是函数在给定点下降最快的方向，只要沿着梯度的反方向一直走，就能走到局部的最低点。梯度下降算法的数学解释：此公式的意义是：J是关于Θ的一个函数，我们当前所处的位置为Θ0点，要从这个点走到J的最小值点，也就是山底。首先我们先确定前进的方向，也就是梯度的反向，然后走一段距离的步长，也就是α，走完这个段步长，就到达了Θ1这个点！梯度前加一个负号意味着朝着梯度相反的方向前进，为了确定损失函数曲线上的下一个点，会将梯度大小一部分与起点相加。α的含义α在梯度下降算法中被称为学习速率或则步长，意味着我们可以通过α来控制每一步走的距离，避免错过最低点，同时也要保证不要走得太慢，导致太阳下山了，还没走山下，所以α的选择在梯度下降法中往往是非常重要的，选择α的值不能太大或者太小梯度下降算法的实例单变量函数的梯度下降梯度下降的迭代计算过程：经过四次的运算，也就是走了四步，基本就抵达了函数的最低点，也就是山底多变量函数的梯度下降多变量线性回归的表达式为hθ(x) = θ0+θ1x1+θ2x2+···+θnxn多变量函数梯度下降更新参数的公式：多变量函数更新参数与单一变量函数更新公式的区别在于：多变量函数将多种变量(多种特征)看成是一个向量矩阵，将变量的参数又看成是一个向量矩阵，通过两个向量矩阵相乘，得到一个包含各种特征的多项式,这个多项式就是多变量线性回归的表达式。对于多变量线性回归进行梯度下降的目的是：找出使得代价函数最小的一系列参数(θ)。注意：我们在使用梯度下降算法之前，归一化数据很必要设置初始起点初始的学习率：函数的梯度：进行多次迭代此时基本靠近函数的最小值点代码实现将均值误差代价函数和代价函数的梯度转化为矩阵向量相乘的形式 import numpy as np # Size of the points dataset. m = 20 # Points x-coordinate and dummy value (x0, x1). 为了将x乘到theta上，由向量的内积可知，我们应该给每一个点X增加一维，这一维的值固定为1，这样这一维才会乘到theta中 X0 = np.ones((m, 1)) X1 = np.arange(1, m+1).reshape(m, 1) X = np.hstack((X0, X1)) # Points y-coordinate y = np.array([ 3, 4, 5, 5, 2, 4, 7, 8, 11, 8, 12, 11, 13, 13, 16, 17, 18, 17, 19, 21 ]).reshape(m, 1) # The Learning Rate alpha. alpha = 0.01 以矩阵向量的形式定义均值误差代价函数和代价函数的梯度 def error_function(theta, X, y): '''Error function J definition.''' diff = np.dot(X, theta) - y return (1./2*m) * np.dot(np.transpose(diff), diff) def gradient_function(theta, X, y): '''Gradient of the function J definition.''' diff = np.dot(X, theta) - y #Numpy.dot返回两数组的点积 return (1./m) * np.dot(np.transpose(X), diff) #Numpy.transpose为矩阵的转置函数 算法的核心部分，梯度下降迭代计算 def gradient_descent(X, y, alpha): '''Perform gradient descent.''' theta = np.array([1, 1]).reshape(2, 1) gradient = gradient_function(theta, X, y) while not np.all(np.absolute(gradient) &lt;= 1e-5): theta = theta - alpha * gradient gradient = gradient_function(theta, X, y) return theta 返回的theta作为预测函数的参数 下山的人实际上就代表了反向传播算法，下山的路径其实就代表着算法中一直在寻找的参数θ，山上当前点最陡峭的方向实际上就是代价函数在这一点的方向，场景中观测最陡峭方向所用的工具就是微分，在下一次观测之前的时间就是由我们算法中的学习率α所定义的。均值归一化处理将特征的取值范围较大的进行归一化处理让它们的取值范围基本上接近，以达到快速收敛的效果。1.可以用该特征除以该特征的取值范围，来使取值范围缩小2.还可以用该特征的取值减去该特征的平均值再除以该特征的取值范围(指的是取值范围最大的值减去取值范围最小的值)来使取值范围缩小####正规方程正规方程的局限性：只适用于线性模型，不适用于逻辑回归等其他模型，二梯度下降则适用于任何模型。多变量线性回归代价函数：多变量线性回归函数 正规方程用于处理多变量线性回归的参数求解，与单变量线性方程参数求解相似，都是关于相应的参数求解其偏导数的值正规方程推导设有m个训练实例，每个实例有n个特征，则训练实例集为：其中$x_j^i$表示第i个实例第j个特征特征参数为：,输出变量为：代价函数为：进行求偏导数，等价于如下的形式:第一项第二项该矩阵求导为分母布局下$\\frac{标量}{向量}$形式第三项该矩阵求导为分母布局下$\\frac{标量}{向量}$形式第四项该项为标量可以看成是一个常数根据该矩阵求导为分母布局下$\\frac{标量}{向量}$形式综上，正规方程为：特征参数表示","categories":[{"name":"机器学习笔记","slug":"机器学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"特征选择与稀疏学习","slug":"特征选择与稀疏学习","date":"2022-09-09T07:13:37.329Z","updated":"2022-09-09T07:13:37.329Z","comments":true,"path":"2022/09/09/te-zheng-xuan-ze-yu-xi-shu-xue-xi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/te-zheng-xuan-ze-yu-xi-shu-xue-xi/","excerpt":"","text":"###特征选择与稀疏学习对一个学习任务来说，给定属性集，称这些属性为特征，其中有一些属性对当前学习任务来说很有效，这些属性称为相关特征，对当前任务没什么效果的属性，称为无关特征。还有一类特征称为冗余特征，它们所包含的特征能从其他的特征中推演出来，例如：立方体对象，已有特征“底面长”，“底面宽”，则“底面积”就是冗余特征，冗余特征在很多时候不起作用，但它有时能降低学习任务的难度（根据学习任务不同来决定，如：求立方体的体积时底面积就能使体积的估算更简单），若某个冗余特征恰好对应了完成学习任务所需的“中间概念”，则该冗余特征是有益的。现在大部分机器学习任务中，特征选择占有重要的地位，特征选择是一个数据预处理的过程。特征选择对学习任务的好处其一：因为在机器学习任务中，当给定样本中属性过多时，会经常遇到维数灾难的问题，特征选择能选出其中重要的特征，之后再进行学习过程就能大为减轻维数灾难的问题。其二：去除不相关的特征往往会降低学习任务的难度，将纷繁复杂的因素抽丝剥茧，只留下关键因素，则真相往往更容易看清。注意： 特征选择的过程中必须确保不丢失重要特征，否则后续的学习过程会因为重要信息的缺失而无法获得好的性能，而且特征选择是对当前学习任务而言的，不同的学习任务，相关特征的选择不同 特征选择与降维的区别：前者只是去掉原本特征里和结果预测关系不大的，后者做特征的计算组合构成新特征。 ####子集搜索问题对于给定的特征集合，将每个特征看作一个个候选子集，接着利用信息增益的方法来评价每个候选子集的好坏，接着将评出好的那个特征加入到上一轮中的每个候选子集中，再进行新一轮的评价，直到无法找到更好的候选子集为止。前向搜索先将给定的特征集合，分为一个个单特征的候选子集，进行评价，将评好的特征作为选定集，接着将选定集中的特征与剩余的候选子集分别组合，再一一进行评价，将评价好的特征子集组合作为选定集。假设在第k+1轮时最优的（k+1）特征子集组合不如上一轮的选定集，则停止子集搜索选取上一轮的选定集作为特征选择的结果。后向搜索从完整的特征集合开始，每次尝试减去一个特征再评价，直到减去特征后的特征子集的评价结果不如减去前的特征集合时停止子集搜索，选取减去特征前的特征子集为特征选择的结果。双向搜索每一轮增加评价好的相关特征（这些特征在后续轮中不会被去除），减去评价不好的特征。上述的策略都是贪心的，因为它们仅考虑了使本轮选定集最优，没有从全局方面去选择最合适的选择。####子集评价利用到了信息熵和信息增益的知识点，信息增益越大说明特征子集包含的有助于分类的信息越多，对于每个候选特征子集，计算其信息增益，以此作为评价标准。###过滤式选择二分类问题（Relief） 相关统计量：用来度量特征的重要性（向量），其每个分量分别对应一个初始特征 猜中近邻：对于一个样本的一个特征（属性），在与该样本同类样本的该特征中寻找和该样本在这个特征下对应的值差距最小的样本值，记为：$x_i,_{nh}$ 猜错近邻：对于一个样本的一个特征（属性），在与该样本不同类的该特征中寻找和该样本在这个特征下对应的值差距最小的样本值,记为：$x_i,_{nm}$ 在相关统计量的度量下，最终只需要指定一个阈值，然后选择比阈值大的相关统计量分量所对应的特征即可；也可以指定欲选取的特征个数k，然后选择相关统计量分量前k个特征。如何确定相关统计量？根据公式，j表示该该样本对应的特征，diff表示该样本对应特征下的值与其对应的猜中近邻（猜错近邻）的距离的平方。若该公式得到的结果是负数，则说明属性j对于区分同类与异类样本是其负面作用的，于是减少属性j对应的相关统计量的分量，否则说明属性j对于区分同类与异类样本是有益的，于是增大属性j对应的相关统计量的分量。最后对基于不同的样本得到的估计结果进行平均，就得到各属性的相关统计量分量，分量值越大，则对应属性的分类能力就越强。多分类问题（Relief-F）注意： 这里的数据值都是经过归一化处理的，已规范到[0,1]区间。","categories":[{"name":"机器学习笔记","slug":"机器学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"模型评估与选择","slug":"模型评估与选择","date":"2022-09-09T07:13:37.310Z","updated":"2022-09-09T07:13:37.311Z","comments":true,"path":"2022/09/09/mo-xing-ping-gu-yu-xuan-ze/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/mo-xing-ping-gu-yu-xuan-ze/","excerpt":"","text":"###经验误差训练模型的实际预测输出与样本的真实输出之间的差异称为误差训练模型在训练集上的误差称为”训练误差（经验误差）“训练模型在新样本上的误差称为“泛化误差”在很多情况下，得到一个经验误差很小的模型还是比较容易，但这并不是人们所希望看到的训练模型，在新样本上表现很好的训练模型才是人们不断追求的。###过拟合为了降低模型的泛化误差，应该从训练样本中尽可能学出适用于所有潜在样本的“普遍规律”这样在遇到新样本时才能做出正确的判断。然而，训练模型把训练样本学得“太好了”的时候，很可能已经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化能力下降，这种现象在机器学习中称为“过拟合”###欠拟合相对于过拟合，欠拟合就像个弟弟，对训练样本的一般性质都还没学好，欠拟合一般是由于学习能力低下造成的，过拟合最常见的情况是由于学习能力过强造成的。但是欠拟合比较容易克服，只要增加训练次数，可以提高模型的泛化能力，而过拟合则很麻烦，过拟合也是机器学习面临的关键障碍，而且在机器学习的各方面过拟合是无法彻底避免的###模型选择在现实任务中，往往有多种学习算法可供选择，甚至对同一个学习算法，当使用不同的参数配置时，也会产生不同的模型，理想的解决方案当然是对候选模型的泛化误差进行评估，然后选择泛化误差最小的模型。####评估方法通过实验测试来对模型的泛化误差进行评估进而做出选择。因此，需要一个“测试集”来测试模型对新样本的判别能力。然后以测试集上的“测试误差”作为泛化误差的近似。测试样本是从样本真实分布中独立同分布采样而得，需注意的是：测试集应该尽可能与训练集互斥，即测试样本尽量不在训练集中出现，未在训练过程中使用过。因为将测试样本放到训练集中相当于把测试答案告诉了模型，不能体现出模型的泛化能力强。留出法这是一种划分数据集的方法，它直接将原始数据集划分为两个互斥的集合，其中一个集合作为训练集S,另一个作为测试集T，在训练集上训练出模型后，用测试集来评估泛化误差。注意：训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响，例如在分类任务中至少要保持样本的类别比例相似。从采样的角度来看待数据集划分的过程，保留类别比例的采样方法通常称为“分层抽样”。在数据集中一般会有正例和反例两个类别，假如现在有一个含有1000个实例的数据集，抽取300个实例作为测试集，700个样本作为训练集，在数据集中有700个正例300个反例，此时应该在正例和反例中分别抽取350个实例作为训练集，然后再在正反例中分别抽取150个实例作为测试集，否则，当样本类别比例差别很大，则误差估计将由训练/测试数据分布的差异而产生偏差。注意：单次使用留出法得到的估计结果往往是不够稳定可靠的，在使用留出法时，一般要采用若干次随机划分，重复进行实验评估后取平均值作为留出法的评估结果。使用留出法注定不能将完整的原始数据集作为训练集来训练模型，但是为了模型的准确性，一般按$\\frac{2}{3}$~$\\frac{4}{5}$来划分原始数据集交叉验证法(k折交叉验证)先将原始数据集划分为k个大小相似的互斥子集，每个子集用分层抽样的方法保持数据分布的一致性，划分好数据子集后，每次用k-1个子集的并集作为训练集，将余下的那个子集作为测试集，这样就可以进行k次训练和测试，最终返回的是这个k个测试结果的均值。交叉验证法的评估结果和稳定性和保真性在很大程度上取决于k的取值。“留一法”是交叉验证法的一个特例，假定数据集中包含了m个样本实例，令k=m。留一法不受随机样本划分的方式的影响，因为m个样本只有唯一的方式划分为m个子集——每个子集包含一个样本。留一法使用的的训练集与初始数据集相比只少了一个样本，这个样本作为测试集，这样使得被实际评估的模型与期望评估的用原始数据集训练得到的模型就很相似。然而，留一法的缺陷在于：随着数据集规模变大，训练m个模型的计算开销可能是难以忍受的。自助法(bootstrapping)以自助采样为基础，有一个包含m个样本的数据集D，现在每次在D中随机挑选出一个样本放在数据集D’中，进行m次挑选后，D’中是包含m个样本的数据集，但是D中的一些样本会在D’中出现多次，而有另一部分样本不出现。通过自助采样，原始数据集中部出现在D’中约占D的36.8%，将D’作为训练集，那些36.8%的样本作为测试集，得出的测试结果称为“包外估计”自助法的局限性：在数据集较小、难以有效划分训练/测试集的时候很有用。自助法能从原始数据集中产生多个不同的训练集，这对集成学习有很大的好处。然而，自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差。因此，在原始数据集数量足够时，用留出法和交叉验证法比较多。####调参与最终模型大多数学习算法都有些参数需要设定，参数配置不同，模型的性能往往有显著差别，因此，在模型的评估与选择时，除了要对适用学习算法进行选择，还需对算法进行设定，这就是通常说的“参数调节”或“调参”机器学习中一般涉及两类参数：一类是算法参数，即“超参数”。数目通常在10内。另一类是模型的参数，两者调参方式相似，均是产生多个模型后基于某种评估方法来进行选择，不同之处在于前者通常是人工设定多个参数候选值，后者则是通过学习来产生多个候选模型（例如神经网络在不同轮数停止训练）在模型评估中只用了一部分的样本做为训练集，另一部分样本作为测试集，在模型选择完成后，学习算法和参数配置已选定后，应该在这个学习算法和参数设置的前提下去，重新以原始数据集中的所有样本来作为训练集，这才是最终交给用户的模型。","categories":[{"name":"机器学习笔记","slug":"机器学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"决策树","slug":"决策树","date":"2022-09-09T07:13:37.299Z","updated":"2022-09-09T07:20:22.430Z","comments":true,"path":"2022/09/09/jue-ce-shu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/jue-ce-shu/","excerpt":"","text":"决策树 决策树是一种基本的分类与回归方法，==决策过程中提出的每一个判定问题都是对某一个属性的“测试”，每个测试结果或是导出最终结论，或是导出进一步的判定问题，其考虑范围在上次决策结果的限定范围之内。== 决策树学习的目的是 ==为了产生一颗泛化能力强，即处理未见示例能力强的决策树==。决策树图形如下图所示 决策树在分类问题中，表示基于特征对实例进行分类的过程，可以认为它是if-then规则，也可以认为他是定义在特征空间与类空间上的条件概率分布 假设给定训练数据集 $$\\boldsymbol{D={(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)}}$$其中，$\\boldsymbol{x_i=(x_i^{(1)},x_i^{(2)},\\cdots,x_i^{(n)})^T}$ 为输入实例，也叫做特征向量，$\\boldsymbol{n}$ 为特征个数，$\\boldsymbol{y_i\\in{1,2,\\cdots,K}}$ 为类标记，$\\boldsymbol{i=1,2,\\cdots,N}$，$\\boldsymbol{N}$为样本容量。 以去食堂吃饭为例： 它的特征空间分布如下图： 在上例中特征向量的维数为2，也就是只有两个判断特征，那么它的特征空间就是二维平面的，类别数也只有两个：去吃饭和吃nm，其中 $\\omega_1,\\omega_2$ 为实例的两个类别（去吃饭和吃nm），假定特征 $\\boldsymbol{x_1}$ 的阈值为 $\\boldsymbol{\\epsilon_1}$ ，特征 $\\boldsymbol{x_2}$ 的阈值为 $\\boldsymbol{\\epsilon_2}$ ，根据阈值将特征空间划分为几个部分 上图就是本人每天去食堂的心理决策图，可以看出先进行决断的指标是在我看来最重要的，也就是在我心中占比最大的，之后的指标的重要程度一层层降低。这在决策树中也是一样的，这些指标在决策树中被称为规则。 特征选择计算机通过一些特别的算法能理解数据中所蕴含的知识信息，这些数据被称为特征，划分数据集中实例的规则就是从这些特征中选出来。那么在数据集中实例的特征会有一些对划分实例有比较重要的作用，有一些特征对于划分实例没什么作用，那么就会产生一些问题。 数据集哪个特征在划分数据分类时起决定作用？为了找到决定性的特征，划分出最好的结果，我们必须评估每个特征，使杂乱无章的数据变得更加有序，原始数据集被划分为几个数据子集。 这些数据子集会分布在第一个决策点的所有分支上，如果某个分支下的数据属于同一个类型，则无需进一步对数据集进行分割。如果数据子集内的数据不属于同一类型，则需要重复分割数据子集的过程，划分数据子集的算法和划分原始数据集的算法相同，直到所有具有相同类型的数据均在一个数据子集。 如何判断划分的子集属于父集？首先引入一个概念信息增益（在划分数据集之前之后信息发生的变化），可以使用信息论量化度量信息的内容。 信息熵 一条信息的信息量与其不确定性有着直接的联系。例如：我们要搞清楚一件不确定的的事，一无所知的事，就需要大量的信息，相反如果对某件事了解较多，则不需要太多的信息就能把它搞清楚。从这个角度来看，可以认为，信息量等于不确定性的多少。==系统不确定性越多，信息熵就越大。== 信息熵表示为：$$\\boldsymbol{Ent(D)=-\\sum^K_{k=1}p_k\\log_2(p_k)}$$单位是比特（bit）$\\boldsymbol{K}$ 表示数据集中有 $\\boldsymbol{ K }$个类别，$\\boldsymbol{p_i}$表示第 $\\boldsymbol{i}$ 类样本在样本集合 $\\boldsymbol{D}$ 中所占比例为 信息论中的冗余度：表示信息重复的指标，重复的信息越多，信息量就越小，冗余度就越高。 条件熵 在阅读的过程中，我们联系上下文去理解某段话的深层次的含义，这是个寻找相关信息的过程。事实证明，“相关的”信息也能够消除不确定性 现在假设X和Y是两个随机变量。Y是我们想要了解的，它的熵是$$\\boldsymbol{H(X) = -\\sum^n_{i=1}p(x_i) \\log p(x_i)}$$ 而且我们还知道Y和X一起出现的概率，也就是X，Y的联合概率分布$$\\boldsymbol{p(X=x_i,Y=y_i)=p_{ij},i=1,2,…,n;j=1,2,…,n}$$以及在X取不同值的情况下Y的概率分布，在数学上称为条件概率分布，则定义在X的条件下的条件熵为：$$\\boldsymbol{\\begin{aligned}H(Y \\mid X) &amp;=\\sum_{x \\in X} p(x) H(Y \\mid X=x) \\&amp;=-\\sum_{x \\in X} p(x) \\sum_{y \\in Y} p(y \\mid x) \\log p(y \\mid x) \\&amp;=-\\sum_{x \\in X} \\sum_{y \\in Y} p(x, y) \\log p(y \\mid x)\\end{aligned}}$$ 互信息 互信息是两个随机事件“相关性”的量化度量，即判断两个随机事件是否存在相关性 互信息定义：$$\\begin{aligned}I(X ; Y) &amp;=H(X)-H(X \\mid Y) \\&amp;=H(X)+H(Y)-H(X, Y) \\&amp;=\\sum_{x} p(x) \\log \\frac{1}{p(x)}+\\sum_{y} p(y) \\log \\frac{1}{p(y)}-\\sum_{x, y} p(x, y) \\log \\frac{1}{p(x, y)} \\&amp;=\\sum_{x, y} p(x, y) \\log \\frac{p(x, y)}{p(x) p(y)}\\end{aligned}$$ 相对熵（交叉熵） 相对熵也用来衡量相关性，但与互信息不同，它是用来衡量两个取值为正数的函数的相似性 结论： 对于两个完全相同的函数，它们的相对熵等于零 相对熵越大，两个函数差异越大：反之，相对熵越小，两个函数差异越小 对于概率分布或概率密度函数，如果取值均大于零，相对熵需要指出的是相对熵是不对称的 信息增益（ID3的做法） 在==划分数据集之后信息发生的变化==称为信息增益，注意：信息熵只与样本类别有关，与样本特征无关。 定义：$$\\boldsymbol{Ent(D)=-\\sum^K_{k=1}\\frac{|C_k|}{|D|}\\log_2(\\frac{|C_k|}{|D|})}$$$$\\boldsymbol{ \\begin{aligned}Gain(D,a) &amp;= Ent(D)-\\sum^V_{v=1}\\frac{|D^v|}{|D|}Ent(D^v)\\ &amp;=-\\sum^K_{k=1}\\frac{|C_k|}{|D|}\\log_2(\\frac{|C_k|}{|D|})+\\sum^n_{i=1}\\frac{|D_{i}|}{|D|}\\sum^K_{k=1}\\frac{|D_{ik}|}{|D_i|}\\log_2{\\frac{|D_{ik}|}{|D_I|}}\\end{aligned}}$$ $\\boldsymbol{C_k}$表示 $\\boldsymbol{k}$ 个类，$\\boldsymbol{|C_k|}$表示类$\\boldsymbol{C_k}$的样本个数 特征属性 $\\boldsymbol{ a }$ 的 $\\boldsymbol{ n }$ 个可能的取值：$\\boldsymbol{ { a^1,a^2,\\cdots,a^n} }$ 根据特征 $\\boldsymbol{ a }$的取值将集合 $\\boldsymbol{ D }$ 划分为$\\boldsymbol{ {D_1,D_2,\\cdots,D_n} }$ $\\boldsymbol{D_{ik}}$ 表示子集 $\\boldsymbol{D_i}$ 中属于类 $\\boldsymbol{C_k}$ 的样本个数 $\\boldsymbol{|D|}$ 表示样本空间的个数，$\\boldsymbol{|D_{ik}|}$ 表示对于集合 $\\boldsymbol{D}$中取值为 ==一般地，熵与条件熵的差就是互信息==，也就说互信息就是信息增益 增益率（C4.5的做法）实际上，信息增益准则对==可取值数目较多的特征属性有所偏好==，为减少这种偏好可能带来的不利影响，著名的C4.5决策树算法不直接使用信息增益，而是使用“增益率”来选择最优化分属性。$$增益率=\\frac{特征属性的信息增益}{该特征属性的香农熵}$$ ID3算法实现 我们将对每个特征划分数据集的结果计算一次信息增益，然后判断哪个特征划分数据集是最好的划分方式。 训练数据集 $\\boldsymbol{D}$，特征集 $\\boldsymbol{A}$ 以及阈值为$\\boldsymbol{\\epsilon}$ 先遍历取出训练集中的特征 计算出所取出的特征的每种取值下划分出的子集的条件熵 用全集的信息熵减去所取出特征计算出的条件熵就可以得到该特征的信息增益（互信息） 最后将所有特征计算出来的信息增益排序，选取信息增益最大的那个特征 $\\boldsymbol{A_g}$ 如果这个信息增益最大的特征的信息增益小于阈值$\\boldsymbol{\\epsilon}$，则将数据集中的所有实例划分为一个结点，将数据集实例数最多的类作为该节点的类标记 如果这个特征的信息增益大于阈值，就根据该特征下的几种不同的取值，对数据集进行划分，将数据集分为若干个非空子集 $\\boldsymbol{D_i}$ ，将 $\\boldsymbol{D_i}$ 中实例数最大的类作为标记，构建子节点 对第 $\\boldsymbol{i}$ 个子节点，以 $\\boldsymbol{D_i}$ 为训练集，以 $\\boldsymbol{A-{A_g}}$ 为特征集，递归地调用1~6步骤，得到子树 注意：如果训练集 $\\boldsymbol{D}$ 中所有实例属于同一类则将该训练集中的实例归结的单个节点，并将该类作为该节点的类标记； 递归结束条件：$\\boldsymbol{A = \\varnothing}$ 当特征集为空时将训练集中的所有实例归结为一个节点，并将训练集中实例数最多的类作为该节点的类标签 剪枝处理 剪枝(pruning)是决策树学习算法对付 “过拟合” 的主要手段 在决策树学习中，为了尽可能正确分类训练样本，结点划分过程不断重复，==有时会导致决策树分支过多，这时就会导致因训练样本学习得“太好”，以致于把训练集自身的一些特点当作所有数据都具有的一般性质而导致过拟合==，因此，可通过主动去掉一些分支来降低过拟合的风险。 预剪枝（prepruning）是指在决策树生成过程中，对每个节点在划分前先进行估计，若当前节点的划分不能带来决策树泛化能力的提升，则停止划分并将当前节点标记为终止节点。 ==预剪枝会导致决策树很多分支都没有“展开”==，这不仅降低了过拟合的风险，还显著减少了决策树的训练时间的开销和测试时间开销。==但另一方面，有些分支的当前划分虽不能提升泛化性能，甚至可能导致泛化性能暂时下降，但在其基础上进行的后续划分却有可能导致性能显著提高==；预剪枝基于“贪心”本质禁止这些分支展开，给预剪枝决策树带来了欠拟合的风险。 后剪枝（post-pruning）是先从训练集中生成一颗完整的决策树，然后自底向上地对==特征判断节点==进行判断，若该结点对应的子节点能带来决策树的泛化能力提升，则将该子树替换为终止节点。 一般情形下，后剪枝决策树欠拟合的风险很小，泛化能力往往优于预剪枝决策树，但后剪枝过程是在生成完全决策树后进行的，并且要自底向上地对树中所有非终止节点进行逐一考查，因此==其训练时间开销比未剪枝决策树和预剪枝决策树都要大得多。== 决策树的剪枝 决策树递归产生的二叉树，对训练数据的分类非常准确，但是对于未知的测试数据的分类却没有那么准确，即出现过拟合的现象，为了解决这个问题就要考虑决策树的复杂度，对已生成的决策树进行简化，因此要对递归生成的决策树进行剪枝处理。 ==决策树的剪枝一般通过最小化决策树整体的损失函数或代价函数来实现== 设决策树 $T$ 的终止节点个数为 $\\left|T \\right|$ ，$t$ 为树 $T$ 的终止节点，该终止节点上有 $N_t$ 个样本点，其中 $k$ 类样本点有 $N_{tk}$ 个，$k=1,2,\\cdots,K$，$H_t(T)$ 为终止节点 $t$ 上的==经验熵==，$\\alpha\\geq 0$ 为参数 经验熵是熵和条件熵中的概率由数据估计（如：极大似然估计）得到时，所对应的熵与条件熵分别称为经验熵和经验条件熵计算公式为：$$H_{\\alpha}(T) = -\\sum_K\\frac{N_{tk}}{N_t}\\log\\frac{N_{tk}}{N_t}$$ 决策树的损失函数：$$\\begin{aligned}C_{\\alpha}(T) &amp;= \\sum^{\\left|T\\right|}{t=1}N_tH_t(T)+\\alpha \\left|T\\right|\\&amp;=-\\sum^{\\left|T\\right|}{t=1}\\sum_{k=1}^KN_{tk}\\log\\frac{N_{tk}}{N_t}+\\alpha\\left|T\\right|\\end{aligned}$$记：$$C(T)==-\\sum^{\\left|T\\right|}{t=1}\\sum{k=1}^KN_{tk}\\log\\frac{N_{tk}}{N_t}$$则：$$C_{\\alpha}(T)=C(T)+\\alpha\\left|T\\right|$$ 其中$C(T)$ 表示模型对训练数据的预测误差，即==模型与训练数据的拟合程度==，$\\left|T\\right|$表示模型复杂度，参数$\\alpha\\geq0$ 的作用是控制两者（模型复杂度和模型与训练数据的拟合程度）之间的影响，较大的 $\\alpha$会促使选择较简单的模型（树），较小的 $\\alpha$会促使选择较复杂的模型（树）。$\\alpha=0$意味着只考虑模型与训练数据的拟合程度，不考虑模型的复杂度。 剪枝，就是当 $\\alpha$ 确定的条件下，选择损失函数最小的模型。当 $\\alpha$ 确定时子树越大，往往与训练数据的拟合程度越好，但模型的复杂度就越高；子树越小，模型的复杂度就越小，但往往和训练数据的拟合程度就越差 剪枝函数的最小化相当于正则化的极大似然估计 剪枝的过程： 计算每个终止节点的经验熵 递归地从决策树的终止节点向上回缩。假如一个父节点下的终止节点回缩到其父节点之前与之后的整体树分别为 $T_B$ 和 $T_A$ ，其对应的损失函数值分别为 $C_{\\alpha(T_B)}$ 和 $C_{\\alpha(T_A)}$ ，如果$$C_{\\alpha(T_A)}\\leq C_{\\alpha(T_B)}$$则说明终止节点回缩到其父节点之后的模型（树）比未回缩前的模型（树）更好 回到2，直到不能继续为止，得到损失函数最小的子树$T_{\\alpha}$ 决策树的剪枝算法可以由一种动态规划的算法实现 连续值与缺失值 现实学习任务中常会遇到连续属性，连续属性可能是一系列没有明确意义的字，因此连续属性的可取值数目不再有限，所以不能直接根据连续属性的可取值来对结点进行划分。 现实任务中常会遇到不完整的样本，即==样本的某些属性值缺失==，尤其是当属性数目较多的情况下，往往会有大量的样本出现缺失值。==如果简单地放弃不完整的样本，仅使用无缺失值的样本来进行学习，显然是对数据极大的浪费。== 连续值的处理此时连续属性离散化的技术就派的上用场了，最简单的方法就是采用二分法(bi-partition)对连续属性的可取值范围进行处理，给定样本集D和连续属性a，假定a在D上出现了n个不同的取值，将这些值从小到大进行排序，找到这些值的中点，以中值为基础将这些值划分为两个部分，一部分在中值的左边，一部分在中值的右边，因为在这些值中，对相邻的取值来说，在相邻取值区间内取任意值所产生的划分结果相同。因此我们可考查这些相邻点的之间区间内的点，对于连续属性的可取值范围可以将其划分为n-1个小区间，这样就可以像离散属性值一样来考察这些细分的小区间。 二分法处理连续值：有 $n$ 个连续值就会划分为 $n-1$ 个小区间 缺失值的处理在遇到含缺失值的样本数据的时候，有必要考虑利用有缺失属性值的样本数据来进行学习。这时，我们需要解决两个问题：1.如何在特征值缺失的情况下进行划分特征值的选择？（在选择结点的情况下面对含缺失值的样本的处理方式）2.给定划分特征，若样本在该特征上的值缺失，如何对样本进行划分？（即究竟要把含缺失值的样本划分到哪个结点里） 比较发现，“纹理”在所有属性中的信息增益值最大，因此，“纹理”被选为划分属性，用于对根节点进行划分。划分结果为：“纹理=稍糊”分支：{7,9,13,14,17}，“纹理=清晰”分支：{1,2,3,4,5,6,15}，“纹理=模糊”分支：{11,12,16}。如下图所示： 那么问题来了，编号为{8,10}的样本在“纹理”这个属性上是缺失的，该被划分到哪个分支里？前面讲过了，这两个样本会同时进入到三个分支里，只不过进入到每个分支后权重会被调整（前面也说过，在刚开始时每个样本的权重都初始化为1）。编号为8的样本进入到三个分支里后，权重分别调整为5/15，7/15 和 3/15；编号为10的样本同样的操作和权重。因此，经过第一次划分后的决策树如图所示： 我们都知道构造决策树的过程是一个递归过程，原来不打算继续介绍递归过程了，但是因为权重发生了变化，所以继续介绍下递归过程。接下来，递归执行“纹理=稍糊”这个分支，样本集D = {7，8，9，10，13，14，17}，共7个样本。如下图所示： 下面来看具体的计算过程： 对比能够发现属性“敲声”的星系增益值最大，因此选择“敲声”作为划分属性，划分后的决策树如下图所示： 结点{9,14,17}因为包含的样本全部属于同一类别，因此无需划分，直接把结点{9,14,17}标记为叶结点，如下图所示： 根据递归过程，接下来对分支“敲声 = 浊响”即结点{7，8，13}进行划分，计算过程和上面一样，虽然我也算过了，但是不再贴出来了，需要注意的是样本的权重是1/3。计算完比较能够知道属性“脐部”的信息增益值最大，因此选择“脐部”作为划分属性，划分完的决策树如下图所示： 接下来，继续，对于结点{13}，因为就一个样本了，直接把该结点标记为叶结点，类别为“坏瓜”；递归到结点{7，8}，因为样本类别相同，所以也标记为叶结点，类别为“好瓜”；递归到结点“脐部=平坦”，因为这个结点不包含任何样本为空集，因此，把该结点标记为叶结点，类别设置为父节点中多数类的类别，即为“好瓜”。因此“纹理=稍糊”这颗子树构造完毕，如下图所示： 接下来，只需递归的重复上述过程即可，即能训练出一颗完整的决策树，最终的决策树如下图所示: 多变量决策树若把样本中的每个特征看作是坐标空间中的一个坐标轴，则 $n$ 个特征描述的样本就对应了 $n$ 维空间中的一个数据点，对样本分类则意味着在这个特征空间中找不同类样本之间的分类边界。决策树所形成的分类边界有一个明显的特点：轴平行，即它的分类边界由若干个与坐标轴平行的分段组成。这样的分类边界使得学习结果有较好的可解释性，因为每一段划分都直接对应了某个特征取值。但在学习任务的真实分类边界比较复杂时，必须使用很多段才能获得较好的近似。","categories":[{"name":"机器学习笔记","slug":"机器学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据结构—高级字典结构","slug":"数据结构—高级字典结构","date":"2022-09-09T07:13:37.288Z","updated":"2022-09-09T07:13:37.289Z","comments":true,"path":"2022/09/09/shu-ju-jie-gou-gao-ji-zi-dian-jie-gou/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-ju-jie-gou-gao-ji-zi-dian-jie-gou/","excerpt":"","text":"高级字典结构 主要介绍字典与索引的关系，讨论字典的其他实现：以字符为结点的字符树，以关键码为结点的二叉排序树（包括静态的最佳二叉排序树和保持动态平衡的二叉排序树） 字典和索引的关系索引的引入散列检索操作是以关键码（key）作为根据进行的，因此往往忽略对值的处理，并把值得类型也固定死。但是在实际应用中，值的形式有多种多样，例如：一把钥匙去开一个房门，里面不一定就是固定的东西 不同的值需要不同大小的空间，这样的字典就很难采用散列的方式来存储，因此为了解决不等长元素字典的表示问题，引入一种辅组结构：索引 索引实际上就算一个从关键码到地址的转换关系 字典的索引另外开辟一个目录表存放指向字典值的指针，这个目录表的作用就是索引 检索一个元素时，只要在目录表找到对应的关键码，就可以得到对应结点的存储位置，若是目录表的关键码经过排序有序后，查找元素会变得更加简单 索引和散列的异同索引和散列都是给出一种从关键码到存储地址的映射方法，但是散列法的映射是通过函数定义，而索引法是通过建立辅组的索引表解决 字符树介绍用字符树建立字典：假设所有关键码都是一个字符串，字符树就是每个结点表示关键码中的一个字符的树。在字符树中，从根出发的每条路径上所对应的字符连接起来，就得到一个字符串。 一个字典的所有关键码，可以用一个字符树（林）中从根到其他结点路径对应字符串的集合表示。 每个构成关键码的结点中，增加一个指向该关键码对应元素的位置指针，这个字符树就表示了这个字典的一个树目录 在字符树中检索关键码的过程是：==用待查关键码的第一个字符于树林的各个根的字符相比较，然后下一步的检索在前次比较相等的那棵树上进行。直到进行到某一层，待查关键码完全匹配成功，并且在字符树中对应结点有指向外部结点的指针，则该外部结点就算检索到的字典元素，检索成功；或该层所有结点的字符都与待查关键码相应位置的字符不同，这说明此关键码在数目录里没有出现，检索失败== 二叉排序树 二叉排序树作为字典（索引）的表示方法，介绍二叉排序树中进行节点的检索和插入、删除的方法 概念二叉排序树（二叉搜索树）是以关键码为结点的二叉树，具有以下性质：任一结点的左子树非空的话，则左子树的所有结点的关键码都小于根结点的关键码； 如果任一结点的右子树非空，则右子树的所有结点的关键码都大于根结点的关键码（因此二叉排序树不允许关键码比它小的元素出现） 如果按照中序周游的方式遍历二叉排序树则会得到一个递增序列的关键码 重点研究二叉排序树本身的结构，下面忽略了关键码以外的属性或者指针，把二叉排序树的结点定义为仅仅包含关键码信息。 存储结构： struct BinSearchNode; typedef struct BinSearchNode *PBinSearchNode struct BinSearchNode{ KeyType key;//结点的关键码字段 PBinSearchNode llink,rlink;//二叉树的左、右指针 }; 二叉排序树的检索二叉排序树中查找某个结点的过程和二分法检索相似，检索成功时返回指向找到的结点的指针，检索失败时返回指向该结点应==插入位置==的父结点 二叉排序树的删除要删除二叉排序树中的一个结点，必须先检索到这个结点，如果被删除结点 *p没有左子树，则可以用 *p的右子树代替 *p即可。否则，在 *p的左子树中找出关键码最大的一个结点 *r（ *p左子树中的最右结点），将 *r的右指针指向 *p的右子树，用 *p的左子树代替被删除的结点 最佳二叉排序树二叉排序树的构建对于同一个关键码集合，因为不同的关键码插入顺序会产生不一样的结果，但是什么样的二叉排序树对检索效果最好（具有最小平均比较次数）呢？对扩充二叉排序树，检索一个关键码的平均比较次数为：$$E(n)=\\frac{1}{w}\\left[\\sum_{i=1}^{n} p_{i}\\left(l_{i}+1\\right)+\\sum_{i=0}^{n} q_{i} l_{i}^{\\prime}\\right]$$$1_{\\mathrm{i}}:$ 第i个内部结点的层数 ;$1_{\\mathrm{i}}^{\\prime}$ 是第i个外部结点的层数$\\mathrm{p_i}$是检索第i个内部结点关键码的频数$\\mathrm{q}{\\mathrm{i}} $是检索第i个外部结点关键码的频数, $q_i$和$p_i$也叫结点的权$\\mathrm{p}{\\mathrm{i}} / \\mathrm{w}$ 是检索第i个内部结点关键码的概率, $\\mathrm{q}{\\mathrm{i}} / \\mathrm{w}$ 是被检索的关键码属于第i个外部结点关键码集合的概率$$w=\\sum{i=1}^{n} p_{i}+\\sum_{i=0}^{n} q_{i}$$ 构造最佳二叉排序树 先将字典元素关键码排序 对每个关键码按照二分法在排序关键码序列中执行检索，将检索中遇到的未在二叉排序数中的关键码插入二叉排序树中 平衡二叉排序树（AVL树） 最佳二叉排序树通常用于表示一旦构造好就不再改动的静态字典；对于动态字典，为了能够在进行元素的插入和删除操作时较快地对二叉排序树进行调整，通常不要求二叉排序树总是保持“最佳的”检索效率，而是希望达到一种比较容易调整的“较佳”状态。 概念每个结点的左、右子树高度之差的绝对值不超过1结点右子树高度与左子树高度之差称为该结点的平衡因子 构造平衡二叉排序树==核心问题：在执行插入、删除操作后，如何保持二叉树的平衡性？== 发现最小不平衡二叉树在AVL的构造过程中，距离插入结点最近的、且平衡因子的绝对值大于1的结点为根的子树 调整：LL型，RR型，LR型，RL型 过程： 从插入结点开始向上计算各结点的平衡因子，若某结点平衡因子绝对值大于1，则插入操作破坏了AVL的平衡性，则需要进行调整，否则继续插入 若AVL的平衡性被破坏了，则要找到最小不平衡子树的根结点，根据新插入结点与最小不平衡子树根结点之间的关系判断调整类型（LL型，RR型，LR型，RL型） 根据调整类型进行调整 调整类型 LL型旋转：扁担原理冲突：旋转优先 RR型旋转：扁担原理冲突：旋转优先 LR型左子树先逆时针旋转（变为LL型），再整体顺时针旋转 RL型右子树先顺时针旋转（变为RR型），再整体逆时针旋转 元素的删除平衡二叉排序树也是二叉排序树的一种，因此它的删除元素和二叉排序树中删除元素的方法一样，不同的地方就在于：删除了元素之后，应该如何保持它的平衡性，实际上还是根据四种调整策略来进行调整","categories":[{"name":"数据结构学习笔记","slug":"数据结构学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据结构—栈与队列","slug":"数据结构—栈与队列","date":"2022-09-09T07:13:37.280Z","updated":"2022-09-09T07:13:37.281Z","comments":true,"path":"2022/09/09/shu-ju-jie-gou-zhan-yu-dui-lie/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-ju-jie-gou-zhan-yu-dui-lie/","excerpt":"","text":"栈 在现在很多软件中，栈的使用频率相对较高，而且栈对于数据的处理有一定的便利，因此掌握栈这种数据结构对于计算机专业的我们来说更显得重要（其实所有数据结构都应该学好） 1. 栈的定义==栈是限定仅在表尾进行插入和删除操作的线性表== 把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。 栈因为其后进先出的特点，因此也被称为LIFO（Last In First Out） 结构 注意： 首先要知道栈是一个线性表，也就是说栈元素具有线性关系，即前驱后继关系，在C语言中也是通过结构体来保存栈内的数据元素的 严格遵守从栈顶进从栈顶出的特点，且是先进后出 若栈为空还执行出栈操作此时要出现错误 前面介绍了数据结构其实是一种抽象的数据类型（ADT），那么栈也有其相对应的操作 2. 栈的操作插入（进栈push）： 删除（弹栈pop）： 根据任务需要还可能有判断栈是否为空的操作 3. 栈的顺序存储结构及实现既然栈是线性表的一种特例，那么栈的顺序存储其实也是也是线性表存储的简化，这种结构的栈称为==顺序栈==。也就是用数组实现栈 一般，以数组下标为0的一端作为栈底比较好，因为首元素都存在栈底，变化最小。 由于顺序栈是由数组实现的，而数组大小都是事先声明好的，因此要定义一个 top变量 来指示栈顶元素在数组中的位置，top变量必须小于数组的长度。 创建空顺序栈的代码： typedef int DataType; struct seqStack { int MAXNUM; int top; DataType *element; }; typedef struct seqStack *PseqStack; PseqStack createNullStack_seq(int m) { PseqStack st; st = (PseqStack)malloc(sizeof(struct seqStack)); if(m==0) { st = NULL; return st; } else { st-&gt;top = -1; st-&gt;MAXNUM = m; st-&gt;element = (int*)malloc(sizeof(int)*m);; return st; } } 1. 两栈共享空间对于顺序栈来说，它有一个很大的缺陷，那就是必须事先确定数组存储空间的大小。不够用的话，只能通过其他方式来实现扩展数组的容量，很麻烦。但是如果声明的数组存储空间太大，导致数组存储空间大量被浪费的话，那也不是一个好的做法。 有什么办法可以最大限度地利用事先开辟的存储空间来进行操作呢？ 在对于两个==相同类型==的栈而言，如果为它们各自开辟数组空间，极有可能是其中一个栈满了，而另一个栈还有很多存储空间空闲，这不是浪费吗？ 这时可以用一个数组来存储这两个栈 声明的数组有两个端点，而两个栈有两个栈底，可以让其中一个栈的栈底为数组的首端，即数组下标为 0 的地方，让另一个栈底为数组的末端，即数组下标为 n-1 的地方，当两个栈增加元素时，就从两端点向中间延伸 实际上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。就像买入股票一样，你买入时，一定是有一个你不知道的人在做卖出的操作。有人赚钱就有人赔钱。这样使用两栈共享空间存储方法才有比较大的意义。否则两个栈都在不断增长，那很快就会因栈满而溢出了 4. 栈的链式存储结构及实现 栈的链式存储结构称为链栈 栈顶放在链表的哪个部分比较合适呢？由于想找到链表的元素必须要找到链表的头指针，而栈顶的指针也是必须的，因此选取链表表头的位置作为栈顶比较好，而且这样做还能使得链表不用声明一个头结点，想想==头结点的作用是为了操作的统一和方便而设立的==，而栈顶始终会在链表的头部，这样头结点就失去意义 对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间 对于空栈来说，链表原定义就算头指针指向空，也就是top=NULL struct stack1{ Datatype* top; }; typedef struct stack1 stack; 5. 栈的应用1. 递归调用 递归调用函数的方式有点类似于栈的结构特点，后调用的函数先返回 函数调用实现的三个步骤： 传送调用信息 ==分配被调函数需要的数据区==，并接受传送来的调用信息 ==把控制转移到被调函数的入口== 当被调函数执行结束，返回到调用函数时： 传送返回信息 释放被调函数的数据区 把控制按返回地址转移到调用函数中去 内存的静态分配： 在非递归调用的情况下，数据区的分配在程序运行前进行，一直到整个程序运行结束才释放 动态分配： 在递归调用的情况下，被调函数的局部量不能分配给固定的某些单元，而必须每调用一次就分配一份，当前程序使用的所有的量（包括形参、局部变量和中间工作单元等），都必须是最近一次递归调用时所分配的数据区中的值 动态分配的处理方法： 在内存中开辟一个存储区域称为==运行栈== 每次调用时，将动态区指针下推，分配被调函数所需的数据区 在每次返回时，将内存指针上移，释放本次调用所分配的数据区，恢复到上次调用所分配的数据区中 被调函数中变量地址全部采用相对于动态区指针的位移量来表示（称为相对地址） 简单来说就是，在递归调用函数时，对于每一层递归，函数的局部变量、参数值和返回地址被压入栈内，在函数返回时，位于栈顶的局部变量、参数值和返回地址被弹出 2. 中缀表达式转化为后缀表达式在我们现实生活中的算数运算都有其相对应的一些规则，比如说：先乘除后加减，括号内的优先级最高 那么计算机就是要用来帮助我们进行大量的计算的一种工具，计算机是如何理解这些运算的优先级的呢？这就要用到栈的相关知识 后缀（逆波兰）表达式的定义：一种不需要括号的后缀表达式 规则：从左到右遍历中缀表达式的每一数字和符号，若是数字就输出，即成为后缀表达式中的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级==不高于==栈顶符号则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止 右括号会将栈中的元素依次出栈直到把左括号出栈为止，但是右括号不会进栈 3. 栈混洗 ==主要思想就是通过控制入栈和出栈的时机，来获得不同序列的出栈序列== 例如现在有 $a,b,c$ 三个元素依次进栈，那么会有多少种出栈的顺序呢？ $a,b,c$ 进，再 $a,b,c$ 出，这是最直观的想法，出栈顺序为 $cba$ $a$ 进， $a$ 出，$b$ 进，$b$ 出，$c$ 进，$c$ 出，出栈顺序为 $abc$ $a,b$ 进，$b,a$ 出，$c$ 进，$c$ 出，出栈顺序为 $bac$ $a$ 进，$a$ 出，$b,c$ 进，$c,b$ 出，出栈顺序为 $acb$ $a$ 进，$b$ 进，$b$ 出，$c$ 进，$c$ 出，$a$ 出，出栈顺序为 $bca$ 4. 迷宫问题 迷宫问题就是一个深度优先搜索（DFS），深度优先搜索是一个不断回溯的过程 所谓深度优先就是说：从一个状态出发，访问当前状态的相邻的其他状态，若访问的该状态是没有被访问过的，就以该状态作为当前状态继续进行访问，一直到所访问的状态的所有相邻的状态都被访问过了就开始使用==回溯==的方法，返回到上一个状态点，继续访问当前状态点的未被访问到的相邻状态点。直到每个状态都被访问过 代码实现： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct node Datatype; struct node{ int x,y,d; Datatype* next; }; struct stack1{ Datatype* top; }; typedef struct stack1 stack; stack* create_EmptySTACK() { stack* st; st = (stack*)malloc(sizeof(stack)); st-&gt;top = NULL; return st; } stack* push_element(stack* st,int x, int y,int d){ Datatype* new_element; new_element = (Datatype*)malloc(sizeof(Datatype)); new_element-&gt;d = d; new_element-&gt;x = x; new_element-&gt;y = y; new_element-&gt;next = st-&gt;top; st-&gt;top = new_element; return st; } stack* pop_element(stack* st) { Datatype* node; if(st-&gt;top==NULL) { printf(\"empty stack\"); } else{ node = st-&gt;top; st-&gt;top = st-&gt;top-&gt;next; //free(node); } return st; } int isemptystack(stack* st) { int flag; if(st-&gt;top==NULL) { flag = 0; } else{ flag = 1; } return flag; } int search_path(int** maze,int** direction,int in1,int in2,int ou1,int ou2,int M,int N,stack* st) { int i,j,k; int g,h; int tempi,tempj,tempk; *((int*)maze + in1*M+in2) = 2; push_element(st,in1,in2,-1); while(isemptystack(st)) { tempi = st-&gt;top-&gt;x; tempj = st-&gt;top-&gt;y; tempk = st-&gt;top-&gt;d; pop_element(st); i = tempi; j = tempj; k = tempk; while(k&lt;=3) { g = i + *((int*)direction+k*2); h = j + *((int*)direction+k*2+1); if(g == ou1 &amp;&amp; h == ou2 &amp;&amp; *((int*)maze + g*M+h)==0) { tempi = i; tempj = j; tempk = k; push_element(st,tempi,tempj,tempk); while(isemptystack(st)) { printf(\"%d%d%d\\n\",st-&gt;top-&gt;x,st-&gt;top-&gt;y,st-&gt;top-&gt;d); pop_element(st); } return 0; } if(*((int*)maze + g*M+h)==0) { *((int*)maze + g*M+h) = 2; tempi = i; tempj = j; tempk = k; push_element(st,tempi,tempj,tempk); i = g; j = h; k = -1; } k=k+1; } } printf(\"The path has not found\"); } int main() { int maze[6][6]={{1,1,1,1,1,1},{1,0,0,1,1,1},{1,0,0,0,0,1},{1,0,1,1,1,1},{1,0,0,0,0,1},{1,1,1,1,1,1}}; int direction[4][2] = {{0,1},{1,0},{0,-1},{-1,0}}; stack* st; int result; st = create_EmptySTACK(); result = search_path((int**)maze, (int**)direction, 1, 1, 4, 4, 6, 6, st); return result; } 队列 队列和栈都是线性表结构 1. 队列的定义队列只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出（First In First Out）的线性表，简称FIFO，允许插入的一端称为队尾，允许删除的一端称为队头 队列中必须要有两个变量用于指明队列的队头位置和队尾位置，分别定义为 front 和 rear 2. 队列的操作对于顺序表的队列出队列：入队列： 可以看出在顺序队列中，即使执行出队列操作后，出队列元素所在的顺序表位置上的内存仍然没有被销毁，但是指明队列队头的变量front指向前一个位置。因为队头只能执行出队列的操作，队尾只能执行入队列的操作，如果一直执行出队列的操作的话，再执行入队列操作，那么就会出现==假溢出==的现象 所谓的假溢出就是：已经达到了front==rear的状态，再执行插入操作就会导致溢出，但是实际上front前面可能还有可用的存储空间，这种现象就叫做假溢出 那么该如何解决假溢出的问题呢？可以把顺序表在逻辑上看成一个圆环，这种队列也称为==循环队列==，循环队列的特点就是头尾相接的循环 循环队列为空时：有Queue-&gt;front == Queue-&gt;rear; 循环列表满时有：(Queue-&gt;rear+1)%Queue-&gt;MAXNUM == Queue-&gt;front; 循环队列中的元素个数判断： 3. 队列的声明1. 队列的顺序实现struct Queue { int front,rear; int MAXNUM; int* element; }; typedef struct Queue queue; queue* create_node(int num) { queue* qu; int temp[num]; qu = (queue*)malloc(sizeof(queue)); qu-&gt;front = 0; qu-&gt;rear = 0; qu-&gt;element = e; } 2. 队列的链式实现struct node { int data; struct node* next; }; typedef struct node* Node; struct Queue { Node front,rear; }; typedef struct Queue queue; queue* create_qu() { queue* qu; qu = (queue*)malloc(sizeof(queue)); qu-&gt;rear = NULL; qu-&gt;front = NULL; } 4. 队列的应用1. 农夫过河问题 上面的迷宫问题已经介绍过了深度优先搜索（DFS），而农夫过河问题就是一个典型的广度优先搜索（BFS）的问题 所谓的广度优先搜索就是：在搜索过程中，总是首先搜索下面一步的所有可能状态，然后再进一步考虑更后面的状态。由于队列的先进先出的特点，实现广度优先搜索一般使用队列作为辅助结构，先把每一步的下一步的所有可能达到的状态全部列举出来，放进队列中，然后按顺序取出来分别进行处理，在处理中又把再下一步的状态全部放在队列里，由于队列的先进先出的特点，所以，只有再前一步的所有状态都被处理完之后，才能开始处理后面的状态。 首先来描述一下农夫过河问题，农夫带着🐺、🐏和一颗白菜打算从河的一岸到达河的另一岸，但是农夫每次只能带着一样东西渡河，这就意味着起码会有两样东西会同时呆在一个岸上，总所周知，🐺会吃🐏，而🐏会吃白菜，那么就意味着🐺和🐏是不能同时呆在同一个岸上的，🐏和白菜也是不能同时呆在同一个岸上的 在计算机中只能接受数值型数据，因此要把实际物体进行数字表示。就用4位二进制数顺序分别表示农夫、🐺、白菜、🐏的位置，而0表示该物体在南岸，1表示该物体在北岸。根据题目的分析，很容易看出这是一个状态的表示问题，当🐺和🐏同时呆在同一个岸上的状态是不允许出现的。 首先要给出每个个体位置状态的判断函数 int farmer(int location) { return (0!=(location &amp; 0x08)); } int wolf(int location) { return (0!=(location &amp; 0x04)); } int cabbage(int location) { return (0!=(location &amp; 0x02)); } int goat(int location) { return (0!=(location &amp;0x01)); } 接着要进行判断两个状态是否安全 int main() { Queue* queue; int i,movers,location,newlocation; int route[16]; for(i = 0;i&lt;16;i++) { route[i] = -1; } queue = Create_Queue(); enQueue_seq(queue,0x00); route[0] = 0; while(!isEmptyQueue_seq(queue) &amp;&amp; (route[15]==-1)) { location = frontQueue_seq(queue); deQueue_seq(queue); for(movers = 1;movers&lt;=8;movers &lt;&lt;= 1) //考虑各种物体的移动 { if ((0 != (location &amp; 0x08)) == (0 != (location &amp; movers))) //农夫与移动的物体在同一岸上 { newlocation = location ^ (0x08 | movers); //计算新状态，用0x08是为了改变农夫的状态，农夫每次都得移动 if (safe(newlocation) &amp;&amp; (route[newlocation] == -1)) //判断新状态是否安全而且为未处理 { route[newlocation] = location; //记录新状态的前驱 enQueue_seq(queue, newlocation); } } } } if(route[15]!=-1) //判断是否到达最终状态 { printf(\"The reverse path is:\\n\"); for(location=15;location&gt;=0;location = route[location]) { printf(\"The location is:%d\\n\",location); if(location==0) exit(0); } } else{ printf(\"No solution.\\n\"); } } 以树形图来理解会比较好","categories":[{"name":"数据结构学习笔记","slug":"数据结构学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据结构—排序算法","slug":"数据结构—排序算法","date":"2022-09-09T07:13:37.269Z","updated":"2022-09-09T07:13:37.270Z","comments":true,"path":"2022/09/09/shu-ju-jie-gou-pai-xu-suan-fa/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-ju-jie-gou-pai-xu-suan-fa/","excerpt":"","text":"排序算法 排序是数据处理中经常使用的运算，高效地排序可以提高解决问题的速度 基本概念排序码： 待排序对象中的一个（或多个）字段，排序以排序码为依据。排序码可以不是关键码，可能有多个记录有相同的排序码，使得排序的结果不唯一，排序码之间要进行比较。 稳定性： 在待排序对象中，如果存在多个排序码相同的对象，经过排序之后，相同的排序码对象之间的相对次序如果保持不变，则这种排序方法是稳定的，否则是不稳定的 内排序： 待排序对象在排序过程中全部存放在内存的排序称为内排序 外排序 待排序对象在排序过程中全部放在外存的排序称为外排序 评价排序算法好坏的两个主要标准 （一般按照最坏情况或平均情况估算）： 执行算法所需的时间 执行算法所需要的附加空间 插入排序 基本思想：每步将一个待排序的对象，按照其排序码大小，插入到前面已排序的文件中的适当位置，直到全部插完为止 直接插入排序直接插入排序==必须采用顺序存储结构方式== void insert_sort(Data* d) { int i,j; int temp; int temp1; for(i=1;i&lt;d-&gt;Max;++i) //将数组中从第二个元素开始的元素依次插入前面已经排好序的元素里 { temp = d-&gt;data[i]; for(j=i-1;temp &lt; d-&gt;data[j] &amp;&amp; j&gt;=0;j--) //对插入的元素进行排序 { d-&gt;data[j+1] = d-&gt;data[j]; } if(j != i-1) { d-&gt;data[j+1] = temp; } } } input: 8 49 38 65 97 76 13 27 49 output: 13 27 38 49 49 65 76 97 直接排序过程如上图所示：将未排序的元素依次插入排好序的元素中，注意这是在一个数组中就能实现，不需要另外开一个数组来保存排好序的元素，只需要控制好数组下标就可以 直接插入排序对于不同排序对象的初态所耗费的时间有很大的差异，当对象为正序，则算法的时间复杂度为 $O(n)$ ，当对象为反序时，算法的时间复杂度为 $O(n^2)$ （具体可以证明，但我不懂证） 二分法插入排序由于直接插入排序中已经有一部分的元素是有序，而且是用数组来实现的，为了优化算法，很容易想到二分搜索的应用，二分法插入排序就是在直接插入排序的基础上，在将元素插入排好序的元素中时采用二分法找出插入位置 void bin_sort(Data* d) { int i,j,left,mid,right; int temp; int temp1; for(i = 1;i&lt;d-&gt;Max;i++) { temp = d-&gt;data[i]; left = 0; right = i-1; while(left &lt;= right)//找出插入位置 { mid = (left+right)/2; if(temp&lt;d-&gt;data[mid]) { right = mid - 1; } else{ left = mid + 1; } } for(j = i-1;j&gt;=left;j--)// 移动插入位置后面的元素 { d-&gt;data[j+1] = d-&gt;data[j]; } if(j != i-1) { d-&gt;data[j+1] = temp; } } } 表插入排序表插入排序必须采用链接存储方式 表插入排序的目标是在直接插入排序的基础上减少对象的移动次数，它的做法就是用链表将所有待排序对象连接起来，将元素插入排好序的元素中时，先将待插元素脱链，再采用顺序比较的方法找到插入位置，像单链表的插入那样将待插入元素插入链表 暂时没有代码 Shell排序（缩小增量法）它的做法是：先取一个整数 $d_1&lt;n$ ，把全部排序对象分成 $d_1$ 个组，所有距离为 $d_1$ 倍数的记录放在一组中，现在各组内排序；然后取 $d_2&lt;d_1$重复上述分组和排序工作；直到 $d_i==1$ ，即所有记录放在一组中为止。组内排序可以采用直接插入排序，也可以采用其他排序方法 Shell排序对直接插入排序的改进：直接插入排序在对象基本有序是，排序时间较少；而且当 $n$ 值较小时，$n$ 和 $n^2$ 的差别也较小。==Shell排序开始时增量较大，分组较多，每组的记录数目较少，因此在各组内采用直接插入排序较快，后面随着增量减小，分组数减少，各组的记录数增多，但是由于已经分组排序过了，文件接近于有序状态，所以新一躺排序过程也较快==增量 $d_i$ 有各种不同的取法，我们以 $d_1 = [\\frac{n}{2}]$，$d_{i+1}=[\\frac{d_i}{2}]$ 来实践Shell排序 void Shell_sort(Data* d,int t) { int i,j,inc; int temp; int temp1; for(inc = t; inc&gt;0; inc/=2) //增量的变化 { for(i=inc; i&lt;d-&gt;Max;i++) //从第一个增量组的位置开始向前迭代 { temp = d-&gt;data[i]; for(j = i-inc;j&gt;=0 &amp;&amp; temp&lt;d-&gt;data[j];j-=inc) //以当前位置j为基准，和它前面的相差inc增量的元素相比，将比 { d-&gt;data[j+inc] = d-&gt;data[j]; //将大数据往后移动 } d-&gt;data[j+inc] = temp; //插入待插入元素 } } } 注意到：Shell排序是一个不稳定的排序，因为它只有遇到比它大的才会停止将数据向后移动，尽管和它相等的也不行 选择排序 基本思想就是：每步从待排序对象中选出排序码最小的记录，顺序在已排序的对象序列后面，直到全部排完 直接选择排序它的做法是：先在所有未排序元素中找出排序码最小的元素，将其与第一个元素进行交换，然后在剩下的元素中再找到排序码最小的元素，与第二个交换，以此类推，直到所有记录排好序，总共需要排序n-1次，因为最后一个位置的元素不用排序 直接选择排序是不稳定的 void select_sort(Data* d) { int i,j,k; int temp; for(i=0;i&lt;d-&gt;Max-1;i++) { k = i; for(j = i+1;j&lt;d-&gt;Max;j++) { if(d-&gt;data[j]&lt;d-&gt;data[k]) { k = j; } } if(k != i) { temp = d-&gt;data[i]; d-&gt;data[i] = d-&gt;data[k]; d-&gt;data[k] = temp; } } } 堆排序 定义：一棵二叉树要么它是满二叉树，要么它是完全二叉树，且某个结点的值总是不大于或不小于其父结点的值，这样的二叉树称为堆 堆排序与直接选择排序的区别：直接选择排序n-1趟比较只是从排序码序列中选出了一个最小的排序码，并没有保存其他中间比较结果，因此在下一趟排序中又要重复很多比较操作 而堆排序的方法是将待排序对象构造成大根堆（或小根堆），通过不断从堆中选出最大元素，从而达到排序的目的 初始建堆问题：可以通过把待排序的文件中的记录逐个插入到空堆中来完成，这样需要另外开辟与原来对象同样大小的空间，为了节省空间，可以利用原始文件的空间，反复调用一个称为sift的函数，从后向前逐步把排序的记录调整为堆 void sift(Data* d,int size, int p) { int temp; temp = d-&gt;data[p]; //由于初始建堆是以完全二叉树的形式存储数据的，所以p代表该子树在完全二叉树中的位置，这步是取子堆顶的元素 int child = 2 * p + 1; while(child&lt;size) { if((child&lt;size-1)&amp;&amp;(d-&gt;data[child]&lt;d-&gt;data[child+1])) //遍历子堆中左右的孩子 { child++;//左孩子转换为右孩子 } if(temp&lt;d-&gt;data[child]) { d-&gt;data[p] = d-&gt;data[child]; //将大数据移动到堆顶 p = child; //继续判断以该孩子为堆顶的子堆是否满足大根堆的特点，不满足继续循环调整 child = 2 * p + 1; } else{ break; //最多遍历左右孩子说明该子堆的左右孩子都小于堆顶元素 } } d-&gt;data[p] = temp; } void heap_sort(Data* d) { int i,n; int temp; n = d-&gt;Max; for(i = n/2-1;i&gt;=0;i--) { sift(d,n,i); //建立初始堆 } for(i = n-1;i&gt;0;i--) //开始n-1趟堆排序 { temp = d-&gt;data[0]; //当前堆顶和堆中最大记录交换 d-&gt;data[0] = d-&gt;data[i]; d-&gt;data[i] = temp; sift(d,i,0); //重新调整建堆，注意i在控制调整范围中的作用 } } 交换排序 基本思想：将待排序对象两两比较，交换不满足顺序要求（从小到大，从大到小）的偶对，直到全部满足为止 冒泡排序void bubble_sort(Data* d) { int i; int j; int noswap; int temp; for(i = 0;i&lt;d-&gt;Max-1;i++) { noswap = 1; for(j = 0;j&lt;d-&gt;Max-i-1;j++) { if(d-&gt;data[j+1]&lt;d-&gt;data[j]) { temp = d-&gt;data[j]; d-&gt;data[j] = d-&gt;data[j+1]; d-&gt;data[j+1] = temp; noswap = 0; } } if(noswap) { break;//一趟下来已经没有排序了，则提前终止 } } } 这是一个优化过后的冒泡排序，，它设置了一个标志noswap表示本次冒泡是否有对象交换，要是没有就表示整个排序过程完成了 快速排序快速排序的思想是：分治法+挖坑填数基本思想是： 先从数列中取出一个数作为基准数。 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 再对左右区间重复第二步，直到各区间只有一个数。 以一个数组为例，取区间的第一个数为基数。 0 1 2 3 4 5 6 7 8 9 72 6 57 88 60 42 83 73 48 85 初始时，i=0，j=9，X=a[i]=72 由于已经将a[0]中的数保存到X中，可以理解为在数组a[0]上挖了个坑，可以将其他数据填充到这来 从j开始向前找一个比X小或等于X的数，当j=8时，符合条件，将a[8]挖出来再填到上一个坑a[0]中。即a[0]=a[8]；接着执行i++ 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，接下来要再找一个数来填充a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]；接着执行j– 数组变为： 0 1 2 3 4 5 6 7 8 9 ==48== 6 57 ==88== 60 42 83 73 ==88== 85 i=3；j=7；X=72 再重复上述的步骤，先从后向前找，在从前向后找。 从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]；i++； 从i开始向后找，当i=5时，由于i==j退出。 此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。 数组变为： 0 1 2 3 4 5 6 7 8 9 48 6 57 42 60 72 83 73 88 85 可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了 对挖坑填数进行总结： i =L; j = R; 将基准数挖出形成第一个坑a[i]。 j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。 i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。 再重复执行2，3二步，直到i==j，将基准数填入a[i]中。void quick_sort(Data *d,int l, int r) { int i, x, j; x = d-&gt;data[l]; i = l; j = r; int flag = 0; if (i &lt; j) { while (i != j) { while (d-&gt;data[j] &gt;= x &amp;&amp; flag == 0) { j--; if (i == j) { flag = 1; } } d-&gt;data[i] = d-&gt;data[j]; while (d-&gt;data[i] &lt;= x &amp;&amp; flag == 0) { i++; if (i == j) { flag = 1; } } d-&gt;data[j] = d-&gt;data[i]; } d-&gt;data[i] = x; quick_sort(d, l, i - 1); quick_sort(d, i + 1, r); } } 归并排序 基本思想：基于合并，将两个或两个以上有序表合并成一个新的有序表 二路归并排序它的思想就是：分治思想，假设初始序列含有n个记录，首先将这个n个记录看成n个有序子序列，每个序列的长度为1，然后两两归并，并得到n/2个长度为2的有序子序列，再对长度为2的有序子序列进行两两归并，如此重复，直到有序为止 用两个变量（或者可以称为指针）来指向两个比较段中的元素，通过移动两个指针来将两个比较段合并到一个段中 迭代法实现： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int min(int x,int y); void merge_sort(int arr[], int len); int main() { int arr[11]={7,1,9,8,5,4,3,2,0,6,10}; int len = 11; merge_sort(arr,len); } int min(int x,int y) { return x &lt; y ? x : y; } void merge_sort(int arr[], int len) //arr[]表示待排序的数组，len表示数组中的元素的个数 { int *a = arr; int *b = (int *)malloc(len * sizeof(int)); int seg, start; for(seg = 1;seg &lt; len;seg += seg) { for(start=0;start &lt; len;start += seg*2) { int low = start; int mid = min(start+seg, len); int high = min(start+seg*2,len); int k = low; int start1 = low,end1=mid; int start2 = mid,end2=high; while(start1&lt;end1 &amp;&amp; start2&lt;end2) //局部相邻两个段进行大小比较，小的在前面 { b[k++] = a[start1]&lt;a[start2]?a[start1++]:a[start2++]; //这样的写法太nice了吧 } //将没遍历过的元素直接放到结果后面 while(start1&lt;end1) { b[k++] = a[start1++]; } while(start2&lt;end2) { b[k++] = a[start2++]; } } //一定要记得交换，这一步是防止归并的时候因修改前面的值导致前面本应该到后面的值丢失 int *temp = a; a = b; //将下一个段区间循环中使用排序好的数组 b = temp; //其实这个步骤主要是找到排好最终结果的上一步的结果 } //说实话不知道下面一段是做什么的 // if (a != arr) // { // int i; // for (i = 0; i &lt; len; i++) // b[i] = a[i]; // b = a; // } // free(b); printf(\"Print result:\\n\"); for(int i=0;i&lt;len;i++) { printf(\"%d \",a[i]); } printf(\"\\n\"); printf(\"1900300221刘柏良\"); free(b); } 递归法实现： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void merge_sort_recursive(int arr[],int reg[], int start, int end); void merge_sort(int arr[], int len); int main() { int arr[11]={7,1,9,8,5,4,3,2,0,6,10}; int len = 11; merge_sort(arr,len); } void merge_sort_recursive(int arr[],int reg[], int start, int end) { if(start &gt;= end) { return ; } int len = end - start,mid = (len&gt;&gt;1) + start; int start1 = start,end1 = mid; int start2 = mid + 1,end2 = end; merge_sort_recursive(arr,reg,start1,end1); merge_sort_recursive(arr,reg,start2,end2); int k = start; while(start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) { reg[k++] = arr[start1] &lt; arr[start2]? arr[start1++]:arr[start2++]; } while(start1 &lt;= end1) { reg[k++] = arr[start1++]; } while(start2 &lt;= end2) { reg[k++] = arr[start2++]; } //依然不懂这一步是为什么 for(k = start;k&lt;=end;k++) { arr[k] = reg[k]; } } void merge_sort(int arr[], int len) { int reg[len]; merge_sort_recursive(arr,reg,0,len-1); printf(\"Print result:\\n\"); for(int i=0;i&lt;len;i++) { printf(\"%d \",arr[i]); } }","categories":[{"name":"数据结构学习笔记","slug":"数据结构学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据结构—图论","slug":"数据结构—图论","date":"2022-09-09T07:13:37.262Z","updated":"2022-09-09T07:13:37.262Z","comments":true,"path":"2022/09/09/shu-ju-jie-gou-tu-lun/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-ju-jie-gou-tu-lun/","excerpt":"","text":"图论中基本的概念完全图连通图强连通图弱连通图最小生成树最短路径图的表示方法邻接矩阵表示法邻接矩阵表示法是表示图中常使用的一种表示方法，它其实就是将一张图使用两个矩阵表示：一个是图中的顶点矩阵（一维数组，表示这个图中有多少个顶点），另一个则是关系矩阵（二维矩阵$n \\times n$，$n$表示顶点矩阵中顶点的个数），主要就是表示图中顶点与顶点之间的连通关系，就像两个顶点之间的距离，有距离也代表两个顶点是连通的 在C语言中一般通过结构体来表示出这种结构 #define VertexMax XXX typedef XXX VexType; typedef XXX AdjType; typedef struct { VexType Vertex[VertexMax]; AdjType AdjMatrix[VertexMax][VertexMax]; int vexnum,arcnum; }Graph; 邻接表表示法邻接表表示法包括两部分：顺序存储的顶点表和与每个顶点相关联的链式存储的边表 表示图如下： #define XXX VN struct EdgeNode; typedef XXX VexType; typedef XXX AdjType; typedef struct EdgeNode *PEdgeNode; typedef struct EdgeNode *EdgeList; struct EdgeNode{ int endvex; /*相邻顶点在顶点表的下标*/ AdjType weight; /*边的权，非带权图应该省略*/ PEdgeNode nextedge; /*链接字段*/ }; /*边表中的结点*/ typedef struct{ VexType vertex; /*顶点信息*/ EdgeList edgelist; /*边表头指针*/ }VexNode; /*顶点表中的结点*/ typedef struct{ VexNode vexs[VN]; /*顶点表*/ }GraphList; /*图的邻接表表示*/ 当邻接表表示有向图时，这时候有向图的邻接表的边表称为出边表。顶点 $v_i$ 的边表中结点的个数为顶点 $v_i$ 的出度，为了便于确定顶点的入度，有向图的边表也可以设计为入边表，其中每个结点对应一条以 $v_i$ 为终点的边 最小生成树的算法1. Prim算法1. 思想Prim算法主要是针对顶点来说，在图中顶点与顶点之间连接成线，而最小生成树的结果是包含所有顶点的，而且还要求这个子图是图的所有子图中总路径是最小的，因此可以看成是点与点之间的路径每次都选择最短的，抽象来看就是一个贪心问题 那么Prim算法既然是针对顶点来选择点与点之间的最小距离的，就要将顶点集分为已选点和未选点，需要说明的是已选点集中的点与点之间边都是选取最短的，而扩充已选点集的方法就是看已选点集和未选点集之间构成的边中最短的边对应的未选点集中的顶点，将其添加到已选点集中 在这个过程中要进行多少次循环呢？当然是$n-1$次了，选定一个顶点作为起点也就是已选点集，再从剩下的点中选择，在这个过程中只需要使用一个数组记录下每次选择的边，也就能知道这个最小生成树是如何生长的了，同样使用一个变量可以记录下这个树的总长 2. 代码实现#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define VertexMax 20 #define MaxInt 32767 typedef struct { char Vertex[VertexMax]; int AdjMatrix[VertexMax][VertexMax]; int vexnum,arcnum; }Graph; typedef struct { char adjvex; int lowcost; }ShortEdge; void CreateGraph(Graph *graph); int LocateVex(Graph *graph,char v); int Minimal(Graph *graph,ShortEdge *shortedge); void MiniSpanTree_Prim(Graph *graph, char startvex); void print(Graph graph); int main() { Graph graph; //graph = (Graph*)malloc(sizeof(Graph)); int vexnum; int arcnum; char start; char* result; printf(\"请输入顶点个数：\\n\"); scanf(\"%d\", &amp;vexnum); printf(\"请输入边的个数：\\n\"); scanf(\"%d\", &amp;arcnum); graph.vexnum = vexnum; graph.arcnum = arcnum; CreateGraph(&amp;graph); print(graph); printf(\"请输入开始顶点：\"); scanf(\" %c\",&amp;start); MiniSpanTree_Prim(&amp;graph,start); return 0; // printf(\"%d\\n\",graph-&gt;vexnum); // printf(\"%d\",graph-&gt;arcnum); } int LocateVex(Graph *graph,char v) { for(int i=0;i&lt;graph-&gt;vexnum;i++) { if(graph-&gt;Vertex[i] == v) { return i; } } } void CreateGraph(Graph *graph) { printf(\"请输入顶点集：\"); scanf(\" %s\",&amp;graph-&gt;Vertex); for(int i=0; i&lt;graph-&gt;vexnum; i++) { for(int j=0;j&lt;graph-&gt;vexnum;j++) { graph-&gt;AdjMatrix[i][j] = MaxInt; } } int n,m; char v1,v2; int w; for(int i=0;i&lt;graph-&gt;arcnum;i++) { printf(\"请输入起始点和终点和权值：\"); scanf(\" %c%c,%d\",&amp;v1,&amp;v2,&amp;w); n = LocateVex(graph,v1); m = LocateVex(graph,v2); if(n == -1 || m == -1) { printf(\"NO This Vertex!\\n\"); return ; } graph-&gt;AdjMatrix[n][m] = w; graph-&gt;AdjMatrix[m][n] = w; } } void print(Graph graph) { int i,j; printf(\"\\n-------------------------------\"); printf(\"\\n 邻接矩阵\\n\"); printf(\"\\t \"); for(i=0;i&lt;graph.vexnum;i++) printf(\"\\t%c\",graph.Vertex[i]); printf(\"\\n\"); for(i=0;i&lt;graph.vexnum;i++) { printf(\"\\t%c\",graph.Vertex[i]); for(j=0;j&lt;graph.vexnum;j++) { if(graph.AdjMatrix[i][j]==MaxInt) printf(\"\\t∞\"); else printf(\"\\t%d\",graph.AdjMatrix[i][j]); } printf(\"\\n\"); } } int Minimal(Graph *graph,ShortEdge *shortedge) { int min = MaxInt; int loc=-1; for(int i=0;i&lt;graph-&gt;vexnum;i++) { if(min &gt; shortedge[i].lowcost &amp;&amp; shortedge[i].lowcost!=0) { loc = i; min = shortedge[i].lowcost; } } return loc; } void MiniSpanTree_Prim(Graph *graph, char startvex) { char result[VertexMax] = {0}; result[0] = startvex; ShortEdge shortedge[VertexMax]; int k; k = LocateVex(graph,startvex); for(int i=0;i&lt;graph-&gt;vexnum;i++) { shortedge[i].adjvex = startvex; shortedge[i].lowcost = graph-&gt;AdjMatrix[k][i]; } shortedge[k].lowcost = 0; for(int i=0;i&lt;graph-&gt;vexnum-1;i++) { k = Minimal(graph,shortedge); printf(\"Choose %c\",graph-&gt;Vertex[k]); result[i+1] = graph-&gt;Vertex[k]; shortedge[k].lowcost = 0; //更新shortedge for(int j=0;j&lt;graph-&gt;vexnum;j++) { if(shortedge[j].lowcost&gt;graph-&gt;AdjMatrix[k][j]) { shortedge[j].lowcost = graph-&gt;AdjMatrix[k][j]; shortedge[j].adjvex = graph-&gt;Vertex[k]; } } printf(\"更新后的矩阵：\"); for(int k=0;k&lt;graph-&gt;vexnum;k++) { printf(\"%d \",shortedge[k].lowcost); } printf(\"\\n\"); } printf(\"路径为：%s\\n\",result); } 代码参考 2. Kruskal算法1. 思想Kruskal主要针对的是边，和Prim算法不同，Kruskal算法采用了边贪心的策略，思想要比prim算法简单，先将图中所有边从小到大排个序，从这些边中选择那些==不构成环==的最小边 同样这个算法也需要循环$n-1$次，因为最小生成树是连通的，$n-1$条边是构成一个连通图的必要条件，且最小生成树不能是环因此只能是$n-1$条边 2. 代码实现拓扑排序1. AOV网的概念==有向图==中，用顶点表示活动，边表示活动间的某种约束关系，这样的有向图称为顶点活动图（Activity On Vertex network，简称AOV网） 2. 拓扑排序对于一个AOV网，如果图中所有定点可以排成一个线性序列，并且该线性序列具有以下性质：在AOV网中，如果从顶点 $v_i$ 到顶点 $v_j$ 存在一条路径，则在线性序列中，顶点 $v_i$ 一定排在顶点 $v_j$ 之前。也可以理解为：每个结点代表一项工作，每条边表示完成该工作的需要完成的一些条件，整个AOV网看成一项工程，要完成这项工程需要遍历完所有的结点，那就需要找出一条能遍历完所有结点的路径，这条路径上结点序列排序就称为拓扑排序。 1. 排序思想任何无回路的AOV网，其结点都可以排成一个拓扑序列，构造拓扑序列（拓扑排序）的过程如下： 从AOV网中选择一个入度为0的顶点将其输出 在AOV网中删除此顶点及其所有的出边 反复执行上两步，直到所有顶点都输出为止，或者直到剩下的结点的入度都不为0为止，说明此时AOV网中存在回路，拓扑排序无法再进行 2. 存储结构AOV网采用邻接表表示，边表为出边表。此外还定义了一个indegree数组存放各顶点的入度；再利用indegree数组中的所有值为0的元素空间，构造一个链接表示的栈，所有进入该栈的元素均是入度为0的顶点， 3. 代码实现深度优先搜索算法代码实现 #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;list&gt; using namespace std; class Graph{ private: int V; /*vertex num*/ list&lt;int&gt;* adj; /*adjacency list*/ void DFSUtil(int v, bool *visited); public: Graph(int V); ~Graph(); void addEdge(int v, int w); void DFS(); }; Graph::Graph(int V) { this-&gt;V = V; /*构造函数*/ adj = new list&lt;int&gt; [V]; /*动态分配内存*/ } Graph::~Graph() { delete [] adj; /*析构函数，释放内存*/ adj =nullptr; } void Graph::addEdge(int v, int w) { adj[v].push_back(w); } void Graph::DFSUtil(int v, bool *visited) { visited[v] = true; cout &lt;&lt; v &lt;&lt; \" \"; for(auto it = adj[v].begin();it != adj[v].end();++it) { if(!visited[*it]) { DFSUtil(*it,visited); } } } void Graph::DFS() { bool* visited = new bool[V]; for(int i=0;i&lt;V;++i) { visited[i] = false; } for(int j=0;j&lt;V;++j) { if(!visited[j]) { DFSUtil(j,visited); } } } int main() { int V(5); Graph g(V); set&lt;int&gt; edgeInput[V]; edgeInput[0].insert({1,2}); edgeInput[1].insert({3,4}); for(int i=0;i&lt;V;++i) { for(auto it=edgeInput[i].begin();it!=edgeInput[i].end();++it) { g.addEdge(i,*it); } } cout&lt;&lt;\"DFS: \"&lt;&lt;endl; g.DFS(); cout&lt;&lt;\"1900300221刘柏良\"&lt;&lt;endl; return 0; } 利用深度优先搜索实现 #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; #define NIL -1 #define WHITE 0 #define GRAY 1 #define BLACK 2 #define INF 0x3f3f3f3f #define MAXN 101 int graph[MAXN][MAXN]; int dist[MAXN],f[MAXN]; int color[MAXN],pre[MAXN]; int N,time; struct str_node{ int id; int time; }node[10]; int cmp(const void *x, const void *y) { return (*(str_node*)x).time&gt;(*(str_node*)y).time?-1:1; } void DFSVisit(int u) { color[u] = GRAY; time = time+1; dist[u] = time; for(int i=0;i&lt;N;++i) { if(graph[u][i] != 0 &amp;&amp; color[i] == WHITE) { pre[i] = u; DFSVisit(i); } } color[u] = BLACK; time++; f[u] = time; } void DFS() { int i; for(i = 0;i&lt;N;++i) { color[i] = WHITE; pre[i] = NIL; } time = 0; for(i = 0;i&lt;N;++i) { if(color[i] == WHITE) { DFSVisit(i); } } } int main() { int i,j; ifstream infile(\"data.txt\"); if(infile.is_open()) { cout &lt;&lt; \"open file successful.\" &lt;&lt; endl; } else { cout &lt;&lt; \"open file error\" &lt;&lt; endl; return 0; } while (!infile.eof()) { infile &gt;&gt; N; for(i=0;i&lt;N;++i) { for(j=0;j&lt;N;++j) { infile &gt;&gt; graph[i][j]; } } DFS(); for(int i=0;i&lt;N;++i) { node[i].id = i; node[i].time = f[i]; } qsort(node,N,sizeof(node[0]),cmp); for(i=0;i&lt;N;++i) { cout &lt;&lt; node[i].id &lt;&lt; \" \"; } cout &lt;&lt; endl; } cout &lt;&lt; \"1900300221刘柏良\" &lt;&lt;endl; return 0; } 参考博客","categories":[{"name":"数据结构学习笔记","slug":"数据结构学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据结构—优先队列","slug":"数据结构—优先队列","date":"2022-09-09T07:13:37.254Z","updated":"2022-09-09T07:13:37.254Z","comments":true,"path":"2022/09/09/shu-ju-jie-gou-you-xian-dui-lie/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-ju-jie-gou-you-xian-dui-lie/","excerpt":"","text":"优先队列1. 定义队列的性质是：先进先出，而优先队列则不再遵循这个原则，优先队列分为两种情况： 最大优先队列，无论入队顺序，当前最大的元素优先出队。 最小优先队列，无论入队顺序，当前最小的元素优先出队。 比如有一个最大优先队列，它的最大元素是8，那么虽然元素8并不是队首元素，但出队的时候仍然让元素8首先出队： 要满足以上需求，利用线性数据结构并非不能实现，但是时间复杂度较高，最坏时间复杂度O（n），并不是最理想的方式。 那应该怎么办呢？这个时候就应该使用堆的结构特性 堆是用数组实现的二叉树，它的逻辑结构是二叉树，因为它一般是完全二叉树或者满二叉树，所以存储结构是数组，使用$2\\times i$表示左孩子和$2\\times i + 1$ 表示右孩子 优先队列的堆中的定义： typedef int ElementType; typedef struct Heap { int MaxNum; int HeapSize; ElementType *arr; }PriorityQueue; 优先队列是利用堆的性质实现的，分两种情况，大顶堆和小顶堆，最大（最小）的元素一定在队列的第一个位置，每次将队列中第一个元素提取出来，优先级都是最高的，所以每插入（删除）一个元素，都要调整堆。 2. 优先队列的操作 Extract-Max（pop） 出队，删除队列中优先级最高的元素，并调整优先队列 Increase-Key（Decrease_Key） 若元素提升（降低）之后符合堆的特性，将元素提升（降低）到相应位置 Insert（push） 向优先队列添加一个新的元素 3. 优先队列的应用1. 最小堆实现最小优先队列#ifndef CLIONPROJECT_FUNC_H #define CLIONPROJECT_FUNC_H typedef int ElementType; struct MinHeap; typedef struct MinHeap minHeap; void Initialize(minHeap *mh); void Sift(minHeap *mh, int MaxNum, int smallest); void BuildMinHeap(minHeap *mh); void HeapSort(minHeap *mh); void PrintMinHeap(minHeap *mh); int Get_Min(minHeap *mh); void Extract_Min(minHeap *mh); void Decrease_Key(minHeap *mh, int x, int k); void Insert(minHeap *mh, int k); #endif //CLIONPROJECT_FUNC_H #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include \"PriorityQueue.h\" struct MinHeap{ int MaxNum; int HeapSize; // int flag; ElementType *arr; }; typedef struct MinHeap minHeap; int main() { minHeap mh; Initialize(&amp;mh); PrintMinHeap(&amp;mh); BuildMinHeap(&amp;mh); PrintMinHeap(&amp;mh); printf(\"%d\\n\",Get_Min(&amp;mh)); Extract_Min(&amp;mh); PrintMinHeap(&amp;mh); Insert(&amp;mh,1); BuildMinHeap(&amp;mh); PrintMinHeap(&amp;mh); HeapSort(&amp;mh); PrintMinHeap(&amp;mh); return 0; } void Initialize(minHeap *mh) { int i; mh-&gt;MaxNum = 100; // mh-&gt;flag = mh-&gt;MaxNum; mh-&gt;arr = (ElementType*)malloc(sizeof(ElementType) * mh-&gt;MaxNum); printf(\"请输入10个数建立初始堆：\"); for(i=0;i&lt;10;i++) { scanf(\"%d\",&amp;mh-&gt;arr[i]); } mh-&gt;HeapSize = i; } void Sift(minHeap *mh, int MaxNum, int pos) { int temp = mh-&gt;arr[pos]; int child = pos * 2 + 1; while(child &lt; MaxNum) { if(child &lt; MaxNum-1 &amp;&amp; mh-&gt;arr[child]&gt;mh-&gt;arr[child+1]) { child++; } if(temp&gt;mh-&gt;arr[child]) { mh-&gt;arr[pos] = mh-&gt;arr[child]; pos = child; child = pos * 2 + 1; } else{ break; } } mh-&gt;arr[pos] = temp; } /*建立最小堆*/ void BuildMinHeap(minHeap *mh) { for(int i=mh-&gt;HeapSize/2-1;i&gt;=0;i--) { Sift(mh, mh-&gt;HeapSize, i); } } void HeapSort(minHeap *mh) { int temp; for(int i=mh-&gt;HeapSize-1;i&gt;0;i--) { temp = mh-&gt;arr[0]; mh-&gt;arr[0] = mh-&gt;arr[i]; mh-&gt;arr[i] = temp; Sift(mh,i,0); } } void PrintMinHeap(minHeap *mh) { for(int i=0;i&lt;mh-&gt;HeapSize;i++) { printf(\"%d \",*(mh-&gt;arr+i)); } printf(\"\\n\"); } int Get_Min(minHeap *mh) { return mh-&gt;arr[0]; } void Extract_Min(minHeap *mh) { int temp; temp = mh-&gt;arr[0]; mh-&gt;arr[0] = mh-&gt;arr[mh-&gt;HeapSize-1]; mh-&gt;arr[mh-&gt;HeapSize-1] = 0; // mh-&gt;arr[mh-&gt;flag-1] = temp; mh-&gt;HeapSize--; // mh-&gt;flag--; Sift(mh,mh-&gt;HeapSize,0); } void Decrease_Key(minHeap *mh, int i, int k) { if(k &gt; mh-&gt;arr[i]) { return ; } mh-&gt;arr[i-1] = k; Sift(mh,mh-&gt;HeapSize,i); } void Insert(minHeap *mh, int k) { mh-&gt;HeapSize++; mh-&gt;arr[mh-&gt;HeapSize] = 32767; Decrease_Key(mh,mh-&gt;HeapSize,k); } 参考博客 2. 最小优先队列实现Prim算法传统的Prim算法是每次都要将选中点的集合遍历一遍，再与集合外的元素判断是否相连，从中找出最小的权值，然后把带有最小权值的那个终点记录下来，插入到集合内。 每次遍历所有的选择点，这样会浪费很多时间，既然优先队列是用堆来实现，那么是否可以利用堆的特性，将之前遍历过的顶点而且不是最小权的那些边的权值存入优先队列中，下次再遍历的时候可以接着用。生成最小生成树时，只需要每次将队列头的元素出队即可 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define VertexMax 20 #define MaxInt 32767 typedef int ElementType; typedef struct { int start; int end; int weight; }Node; typedef struct { int MaxNum; int HeapSize; Node *arr; }PriorityQueue; typedef struct { int AdjMatrix[VertexMax][VertexMax]; int vexnum,arcnum; }Graph; void CreateGraph(Graph *graph); void print(Graph graph); int LocateVex(Graph *graph,int v); void Pq_push(PriorityQueue *pq, Node node); void Decrease_Key(PriorityQueue *pq, int x, Node k); void Insert(PriorityQueue *pq, Node k); void CreatePriorityQueue(PriorityQueue *pq); void Sift(PriorityQueue *pq, int MaxNum, int pos); void BuildMinHeap(PriorityQueue *pq); void PrintMinHeap(PriorityQueue *pq); void Prim(Graph *graph, PriorityQueue *pq, int start); int main() { Graph graph; PriorityQueue pq; printf(\"请输入顶点个数：\\n\"); scanf(\"%d\", &amp;graph.vexnum); printf(\"请输入边的个数：\\n\"); scanf(\"%d\", &amp;graph.arcnum); CreateGraph(&amp;graph); print(graph); CreatePriorityQueue(&amp;pq); Prim(&amp;graph,&amp;pq,0); PrintMinHeap(&amp;pq); return 0; } void CreateGraph(Graph *graph) { for(int i=0; i&lt;graph-&gt;vexnum; i++) { for(int j=0;j&lt;graph-&gt;vexnum;j++) { graph-&gt;AdjMatrix[i][j] = MaxInt; } } int v1,v2; int w; for(int i=0;i&lt;graph-&gt;arcnum;i++) { printf(\"请输入起始点和终点和权值：\"); scanf(\"%d %d %d\",&amp;v1,&amp;v2,&amp;w); if(v1 == -1 || v2 == -1) { printf(\"NO This Vertex!\\n\"); return ; } graph-&gt;AdjMatrix[v1-1][v2-1] = w; graph-&gt;AdjMatrix[v2-1][v1-1] = w; } } void print(Graph graph) { int i,j; printf(\"-------------------------------\"); printf(\"\\n 邻接矩阵\\n\"); printf(\"\\t \"); for(i=0;i&lt;graph.vexnum;i++) printf(\"\\t%d\",i+1); printf(\"\\n\"); for(i=0;i&lt;graph.vexnum;i++) { printf(\"\\t%d\",i+1); for(j=0;j&lt;graph.vexnum;j++) { if(graph.AdjMatrix[i][j]==MaxInt) printf(\"\\t∞\"); else printf(\"\\t%d\",graph.AdjMatrix[i][j]); } printf(\"\\n\"); } } void Pq_push(PriorityQueue *pq, Node node) { Insert(pq,node); BuildMinHeap(pq); return ; } void CreatePriorityQueue(PriorityQueue *pq) { int i; pq-&gt;MaxNum = 100; pq-&gt;arr = (Node*)malloc(sizeof(Node) * pq-&gt;MaxNum); pq-&gt;HeapSize = 0; } void Decrease_Key(PriorityQueue *pq, int i, Node k) { pq-&gt;arr[i-1] = k; Sift(pq,pq-&gt;HeapSize,i); } void Insert(PriorityQueue *pq, Node k) { pq-&gt;HeapSize++; Decrease_Key(pq,pq-&gt;HeapSize,k); } void Sift(PriorityQueue *pq, int MaxNum, int pos) { int temp = pq-&gt;arr[pos].weight; int child = pos * 2 + 1; while(child &lt; MaxNum) { if(child &lt; MaxNum-1 &amp;&amp; pq-&gt;arr[child].weight &gt; pq-&gt;arr[child+1].weight) { child++; } if(temp&gt;pq-&gt;arr[child].weight) { pq-&gt;arr[pos].weight = pq-&gt;arr[child].weight; pos = child; child = pos * 2 + 1; } else{ break; } } pq-&gt;arr[pos].weight = temp; } void Prim(Graph *graph, PriorityQueue *pq, int start) { Node node; int vis[graph-&gt;vexnum]; memset(vis,0,sizeof(vis)); vis[start] = 1; for(int i=0;i&lt;graph-&gt;vexnum;i++) { for(int j=0;j&lt;graph-&gt;vexnum;j++) { if(graph-&gt;AdjMatrix[start][j]!=MaxInt) { if(vis[j]!=0) { node.start = start; node.end = j; node.weight = graph-&gt;AdjMatrix[start][j]; Pq_push(pq,node); } } } } } void BuildMinHeap(PriorityQueue *pq) { for(int i=pq-&gt;HeapSize/2-1;i&gt;=0;i--) { Sift(pq, pq-&gt;HeapSize, i); } } void HeapSort(PriorityQueue *pq) { Node temp; for(int i=pq-&gt;HeapSize-1;i&gt;0;i--) { temp = pq-&gt;arr[0]; pq-&gt;arr[0] = pq-&gt;arr[i]; pq-&gt;arr[i] = temp; Sift(pq,i,0); } } void PrintMinHeap(PriorityQueue *pq) { for(int i=0;i&lt;pq-&gt;HeapSize;i++) { printf(\"%d \",pq-&gt;arr[i].weight); } printf(\"\\n\"); } 代码写不出来，这个代码有问题 参考博客","categories":[{"name":"数据结构学习笔记","slug":"数据结构学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据结构—二叉树","slug":"数据结构—二叉树","date":"2022-09-09T07:13:37.246Z","updated":"2022-09-09T07:13:37.246Z","comments":true,"path":"2022/09/09/shu-ju-jie-gou-er-cha-shu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-ju-jie-gou-er-cha-shu/","excerpt":"","text":"二叉树与树 树形结构是一种十分重要的数据结构，在树形结构中每个结点最多只有一个前驱，但可以有多个后继，树形结构表示了一种层次结构 1. 二叉树1. 基本概念 二叉树可以定义为结点的有限集合，这个集合或者为空集，或者由一个称为根的结点和两颗==不相交==的分别称为这个根的左子树和右子树的二叉树 由二叉树的定义可以知道二叉树可以递归定义：每个结点都有左右子树，可标识以这个结点为根的二叉树，所以二叉树类型和二叉树的中结点类型在编程时常常看成是同一种类型，因此在二叉树这递归使用的频率比较高 父结点、左（右）子结点、边 若 $x$ 是某二叉树的根结点，结点 $y$ 是 $x$ 的左（右）子树的根结点，则称 $x$ 是 $y$ 的父结点，$y$ 是 $x$ 的左（右）子结点，有序对 $&lt;x,y&gt;$ 称为从 $x$ 到 $y$ 的边 兄弟 具有同一父结点的结点彼此称做兄弟 祖先、子孙 若结点 $y$ 在以结点 $x$ 为根的左（右）子树中，且 $y\\neq x$ 则称 $x$ 是 $y$ 祖先，$y$ 是 $x$的子孙 路径、路径长度 假设 $x$ 是 $y$ 的一个祖先，如果存在一个二叉树中的结点序列 $x_0,x_1,x_2,\\cdots,x_n$，满足 $x=x_0,y=x_n$，并且每个 $x_i$ 为 $x_{i+1}$ 的父结点，称 $x_0,x_1,x_2,\\cdots,x_n$ 为从 $x$ 到 $y$ 的一条路径，$n$ 称为路径长度 结点的层数 规定根的层数为0，其余结点的层数等于其父结点的层数加1。 结点的度数 结点的子结点（即后缀）个数叫做结点的度数。 二叉树的高度 二叉树中结点的最大层数称为二叉树的高度 树叶、分支结点 左（右）子树均为空二叉树的结点称做树叶，否则称做分支结点 2. 特殊的二叉树 满二叉树如果一颗二叉树的任何结点或者是树叶，或有两颗非空子树，则此二叉树称做满二叉树（离散数学称之为是正则的） 完全二叉树如果一颗二叉树中，只有最下面的两层结点度数小于2，其余各层结点度数都等于2 扩充的二叉树 扩充的二叉树是对一个已有二叉树的扩充，扩充后原二叉树的结点都变为度数为2的分支结点。也就是说，如果原结点的度数为2，则不变；度数为1，则增加一个分支，度数为0（树叶），则增加两个分支（在程序输入树结构时会用到扩充二叉树的概念） 新增加的结点称为外部结点，树中原有的结点称为内部结点 为了讨论方便，把空二叉树的扩充二叉树规定为只有一个外部结点组成的二叉树 在扩充二叉树中，外部路径长度E定义为从根到每个外部结点的路径长度之和，内部路径长度I定义为从根到每个内部结点的路径长度之和 2. 主要性质1. 一般二叉树的性质 在非空二叉树的 $i$ 层上，至多有 $2^i$ 个结点（$i\\ge 0$） 高度为k的二叉树中，最多有$2^{k+1}-1$个结点 对于任何一颗非空的二叉树，如果叶结点个数为 $n_0$ ，度数为2的结点个数为 $n_2$，则有$n_0=n_2+1$ 2. 完全二叉树的性质 具有 $n$ 个结点的完全二叉树的高度 $k$ 为 $\\lfloor \\log _2^n\\rfloor$ 对于具有 $n$ 个结点的完全二叉树，如果按照从上（根节点）到下（叶结点）和从左到右的顺序对二叉树中的所有结点从0开始到 $n-1$ 进行编号，则对于任意的下标为 $i$ 的结点，有: (1) 如果 $i=0$，则它是根结点，它没有父结点，如果 $i&gt;0$ ，则它的父节点的下标为 $\\lfloor(i-1)/2\\rfloor$ (2) 如果 $2i+1\\leq n-1$，则下标为 $i$的节点的左子结点的下标为 $2i+1$，否则下标为 $i$ 的结点没有左子结点 (3) 如果 $2i+2\\leq n-1$，则下标为 $i$ 的结点的右子结点的下标为 $2i+2$，否则下标为 $i$ 的结点没有右结点 3. 满二叉树的性质在满二叉树中，叶结点的个数比分支结点个数多1 满二叉树的结点个数至少为2×树高-1 4. 扩充二叉树的性质 在扩充二叉树中，外部结点的个数比内部结点的个数多1 对任意扩充二叉树，外部路径长度$E$和内部路径长度$I$之间满足$E=I+2n$，其中 $n$ 是内部结点个数 3. 二叉树操作1. 创建二叉树struct node{ char info; struct node* lchild; struct node* rchild; }; typedef struct node* Node; Node Create_Binary_tree() { char c; Node T; scanf(\"%c\",&amp;c); if(c == '#') { T = NULL; } else{ T = (Node)malloc(sizeof(struct node)); T-&gt;info = c; T-&gt;lchild = Create_Binary_tree(); T-&gt;rchild = Create_Binary_tree(); } return T; } 2. 二叉树的周游 二叉树的周游是一种按某种方式系统地访问二叉树中所有结点的过程，使每个结点都被访问一次且只被访问一次 通过二叉树的定义，一颗二叉树可看做由三部分组成：根结点、根结点的左子树、根结点的右子树。因此，==只需依次周游这三部分，就可以周游整个二叉树==注意：二叉树是一种递归定义的结构，所以它的左、右子树还需递归的处理。 以上图为例1.先根次序（DLR）：先访问根，然后按先根次序 A,B,D,C,E,G,F,H,I 代码实现（递归） void inOrder(Node T) { if(T == NULL) { return ; } inOrder(T-&gt;lchild); printf(\"%c\",T-&gt;info); inOrder(T-&gt;rchild); } 2.后根次序（LRD）： D,B,G,E,H,I,F,C,A 代码实现（递归） void postOrder(Node T) { if(T == NULL) { return ; } postOrder(T-&gt;lchild); postOrder(T-&gt;rchild); printf(\"%c\",T-&gt;info); } 3.中根次序（LDR）： D,B,A,E,G,C,H,F,I 代码实现（递归） void inOrder(Node T) { if(T == NULL) { return ; } inOrder(T-&gt;lchild); printf(\"%c\",T-&gt;info); inOrder(T-&gt;rchild); } ==对于给定二叉树，可以唯一确定它的先根序列、后根序列和对称序列。但是反过来，给定一颗二叉树的任意一种周游的序列，无法唯一确定这颗二叉树。但是一般而言，如果已知一颗二叉树的中序对称序列，又知道另外一种周游序列，就可以唯一确定这颗二叉树。== 3. 非递归实现二叉树的周游 利用栈实现 1.先根次序 思路：从二叉树的根结点p开始，用一个指针指向p，访问p并将p压入栈中，接着该指针指向当前二叉树的左子树，若左子树不为空，则访问该指针指向的结点，并继续将该结点入栈，如此重复进行，直到该指针为空时，从栈中弹出栈顶元素并输出值，再用指针指向该元素的右子树，重复入栈过程，直到该指针为空且栈为空时，周游结束 另一种思路：把根结点压入栈中，当栈不为空时从栈顶中弹出元素，访问该结点，顺序将其右孩子结点和左孩子结点入栈，重复执行该操作，直到栈为空时，周游结束 2.中根次序 思路：若二叉树不为空，则沿其左子树前进，在前进过程中所经过的二叉树结点逐个压入栈中，当左子树为空时弹出栈顶元素，输出该结点的值并访问该二叉树的根，如果它有右子树，再进入当前二叉树的右子树，从头执行上述过程；如果它没有右子树，则弹出栈顶元素，从前面继续执行。直到当前二叉树为空并且栈也为空时，周游结束 3.后根次序 思路：在后跟次序周游的过程中，对一棵二叉树的根结点访问之前，要两次经过这颗二叉树：首先是由该二叉树找到其左子树，周游其左子树，周游完返回到这棵二叉树；然后是由该二叉树找到其右子树，周游其右子树，周游完再返回到这颗二叉树，这时才能访问该二叉树的根结点，因此一棵二叉树可能要进、出栈各两次，只有在它第二次出战之后才可以访问该二叉树的根结点。为了区分同一二叉树的两次出栈，需要给栈中二叉树增加一个标志量tag，tag=1表示该二叉树是第一次进栈，所以下次出栈不能访问该二叉树的根结点，tag=2表示该二叉树是第二次进栈，所以下次出栈应该访问该二叉树的根结点 4. 广度优先周游 A,B,C,D,E,F,G,H,I 广度优先周游一颗二叉树所得到的结点序列，叫做这颗二叉树的层次序列，在层次序列中，层数较低的结点总数排在层数较高的结点之前，同层结点的左右次序还保持不变。 5. 交换二叉树的左右子树Node swap(Node T) { if(T) { Node temp = T-&gt;lchild; T-&gt;lchild = T-&gt;rchild; T-&gt;rchild = temp; swap(T-&gt;lchild); swap(T-&gt;rchild); } return T; } 4. 哈夫曼树 这是一种特殊的二叉树，可以用于实现哈夫曼编码，哈夫曼树除了叶子结点外其余结点的度数（指孩子的个数）全部为2，则在已知孩子结点的前提下，哈夫曼树的空间大小也就确定了 1. 定义前面介绍了扩充二叉树及其外部路径长度，若用 $E$ 表示某扩充二叉树的外部路径长度，则有：$$E=\\sum^m_{i=1}l_i$$其中，$l_i$ 为从根到第 $i$ 个外部结点的路径长度，$m$ 为外部结点的个数 如果扩充二叉树中的外部结点都带有一定的权值，可将外部路径长度这一概念加以推广。设扩充二叉树具有 $m$ 个带权值的外部结点，那么从根结点到各个外部结点的路径长度与相应结点权值的乘积的和，叫做扩充二叉树的带权的外部路径长度，记作$$WPL=\\sum^m_{i=1}w_il_i$$其中，$w_i$是第 $i$ 个外部结点的权值 假设有一组（无序）实数${ w_1,w_2,w_3,\\cdots,w_m}$，现要构造一颗以$w_i\\left(i=1,2,3,\\cdots,m \\right)$为权的 $m$ 个外部结点的扩充二叉树，使得带权的外部路径长度$WPL$最小。满足这一要求的扩充二叉树就称为哈夫曼树或最优二叉树 2. 哈夫曼树的构造 要使$WPL$最小，必须使权值越大的外部结点离根越近，权值越小的离根越远 步骤: 由给定的 $m$ 个权值${ w_1,w_2,w_3,\\cdots,w_m}$，构造 $m$ 棵由空二叉树扩充得到的扩充二叉树${T_1,T_2,T_3,\\cdots,T_m}$。每个 $T_i\\left(1\\leq i \\leq m\\right)$只有一个外部结点（也是根节点），它的权值设置为 $w_i$ 在已经构造的所有的扩充二叉树中，选取根结点的权值最小和此最小的两颗，将它们作为左、右子树，构造成一颗新的扩充二叉树，它的根结点（新建立的内部结点）的权值置为其左、右子树根结点权值之和 重复执行步骤2，每次都使扩充二叉树的个数减少一，当只剩下一颗扩充二叉树时，它便是所要构造的哈夫曼树 得到 **动态创建哈夫曼树** struct HtNode{ int w; struct HtNode* llink; struct HtNode* rlink; }; typedef struct HtNode* Ht; Ht Create_HT(int* a,int n) { int j; Ht* b; Ht temp; b = (Ht*)malloc(sizeof(struct HtNode) * n); for(int i = 0;i &lt; n;i++) { b[i] = (Ht)malloc(sizeof(struct HtNode)); b[i]-&gt;w = a[i]; b[i]-&gt;llink = NULL; b[i]-&gt;rlink = NULL; } for(int i = 1;i &lt; n;i++) { int first = -1; int second; for(j = 0;j &lt; n;j++) { if(b[j] != NULL &amp;&amp; first == -1) //找到b中不为空的结点的第一个下标 { first = j; continue; } if(b[j] != NULL) //找到b中不为空的结点的第二个下标 { second = j; break; } } for(j = second;j &lt; n;j++) { if(b[j] != NULL) { if(b[j]-&gt;w &lt; b[first]-&gt;w) { //找到比b[first]-&gt;w还要小的权值的下标，然后将它赋值给first，而second就顶替原来first的位置 second = first; first = j; } else if(b[j]-&gt;w &lt; b[second]-&gt;w) { //会出现一种情况：b[j]-&gt;w的权值比b[first]-&gt;w的权值要大，但是比b[second]-&gt;w的权值要小，因此要做这一步判断 second = j; } } } temp = (Ht)malloc(sizeof(struct HtNode)); temp-&gt;w = b[first]-&gt;w + b[second]-&gt;w; temp-&gt;llink = b[first]; temp-&gt;rlink = b[second]; b[first] = temp; b[second] = NULL; } free(b); return temp; } int main() { int element[100]={0}; int e; int count=0; Ht result; scanf(\"%d\",&amp;e); while(e != 0) { element[count] = e; count++; scanf(\"%d\",&amp;e); } result = Create_HT(element,count+1); } 3. 哈夫曼树的应用 哈夫曼编码 哈夫曼树可以直接应用于通信及数据传送中的二进制编码 $d={d_1,d_2,\\cdots,d_n}$为需要编码的字符集合$w={w_1,w_2,\\cdots,w_n}$为 $d$ 中个字符出现的频率现要对 $d$ 中的字符进行二进制编码，使得： 按给出的编码进行传输文件时，通信编码总长最短；（为了保证传输速度） 若 $d_i\\neq d_j$，则 $d_i$ 的编码不可能是 $d_j$ 的编码的开始部分（前缀）；（为了保证传输的信息在译码时无二义性，所以在字符的编码中间不需要添加任意的分割符） 满足上述要求的二进制编码称为最优前缀编码 为了实现上述的目的，就可以利用到哈夫曼树来实现（哈夫曼编码过程）：用 $d_1,d_2,\\cdots,d_n$ 作为外部结点，用 $w_1,w_2,\\cdots,w_n$ 作为外部结点的权，构造哈夫曼树。在哈夫曼树中把每个结点引向其左子结点的边标上二进制数 ==”0”==，把从每个结点引向右子结点的边标上二进制数 ==”1”==，从根到每个叶结点的路径上的二进制数连接起来，就是这个叶结点所代表字符的最优前缀编码。也称这种编码为==哈夫曼编码== 哈夫曼编码解码的过程：只要从二叉树的根结点开始，用需要解码的二进制位串从头开始与二叉树根结点到子结点边上标的0、1相匹配，确定一条到达树叶结点的路径。一旦到达树叶结点，则译出一个字符。然后再回到根结点，从二进制位串中的下一位开始继续解码 二路归并排序 哈夫曼树也可以直接应用于二路归并排序以提高排序的效率 假设现在有 $n$ 个已经排序的文件 ${d_1,d_2,\\cdots,d_n}$，每个文件包含的记录个数对应为${w_1,w_2,\\cdots,w_n}$； 因此可以采用两两归并的方法，把所有文件的记录合到一个大文件中，使这个文件中的记录全部排序。==怎样的合并次序才能使得移动记录个数最少？== 当然是按照哈夫曼树的结构从外部结点到根结点逐层进行合并，一定是一种最佳的（但并非唯一的）合并顺序 树 二叉树是树的一个特例，树的一些基本概念包括周游方式与前面介绍的二叉树的基本概念和周游方式一样，下面补充一点： 树中度数最大的结点的度数叫做==树的度数== 对子树的次序不加区别的树叫做无序树，对子树之间的次序加以区别的树叫做有序树，对于有序树可以从左到右地规定结点的次序 以下图为例，按无序树的概念这两个树是相等的，但是按照有序树的概念，这两个树是不相等的 1. 树的表示方法 树的应用十分广泛，不同的应用可采用不同的表示方法，以提高运算效率。但无论采用何种存储表示，都要求存储结构不但能存储各结点本身的数据信息，还要把树中各结点之间存在的关系反映出来，下面介绍几种存储表示方法 1. 父指针表示法 结点的结构定义为：struct ParTreeNode { int info; int parent; }; 父指针表示法描述树的类型定义为：struct ParTree { int MAXNUM; int n; struct ParTreeNode* nodelist; }; 在树中除根之外的每个结点都有唯一的一个父结点，所以可以用一组连续的存储空间，即用一个数组存储树中的各个结点。数组中的一个元素为一个结构，其中包括结点本身的信息以及本结点的父结点在数组中的下标，树的这种存储方法称为 ==父指针表示法== 优点：这种存储方式中，求某结点的父结点及其所有祖先（包括根）的运算是很方便的 缺点：求结点的子结点和兄弟就需要查询整个数组，而且这种存储结构中没有表示出结点之间的左、右次序，所以无法求树中某个指定结点的 ==最左子结点== 和 ==右兄弟结点== 但在实际操作中，如果要找出一个结点的 ==最左子结点== 或者 ==右兄弟结点==，可以进行一些改进：按一种周游次序在数组中存放结点，比较常用的一种方法就是依次存放树结点的先根序列 这种方式就是将树中的结点按照某种周游次序排列成线性序列。结点在序列中的先后顺序在一定程度上反映了结点之间的关系，使专门用来表示结点之间关系的附加字段得到简化或省略，来节省了存储空间 从图中可以看出要找出当前结点的右兄弟结点就是要找出与该结点同一个父结点的结点，且找到的结点在数组中的位置要在当前结点位置之后，那就是该结点的右兄弟结点，若该树是一个有序树的话，右结点之间的次序也是可以通过在数组中的位置来表示出来 如果要找出当前结点的最左结点就是要找出以该结点为父结点的在数组中排在最前面的那个结点就是当前结点的最左父结点 2. 子表表示法 子表中每个结点的结构定义为：struct EdgeNode { int nodeposition; struct EdgeNode* link; }; 结点表中每个结点的结构定义为：struct ChiTreeNode { int info; struct EdgeNode* children; }; 子表表示的树结构定义为：struct ChiTree { int MAXNUM; int root; int n; struct ChiTreeNode* nodelist; }; 这种表示方法的做法就是把整棵树表示成一个结点表，而结点表中的每个元素又包含一个表，它记录了这个结点的所有子结点的位置，称为==子表==，结点表的长度即树中结点的个数，一般用一维数组顺序存储；而 ==子表的长度依赖各结点的度数== ，所以各不相同，一般用单链表表示；==子表中结点的链接顺序是按其在树中从左到右的次序进行的== 依然以上图为例，用子表表示法来表示它 优点：在这种表示方法中求某个结点的 ==最左子结点== 运算很容易实现，找到结点的 ==全部子结点== 也很容易 缺点：求某个结点的 ==父母和右兄弟== 实现起来比较费事，因为要找某结点的父结点，必须依次检查哪个结点的子表中是否包含该结点，而要找到某结点的右兄弟时，则首先要找到其父结点，然后再从父结点的子表中找寻它的右兄弟结点；合并若干个子树构成一个新树时也要考虑多个结点表的合并问题，由于这些结点表通常用顺序方式表示，所以合并起来比较麻烦 3. 长子-兄弟表示法这种表示方法是在树的每个结点中除其信息域外，再增加一个指向其最左子结点的指针域和一个指向其右兄弟的指针域 树中的结点的类型可以定义为：struct CSNode { int info; struct CSNode* lchild;//指向结点的最左孩子结点的指针 struct CSNode* rsibling;//指向结点的右兄弟的指针 }; 优点：在长子-兄弟表示法中，找结点的全部子结点很容易：先由lchild字段找到 ==长子（最左子结点）==，再由子结点的rsibling字段逐个地找子结点的 ==右兄弟== 缺点：寻找某个指定结点的 ==父结点== 比较麻烦，需要对树进行周游，周游时检查被访问的结点的各个子结点的位置是不是指定结点 树林 树林是由零个或多个不相交的树所组成的结合。前边所介绍的关于树的概念及术语对于树林基本都适用。下面补充一点： 树林中所有树也是有序的，彼此称为兄弟 树林可以是一个空集，也可以只由一棵树构成 如果从一棵树中删除根结点，就可以得到一个树林 1. 树林的周游 树林的周游方法有两种：先根次序和后根次序 1. 先根次序周游首先访问树林中第一棵树的根结点，然后先根次序周游第一棵树除去根结点剩下的所有子树构成的树林，最后先根次序周游除去第一棵树之后剩下的树林 ==也就是说，即使对于一个树林即使其中有不同的树，对树林的周游依然会遍历完所有的树，而不是单单只遍历其中的某棵树== 2. 后根次序周游首先后跟次序周游第一颗树的根结点的所有子树构成的树林，然后访问树林中第一棵树的根结点，最后后根次序周游除去第一棵树之后剩下的树林 2. 树林与二叉树的转换 树林（包括树）与二叉树之间有一个自然的一一对应的关系，也就是说，任何树林都唯一地对应到一颗二叉树；反过来，任何二叉树也都唯一地对应到一个树 由于树和二叉树的这种关系，常常将树转换为二叉树来处理，因此深入学习二叉树是非常有必要的 1. 树林转换为二叉树首先在所有相邻的兄弟结点之间加一条线（下图虚线）；然后对每个非终端结点，只保留它到其最左子结点的连线，删去它与其他子结点之间原有的连线；最后以根结点为轴心，将整棵树顺时针旋转一定角度，使其层次分明 如下图所示： 2. 二叉树转换为树林将二叉树转换成树或树林可以按以下步骤进行： 若某结点是其父母的左子结点，则把该结点的右子结点，右子结点的右子结点……都与该结点的父母用（虚）线连起来 去掉原二叉树中所有父母到右子结点的连线","categories":[{"name":"数据结构学习笔记","slug":"数据结构学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据结构—不相交集数据结构","slug":"数据结构—不相交集数据结构","date":"2022-09-09T07:13:37.239Z","updated":"2022-09-09T07:13:37.239Z","comments":true,"path":"2022/09/09/shu-ju-jie-gou-bu-xiang-jiao-ji-shu-ju-jie-gou/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-ju-jie-gou-bu-xiang-jiao-ji-shu-ju-jie-gou/","excerpt":"","text":"不相交集1. 基础概念在某些应用中，需要将n个不同的元素分成一组不相交的集合，而不相交集数据结构保持一组不相交的动态集合$S = { S_1,S_2, \\cdots S_k}$ 。 每个集合通过一个==代表==来识别，代表就是集合中的某个成员，哪个成员是代表，不是我们应该关注的，我们关注的是如果寻找某一动态集合的代表两次，并且两次寻找之间不修改集合，两次得到的答案应该是相同的。 2. 不相交集的操作 MAKE-SET（x）：建立一个新的集合，其唯一成员（因而其代表）就是x，要求x没有在其他集合中出现过 UNION（x，y）：将包含x和y的动态集合（$S_1$ 和 $S_2$）合并为一个新的集合 FIND-SET（x）：返回一个指针，指向包含x的（唯一）集合的代表 3. 不相交集的应用用于确定一个无向图中连通子图的个数 4. 不相交集的实现方式1. 基于链表的实现每个链表表示一个集合，其中表示集合S的链表包含一个头结点，其存储： S的大小 S的名字 指向链表的第一个和最后一个结点的指针 链表中的结点包含： 一个集合元素 一个指向链表中的下一个结点的指针 一个指回到头结点的指针 UNION（x，y）执行的操作一般为将包含代表x的集合的链表拼接到包含代表y的集合的链表的表尾，这就造成对于原来包含代表x的集合的链表需要修改指向代表的指针，使得时间复杂度达到了$O (n^2)$ 有一点绕 上面的复杂度可能是将较长的表拼接到较短的表上，而且还需要更新长链表指向代表的指针 为了优化时间复杂度，现在将每个链表（集合）中还包含表的长度，每次都将较短的链表拼接到较长的链表后面，相同长度的两个链表任意拼接，这就是==加权合并启发式策略== 这种做法使得时间复杂度变为 $O(m+n\\lg n)$ 2. 基于树的实现 每个结点都有一个指针，非根节点得之争指向它得父亲结点，根结点指向NULL，将用于命名子集名称得元素视为根，其余元素视为其后代，每个子集可用一棵根叔来表示 UNION（x，y）执行的操作是使得一棵树的根指向另一棵树的根，尽管采用这种直观的表示方法，但并不比采用链表表示的算法更快，还需要对算法进行改进 ==改进运行时间的启发式策略== 按秩合并 与用链表表示中的==加权合并启发式策略==相似（使较小秩的树的根指向较大秩的树的根） 区别在于：不显式记录以每个结点为根的子树的大小，而是对每个结点用秩表示结点高度的一个上街 路径压缩 使查找路径上的每个结点都直接指向根结点，路径压缩不改变结点的秩 查找路径：使用FIND-SET操作时，沿父结点指针一直找下去，直到找到树根为止，一路上经过的结点组成的路径就是查找路径 5. 不相交集的代码实现1. 基于链表实现参考","categories":[{"name":"数据结构学习笔记","slug":"数据结构学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据结构","slug":"数据结构","date":"2022-09-09T07:13:37.230Z","updated":"2022-09-09T07:13:37.231Z","comments":true,"path":"2022/09/09/shu-ju-jie-gou/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-ju-jie-gou/","excerpt":"","text":"数据结构与算法 用计算机实现问题求解，实质上就是在计算机中建立一个解决问题的模型。而==程序是使用程序设计语言精确描述的实现模型==，它是问题求解的一个可以在计算机上运行的模型。 一个程序的组成包括：数据，用来表示问题中涉及的对象；处理过程，表示对于数据的处理算法；还要有输入和输出 从问题到程序一般分为几个阶段： 分析阶段：首先要弄清楚用户的需求是什么，对用户的需求进行深入分析，利用数学符号或者流程图的形式给出用户需求的数学模型或者需求模型 设计阶段：给出计算机中的实现模型，重点是算法的设计和数据结构的设计，这一阶段一般而言需要经过多次的精化才能完成 编码阶段：通过一门计算机语言将实现模型在计算机中编写成可执行程序 调试和维护：在计算机得到产出（可执行程序）时，在投入使用之前需要调试这段程序，解决程序中的一些错误；即使在投入使用之后，还需要解决使用过程中的发现的隐含错误和根据使用中提出的需求进行必要的维护 抽象数据类型（ADT） 可以定义为==具有一定行为（操作）的抽象（数学）类型==。它不关心类型中值的具体表示方式和数据类型中定义的各种操作的具体实现方法，是所有可能的值的具体表示和各种操作的具体实现的抽象 数据类型不但包括这个类型的值的集合，还包括定义在这个类型上的一组操作，==数据类型即一种数据结构== 意义与作用抽象数据类型的实质是抽象出了数据类型的使用要求，而把它的具体表示方式和运算的实现细节都隐藏起来。 ==从使用者的观点来看，抽象数据类型仅仅规定了数据类型应该具有的行为（操作）== 抽象数据类型一旦被正确实现，就像程序设计语言中所提供的数据类型那样，可以被自由使用，问题求解的工作就可以在更加抽象的层次上进行，直接使用抽象数据类型提供的各种操作 例如圆的抽象数据类型： ADT Circle is operations area 计算圆的面积 getradius 获取圆的半径 end ADT Circle 理解：定义抽象数据类型就相当于定义了一类抽象出来的具有某些特性或运算的一些数据类型 抽象数据类型支持数据类型的实现和使用分离的原则，允许独立地考虑数据类型的外部接口和内部实现。 定义格式为： ADT抽象数据类型名 { 数据对象:&lt;数据对象的定义&gt; 数据关系:&lt;数据关系的定义&gt; 基本操作:&lt;基本操作的定义&gt; } 数据结构 计算机中表示（存储）的、具有一定逻辑关系和行为特征的一组数据，每个数据元素称为这个结构的一个节点，可以理解为==抽象数据类型的物理实现== “数据结构与算法”是一门研究数据的组织、存储、和运算的一般方法的课程 数据结构的三个要素： 逻辑结构：它定义了数学模型中的元素和元素之间的关系，例如：一对一，一对多，多对多等 存储结构：它给出了数学模型的具体表示方式包括节点的表示和关系的表示例如：链表，树形结构、图形结构等 操作：它给出抽象数据类型关心的各种行为在存储结构上的具体实现算法 注意：对于一种逻辑结构，往往存在多种存储结构，具体选择哪种，主要应该考虑操作的要求。==理解：也就是说，对于数据类型中的数据为顺序关系时，可以选择用链表来存储，也可以选择用树形结构来存储==","categories":[{"name":"数据结构学习笔记","slug":"数据结构学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据库SQL语句","slug":"数据库SQL语句","date":"2022-09-09T07:13:37.224Z","updated":"2022-09-09T07:13:37.224Z","comments":true,"path":"2022/09/09/shu-ju-ku-sql-yu-ju/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-ju-ku-sql-yu-ju/","excerpt":"","text":"opengauss中的一些快捷键在连接进入opengauss数据库之后你可以使用下面的一些快捷键来查看一些东西\\l：查看数据库管理系统中的数据库\\d：查看当前数据库中的表的信息\\c：切换到不同的数据库中\\c - username：切换用户\\h：查看opengauss所有支持的SQL语句\\q：退出数据库 基础操作上面这些信息从哪里来的？从\\?中来的，如果你想了解更多的快捷键的信息的话，你可以仔细阅读一下 创建模式create scheme 模式名 authorization 数据库用户名; 创建成功的话： create schema; 创建数据库create database 数据库名字; 创建表create table 表名( 属性1 数据类型(长度), 属性2 数据类型(长度), ...... ); 添加外码约束理论上来说在定义一张表的时候，定义外码的参照表可以是自身，但是opengauss不可以直接定义自身参照自身的表，那么只能通过==修改表==的形式来为表添加外码约束 alter table 参照表 add constraint 约束名 foreign key (参照表属性）references 被参照表 (被参照表属性); 删除外码约束alter table 表名 drop constraint 约束名; 修改数据库表名alter table 旧表名 rename 新表名; 删除表结构drop table 表名; drop虽然和delete一样是删除的意思，但是一个是删除表元组，一个是删除表结构 插入数据insert into 表名(选择表中的属性列) values(选取的属性列的值); 修改数据类型及长度在插入数据时，发现数据类型的长度不够了或数据类型不符合，这时候可以使用下面的语句来实现修改数据类型 alter table 表名 alter column 表中属性列 set data type 数据类型（长度）; 删除表中元组从指定表中删除满足条件的元组 delete from 表名 where 条件; 更新表中元组的值将表中满足条件的元组中的属性列重新赋值 update 表名 set 表中的属性1 = 值，表中的属性2 = 值,... where 条件; 选择表中属性相当于关系代数中的投影 select 属性组 from 表名; 高阶操作","categories":[{"name":"数据库学习笔记","slug":"数据库学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数学建模-插值算法","slug":"数学建模-插值算法","date":"2022-09-09T07:13:37.215Z","updated":"2022-09-09T07:13:37.216Z","comments":true,"path":"2022/09/09/shu-xue-jian-mo-cha-zhi-suan-fa/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-xue-jian-mo-cha-zhi-suan-fa/","excerpt":"","text":"插值算法 在进行数据分析时，如果此时已知的数据比较少，那么在对问题进行分析时，难免会分析得不全面，这时就需要使用一些数学的方法，“模拟产生”一些新的但又比较靠谱的值来满足需求，这就是插值的作用 在实际问题中，一个函数$\\boldsymbol{y=f(x)}$往往是通过实验观测得到的，仅已知函数$\\boldsymbol{f(x)}$在某区间$\\boldsymbol{\\left[ a,b \\right]}$上一系列点上的值$$\\boldsymbol{y_i=f(x_i),i=0,1,…,n}$$当需要在这些节点$\\boldsymbol{\\ x_0,x_1,…x_n\\ }$之间的点上的函数值时，常用较简单的、满足一定条件的函数$\\boldsymbol{\\ \\varphi(x_i)\\ }$去代替$\\boldsymbol{\\ f(x)\\ }$，插值法是一种常用方法，其插值函数$\\boldsymbol{\\ \\varphi(x_i)\\ }$满足条件$$\\boldsymbol{\\ \\varphi(x_i)=y_i,i=0,1,…,n}$$ 一般插值多项式定理设有n+1个互不相同的节点$\\boldsymbol{\\left(x_i,y_i\\right)\\ \\ \\left( i=0,1,2,….,n\\right)}$，则存在==唯一==的多项式：$$\\boldsymbol{L_n(x)=a_0+a_1x+a_2x^2+…+a_nx_n}$$使得$\\boldsymbol{L_n(x_j)=y_j \\ \\ (j=0,1,2,…,n)}$ 证明$$\\boldsymbol{\\left{\\begin{aligned} a_0+a_1x_0+a_2x_0^2+…+a_nx_0^n=y_0 &amp; \\ a_0+a_1x_1+a_2x_1^2+…+a_nx_1^n=y_1 &amp; \\ ……………………………………………..\\ a_0+a_1x_n+a_2x_n^2+…+a_nx_n^n=y_n &amp; \\\\end{aligned}\\right.}$$根据线性代数解矩阵方程组的知识$$\\begin{gathered}令：A=\\begin{bmatrix}1 &amp; x_0 &amp;…&amp; x_0^n\\1 &amp; x_1 &amp;…&amp; x_1^n\\… &amp; …&amp; … &amp;…\\1 &amp; x_n &amp; … &amp;x_n^n\\end{bmatrix}\\quadX=\\begin{bmatrix}a_0\\a_1\\…\\a_n\\end{bmatrix}\\quadY=\\begin{bmatrix}y_0\\y_1\\…\\y_n\\end{bmatrix}\\end{gathered}$$方程组的矩阵形式如下：$\\boldsymbol{AX=Y}$，$\\boldsymbol{A}$为范德蒙行列式由于$\\boldsymbol{\\left|A \\right|=\\prod^n_{i=1}\\prod^{n-1}_{j=0}(x_i-x_j)\\neq 0\\ }$所以方程组有唯一解从而$\\boldsymbol{L_n(x)=a_0+a_1x+a_2x^2+…+a_nx_n}$唯一存在 注意： 只要n+1个节点互异，满足上述插值条件的多项式是唯一存在的 如果不限制多项式的次数，插值多项式不唯一 拉格朗日插值多项式拉格朗日插值的基函数为：$$\\boldsymbol{l_i(x)=\\prod^n_{j=0,j\\neq i}\\frac{x-x_j}{x_i-x_j},i=0,1,…,n}$$$\\boldsymbol{l_i(x)}$是n次多项式，满足$$\\boldsymbol{l_i(x_j)=\\left{\\begin{array}{lr}0&amp;,&amp;j\\neq i\\1&amp;,&amp;j=i\\end{array}\\right.}$$拉格朗日插值函数$$\\boldsymbol{L_n(x)=\\sum^n_{i=0}y_il_i(x)=\\sum^n_{i=0}y_i\\prod^n_{j=0,j\\neq i}\\frac{x-x_j}{x_i-x_j}}$$当然，拉格朗日插值多项式存在一定的弊端，例如对于函数$f(x)=\\frac{1}{1+x^2},x\\in\\left[ -5,5\\right]$ ，对其使用拉格朗日插值多项式，得到的图像 不同次数的拉格朗日插值多项式的比较图 可以看出当拉格朗日插值多项式的自变量的绝对值逐渐变大时，开始出现波动，这就是高次插值产生的龙格现象，在两端产生明显的震荡。因此在不熟悉曲线运动趋势的前提下，不要轻易使用高次插值 插值多项式次数高精度未必显著提高，而且摄入误差可能显著增大（龙格现象），那么还有什么方法能较好地实现插值呢？分段线性插值是一个比较不错的解决方案 分段线性插值理论理解简单来说就是，将每两个相邻的节点用直线连起来，这样形成的一条折线就是分段线性插值函数，记作 $\\boldsymbol{I_n(x)}$ ,它满足 $\\boldsymbol{I_n(x)=y_i}$ ，且 $\\boldsymbol{I_n(x)}$ 在每个小区间 $\\boldsymbol{\\left[x_i,x_{i+1}\\right]\\left( i=0,1,…,n-1\\right)}$ 上都是线性函数 $\\boldsymbol{I_n(x)}$ 可以表示为$\\boldsymbol{I_n(x)=\\sum^n_{i=0}y_il_i(x)}$，其中$$l_i(x)= \\left{\\begin{aligned}\\frac{x-x_{i-1}}{x_i-x_{i-1}}&amp;,&amp;x\\in\\left[x_{i-1},x_i\\right],i\\neq0\\\\frac{x-x_{i+1}}{x_i-x_{i+1}}&amp;,&amp;x\\in\\left[ x_i,x_{i+1}\\right],i\\neq n\\0&amp;,&amp;其他\\end{aligned}\\right.$$下图为两个节点之间的插值计算展示： $\\boldsymbol{l_i(x)}$其实是一个权重函数，对于一个未知函数值的取值在 $\\boldsymbol{x_i}$ 和 $\\boldsymbol{x_{i+1}}$ 之间的点进行插值，根据 $\\boldsymbol{x}$ 到两端点的距离的程度来为两个分段函数加权 实用须知经过通分之后，就可以知道实际上分段线性插值就是两个端点连线的一次函数，在每两个节点之间的插值的计算公式为$$\\boldsymbol{y_i+(x-x_i)\\frac{y_{i+1}-y_i}{x_{i+1}-x_i}}$$ 下图为分段线性插值的拟合结果： python代码实现： def linear_interpolation_function(X_interval,Y_interval): \"This is original linear interpolation\" X_0 = X_interval[0] X_i = X_interval[-1] Y_0 = Y_interval[0] Y_i = Y_interval[1] Y_interval = Y_0 + ((X_interval[1:]-X_0)*((Y_i-Y_0)/(X_i-X_0))) interpolated_X = X_interval[1:] interpolated_Y = Y_interval return interpolated_X,interpolated_Y def linear_interpolation(X,Y,num): X_total = [] Y_total = [] \"accept the data of been interpolated\" for i in range(num-1): X_interval = X[i:i+2] Y_interval = Y[i:i+2] X_intervaled = np.arange(X_interval[0],X_interval[1],0.05) interpolated_X,interpolated_Y = linear_interpolation_function(X_intervaled,Y_interval) X_total.extend(list(np.insert(X_interval,1,interpolated_X))) Y_total.extend(list(np.insert(Y_interval,1, interpolated_Y))) \"use the function called extend to concat the interpolated data after the list\" return X_total,Y_total 分段二次插值选取跟节点 $x$ 最近的三个节点 $x_{i-1},x_i,x_{i+1}$ 进行二次插值，即在每一个区间$\\left[ x_{i-1},x_{i+1}\\right]$ ，取：$$\\boldsymbol{f(x)\\approx L_2(x)=\\sum_{k=i-1}^{i+1}\\left[ y_k\\prod^{i+1}_{k=i-1\\ ,\\ j\\neq k}\\frac{x-x_j}{x_k-x_j}\\right]}$$在几何上就是用分段抛物线代替 $y=f(x)$ ，故分段二次插值又称为分段抛物插值 全部代码 import numpy as np import matplotlib.pyplot as plt def raw_function(X): Y = np.sin(X) return Y def linear_interpolation_function(X_interval,Y_interval): \"This is original linear interpolation\" X_0 = X_interval[0] X_i = X_interval[-1] Y_0 = Y_interval[0] Y_i = Y_interval[1] Y_interval = Y_0 + ((X_interval[1:]-X_0)*((Y_i-Y_0)/(X_i-X_0))) interpolated_X = X_interval[1:] interpolated_Y = Y_interval return interpolated_X,interpolated_Y def Quadratic_linear_interpolation_function(X_interval,X_interval1,X_1,X_2,X_3,Y_1,Y_2,Y_3): \"This is quadratic linear interpolation\" result = Y_1*((X_interval-X_2)*(X_interval-X_3))/((X_1-X_2)*(X_1-X_3))+\\ Y_2*((X_interval - X_1)*(X_interval-X_3))/((X_2-X_1)*(X_2-X_3)) +\\ Y_3*((X_interval - X_1)*(X_interval-X_2))/((X_3-X_1)*(X_3-X_1)) result1 = Y_1*((X_interval1-X_2)*(X_interval1-X_3))/((X_1-X_2)*(X_1-X_3))+\\ Y_2*((X_interval1 - X_1)*(X_interval1-X_3))/((X_2-X_1)*(X_2-X_3)) +\\ Y_3*((X_interval1 - X_1)*(X_interval1-X_2))/((X_3-X_1)*(X_3-X_1)) print(X_interval,X_interval1) print(result,result1) return result,result1 def Quadratic_linear_interpolation(X,Y,num): for i in range(num-2): delta = 0.05 X_interval = np.arange(X[i]+delta,X[i+1]-delta,delta) X_interval1 = np.arange(X[i+1] + delta, X[i+2]-delta, delta) result,result1 = Quadratic_linear_interpolation_function(X_interval,X_interval1,X[i],X[i+1],X[i+2],Y[i],Y[i+1],Y[i+2]) def linear_interpolation(X,Y,num): X_total = [] Y_total = [] \"accept the data of been interpolated\" for i in range(num-1): X_interval = X[i:i+2] Y_interval = Y[i:i+2] X_intervaled = np.arange(X_interval[0],X_interval[1],0.05) interpolated_X,interpolated_Y = linear_interpolation_function(X_intervaled,Y_interval) X_total.extend(list(np.insert(X_interval,1,interpolated_X))) Y_total.extend(list(np.insert(Y_interval,1, interpolated_Y))) \"use the function called extend to concat the interpolated data after the list\" \"The function called np.insert is used to splicing two matrices\" return X_total,Y_total def plot(X,Y,X_1,Y_1): fig = plt.figure() ax = fig.add_subplot(111) ax.spines['top'].set_color('none') ax.spines['right'].set_color('none') ax.spines['bottom'].set_position(('data', 0)) ax.spines['left'].set_position(('data', 0)) ax.plot(X,Y,'r-',label='raw') ax.plot(X_1,Y_1,'b-',label='interpolated') plt.legend() plt.show() def main(): delta = 0.25 X = np.arange(-5, 5+delta, delta) Y = raw_function(X) num = len(Y) Quadratic_linear_interpolation(X,Y,num) #X_1,Y_1 = linear_interpolation(X,Y,num) #plot(X,Y,X_1,Y_1) if __name__ == '__main__': main() 牛顿插值法$$\\boldsymbol{f(x) = f(x_0)+f\\left| x_0,x_1\\right|(x-x_0)+ f\\left| x_0,x_1,x_2\\right|(x-x_0)(x-x_1)+\\cdots+f\\left| x_0,x_1,\\cdots,x_{n-1},x_{n}\\right|(x-x_0)(x-x_1)+\\cdots +(x-x_n-1)(x-x_n)}$$这是用到了差商的概念 差商定义：称 $\\boldsymbol{f\\left| x_0,x_k\\right|=\\frac{f(x_k)-f(x_0)}{x_k-x_0}}$为函数$\\boldsymbol{f(x)}$关于点$x_0,x_k$的一阶差商（也叫做均差）二阶差商：$$\\boldsymbol{f\\left| x_0,x_1,x_2\\right|=\\frac{f\\left| x_0,x_2\\right|-f\\left| x_0,x_1\\right|}{x_2-x_1}}$$k阶差商：$$\\boldsymbol{f\\left| x_0,x_1,\\cdots,x_k\\right|=\\frac{f\\left| x_1,\\cdots x_{k-1},x_k\\right|-f\\left| x_0,x_1,\\cdots,x_{k-1}\\right|}{x_k-x_0}}$$牛顿插值法和拉格朗日插值多项式的性质是相同的，都是用多项式的方式来近似，因此龙格现象并没有得到很好的解决，但是牛顿插值法的计算过程具有继承性，比较差商和拉格朗日插值的基函数的计算方法，就可以知道，牛顿插值法每次插值只和前n项的值有关，这样每次只要在原来的函数上添加新的项，就能产生新的函数。 除了龙格现象，这两种插值的方法还有一个缺点，那就是==不能全面反映被插值函数的性态==，在很多实际问题中，不仅要求插值函数与被插值函数在所有节点处又相同的函数值，它也==需要在一个或全部节点上插值多项式与被插函数有相同的低阶甚至高阶的导数值。== 那就要用到其他的插值方法，比如说：埃尔米特插值 埃尔米特插值法不但要求在节点上的函数值相等，而且还要求对应的导数值也相等，甚至要求高阶导数也相等，满足这种要求的插值多项式就是埃尔米特插值多项式 要满足$$\\boldsymbol{(1)\\varphi(x_i)=y_i}$$$$\\boldsymbol{(2)\\varphi’(x_i)=y_i’}$$保持插值曲线在节点处有切线（光滑），使插值函数和被插函数的密和程度更好 插值原理设在节点 $\\boldsymbol{a\\le x_0&lt;x_1&lt;\\cdots&lt;x_n\\le b}$ 上，$\\boldsymbol{y_j=f(x_j),m_j=f’(x_j)(j=0,1,\\cdots,n)}$，要求插值多项式$\\boldsymbol{H(x)}$，满足条件$$\\boldsymbol{H(x_j)=y_j,H’(x_j)=m_j(j=0,1,\\cdots,n)}$$这里给出了 $\\boldsymbol{2n+2}$ 个条件（也就是说有n+1个点，加上每个点的导数），可以唯一确定一个次数不超过 $\\boldsymbol{2n+1}$ 的多项式 $\\boldsymbol{H_{2n+1}(x)=a_0+a_1x+\\cdots+a_{2n+1}x^{2n+1}}$$\\boldsymbol{H(x)=H_{2n+1}(x)}$可以仿照拉格朗日插值多项式的基函数的方法，表示为$$\\boldsymbol{H_{2n+1}(x)=\\sum^n_{j=0}\\left[ y_j\\alpha_j(x)+m_j\\beta_j(x)\\right]}$$其中$$\\boldsymbol{\\alpha_j(x)=(ax+b)l_j^2(x)}$$$$\\boldsymbol{\\beta_j(x)=(x-x_j)l_j^2(x)}$$$$\\boldsymbol{l_j(x)=\\prod^n_{i=0,j\\neq i}\\frac{x-x_i}{x_j-x_i},j=0,1,…,n}$$而且 $\\boldsymbol{\\alpha_j(x) ，\\beta_j(x)}$ 要满足$$\\boldsymbol{\\alpha_j(x_i)=\\left{\\begin{array}{lr}0&amp;,&amp;j\\neq i\\1&amp;,&amp;j=i\\end{array}\\right.}$$$$\\boldsymbol{\\alpha’_j(x_i)=0}$$$$\\boldsymbol{\\beta_j(x_i)=0}$$$$\\boldsymbol{\\beta’_j(x_i)=\\left{\\begin{array}{lr}0&amp;,&amp;j\\neq i\\1&amp;,&amp;j=i\\end{array}\\right.}$$解得：$$\\boldsymbol{a = -2l’_j(x_j)\\ ,\\ b=1+2x_jl’j(x_j)}$$因为：$$\\boldsymbol{l’j(x_j)=\\sum^n{i=0,j\\neq i}\\frac{1}{x_j-x_i},i=0,1,…,n}$$所以：$$\\boldsymbol{\\alpha_j(x) = 1-2(x-x_j)\\sum^n{i=0\\ ,\\ i\\neq j}\\frac{1}{x_j-x_i}l_j^2(x)}$$$$\\boldsymbol{\\beta(x)=(x-x_j)l_j^2(x)}$$埃尔米特插值也难免会产生龙格现象，但是可以通过分段来减轻龙格现象，就像上面那幅图展示的，在自变量的绝对值相对没那么高的情况下，还是比较逼近原函数的。 分段三次埃尔米特插值分段三次埃尔米特插值相对于线性插值来说，插值函数在已知点处一阶导数值与原函数相等，使得插值函数曲线在已知点处函数曲线更平滑，而且它是使用了三次多项式作为每一个小段的插值多项式，相对于线性函数，三次函数更光滑 样条插值样条函数的概念样条本就是工程设计中使用的一种绘图工具，绘图员利用它把一些已知的点连接成一条光滑的曲线，并使在连接点处具有连续的曲率 数学上将具有一定光滑性的分段多项式称为样条函数，具体的说，给定区间$\\boldsymbol{\\left[ a,b\\right]}$的一个划分：$$\\boldsymbol{\\Delta:a=x_0&lt;x_1&lt;\\cdots&lt;x_{n-1}&lt;x_n=b}$$如果函数 $\\boldsymbol{s(x)}$ 满足： 在每个小区间 $\\boldsymbol{\\left x_i,x_{i+1}\\right}$ 上 $\\boldsymbol{s(x)}$ 是 $\\boldsymbol{m}$ 次多项式 $\\boldsymbol{s(x)}$ 在 $\\boldsymbol{\\left[ a,b\\right]}$ 上具有 $\\boldsymbol{m-1}$ 阶连续导数 则称 $\\boldsymbol{s(x)}$ 为关于划分$\\boldsymbol{\\Delta}$ 的 $\\boldsymbol{m}$ 次样条函数，其图形为 $\\boldsymbol{m}$ 次样条函数 三次样条插值已知函数 $\\boldsymbol{y=f(x)}$ 在区间 $\\boldsymbol{\\left[ a,b\\right]}$ 上的 $\\boldsymbol{n+1}$ 个节点，$$\\boldsymbol{a=x_0&lt;x_1&lt;\\cdots&lt;x_{n-1}&lt;x_n=b}$$上的值 $\\boldsymbol{y_i=f(x_i)(i=0,1,\\cdots,n)}$，求插值函数 $\\boldsymbol{s(x)}$ ，使得 $\\boldsymbol{s(x_i)=y_i\\ \\ (i=0,1,\\cdots,n)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (1)}$ 在每个小区间 $\\boldsymbol{\\left x_i,x_{i+1}\\right}$ 上 $\\boldsymbol{s(x)}$ 是三次多项式 $\\boldsymbol{s(x)}$ 在 $\\boldsymbol{\\left[ a,b\\right]}$ 上二阶连续可微 $\\boldsymbol{s(x)}$ 称为 $\\boldsymbol{f(x)}$的三次样条插值函数由条件2，不妨记：$$\\boldsymbol{S(x)=\\left|S_i(x),x\\in\\left( x_i,x_{i+1}\\right),i=0,1,\\cdots,n-1 \\right|}$$$$\\boldsymbol{S_i(x)=a_ix^3+b_ix^2+c_ix+d_i}$$ $\\boldsymbol{a_i,b_i,c_i,d_i}$ 为待定系数，共 $\\boldsymbol{4n}$ 个。由条件3$$\\left{\\begin{aligned}S_i(x_{i+1})=S_{i+1}(x_{i+1})\\S’i(x{i+1})=S’{i+1}(x{i+1})&amp; \\ ,\\ &amp;i=0,1,\\cdots,n-2\\ \\ \\ \\ \\ \\ \\ (2)\\S’’i(x{i+1})=S’’{i+1}(x{i+1})\\end{aligned}\\right.$$==理解：这一步需要建立自变量的运算矩阵，将其与系数矩阵进行矩阵的乘法，就可得到函数值矩阵。在已知函数值矩阵和自变量运算矩阵的前提下，就可以解出系数矩阵的值== 由$\\boldsymbol{(1),(2)}$式可知，共有 $\\boldsymbol{4n-2}$ 个方程，为确定 $\\boldsymbol{4n}$ 个待定系数，还需要$\\boldsymbol{2}$个条件。常用的三次样条函数的边界条件有$\\boldsymbol{3}$种类型： $\\boldsymbol{S’(a)=y’_0,S’(b)=y’_n}$特别地 $\\boldsymbol{y_0’=y’_n=0}$ ，样本曲线在端点处呈水平状态 $\\boldsymbol{S’’(a)=y’’_0,S’(b)=y’’_n}$特别地 $\\boldsymbol{y’’_0=y’’_n=0}$ ，称为自然边界条件 $\\boldsymbol{S’(a+0)=S’(b-0),S’’(a+0)=S’’(b-0)}$称为周期条件","categories":[{"name":"数学建模学习笔记","slug":"数学建模学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数学建模-层次分析法","slug":"数学建模-层次分析法","date":"2022-09-09T07:13:37.209Z","updated":"2022-09-09T07:13:37.209Z","comments":true,"path":"2022/09/09/shu-xue-jian-mo-ceng-ci-fen-xi-fa/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-xue-jian-mo-ceng-ci-fen-xi-fa/","excerpt":"","text":"层次分析法 评价类问题可用打分来解决，也就是说通过分数来量化一个评价指标，层次分析法就是一个量化指标的方法。 解决评价类问题的思路： 评价的目标是什么？ 达到这个目标有哪几种可选的方案？ 评价的准则或者说评价的指标是什么？ 一般来说，前两个问题的答案是根据数学建模题目可以判断出来的，但是第三个问题的答案就需要==根据题目中的背景材料、常识以及网上搜索到的参考资料进行结合，从中筛选出最合适的指标，就可以根据指标来对方案进行打分== 层次分析法的特点 层次分析法的主要特点是通过建立递阶层次结构，把人类的判断转化为若干因素两两之间重要度的比较上，从而把难于量化的定性判断转化为可操作的重要度的比较上面。在很对情况下，决策者可以直接使用层次分析法（AHP）进行决策，极大地提高了决策的有效性、可靠性和可行性，但本质是一种思维方式，它把复杂问题分解成多个组成因素，又将这些因素按支配关系分别形成递阶层次结构，通过两两比较的方法确定决策方案相对重要度的总排序。整个过程体现了人类决策思维的基本特征，即分解、判断、综合、克服了其他方法回避决策者主观判断的缺点 ### 基本概念 #### 重要性表 判断矩阵判断矩阵是层次分析法用来分析的一个方阵，方阵里的元素是评价指标之间两两比较得出的分值 为什么要引入判断矩阵呢？这是为了确定指标的权重，一次性考虑全部指标之间的关系，往往考虑不周，因此采用了分而治之的思想，对单个指标进行研究，在这个指标下对方案之间两两比较进行评分，最后计算出该指标的权重 判断矩阵的特点记方阵为A，对应的元素为$\\boldsymbol{a_{ij}}$ $\\boldsymbol{a_{ij}}$表示的意义是，与指标$\\boldsymbol{j}$相比，$\\boldsymbol{i}$的重要程度，重要程度由重要性表给出 当$\\boldsymbol{i}=\\boldsymbol{j}$时，两个指标相同，因此同等重要记为1，所以主对角线上的元素为1 $\\boldsymbol{a_{ij}&gt;0}$且满足$\\boldsymbol{a_{ij}\\times a_{ji}=1}$（满足正互反矩阵） 一致矩阵为什么要定义一致矩阵呢？这是为了要判断我们的判断矩阵是否是不一致的，也就是判断矩阵会出现一些逻辑上的错误，一致矩阵的目的就是用来检验判断矩阵中是否存在很大的逻辑错误，但在实际操作中，由于客观事物的复杂性以及人们对事物判断比较使得模糊性，很难构造出完全一致的判断矩阵，因此层次分析法中一致性检验时允许有一定不一致的范围 注意：所谓一致性检验就是判断矩阵之间的元素是否满足一种传递性，比如：a的重要性是b的2倍，b的重要性是c的2倍，则a的重要性是c的4倍，否则就是判断的不一致 一致矩阵的特点:各行（各列）之间成倍数关系$$\\boldsymbol{a_{ij}=\\frac{\\text{i的重要程度}}{\\text{j的重要程度}}}$$$$\\boldsymbol{a_{jk}=\\frac{\\text{j的重要程度}}{\\text{k的重要程度}}}$$$$\\boldsymbol{a_{ik}=\\frac{\\text{i的重要程度}}{\\text{k的重要程度}}=a_{ij}\\times a_{jk}}$$ 一致矩阵的引理： A为n阶方阵，且A的秩$\\boldsymbol{r(A)=1}$，则A有一个特征值为$\\boldsymbol{tr（A）}$，其余特征值均为0，当特征值为n时，对应的特征向量刚好为$\\boldsymbol{k[\\frac{1}{a_{11}},\\frac{1}{a_{12}}···\\frac{1}{a_{1n}}]^T(k\\ne 0)}$ n阶正互反矩阵A为一致矩阵时当且仅当最大特征值$\\boldsymbol{\\lambda_{max}=n}$，且当正互反矩阵A非一致时，一定满足$\\boldsymbol{\\lambda_{max}&gt;n}$ 一致性检验的步骤第一步：计算==一致性指标CI==$$\\boldsymbol{CI=\\frac{\\lambda_{max}-n}{n-1}}$$第二步：查找对应的==平均随机一致性指标RI==RI的值是这样得到的，用随机方法构造500个样本矩阵，随机地从1~9及其倒数中抽取数字构造正互反矩阵，求得最大特征根的平均值$\\boldsymbol{\\lambda’{max}}$$$\\boldsymbol{RI=\\frac{\\lambda’{max}-n}{n-1}}$$第三步：计算==一致性比例CR==$$\\boldsymbol{CR=\\frac{CI}{RI}}$$如果CR &lt; 0.1，则可认为判断矩阵的一致性可以接受，否则需要对判断矩阵进行修正（判断矩阵一般不会完全一致） 假如CR &gt; 0.1，此时应该对判断矩阵进行修正，往一致矩阵上调整，一致矩阵各行各列成比例 判断矩阵计算权重 一致矩阵因为各行和各列之间成比例，因此不需要每一行都计算出所占的权重，但是判断矩阵不同，判断矩阵不是每一行或每一列都成比例，因此在某些地方计算出来的权重是不相同的 算术平均法求权重 归一化处理权重：对每一行（列）的元素对该行（列）全部元素进行求和，该行对应的元素除以该行元素的总和就可以得出该元素（方案）的权重 将归一化后的各列相加（按行求和），将相加后得到的向量中的每个元素除以方案数n即可得到权重向量 数学表示：$$假设判断矩阵=\\left[\\begin{array}{ccc} a_{11} &amp; a_{12} &amp;… &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp;… &amp; a_{2n} \\ … &amp;… &amp;… &amp;…\\ a_{n1} &amp; a_{n2} &amp;… &amp; a_{nn}\\end{array}\\right]$$$$那么算术平均法求得的权重向量\\ \\omega_i=\\frac{1}{n}\\sum_{j=1}^n\\frac{a_{ij}}{\\sum_{k=1}^na_{kj}}(i=1,2,…,n)$$ 几何平均法 将矩阵A中的元素按照行相乘得到一个新的列向量 将新的向量的每个分量开n次方 对该列向量进行归一化处理即可得到权重向量$$假设判断矩阵A=\\left[\\begin{array}{ccc} a_{11} &amp; a_{12} &amp;… &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp;… &amp; a_{2n} \\ … &amp;… &amp;… &amp;…\\ a_{n1} &amp; a_{n2} &amp;… &amp; a_{nn}\\end{array}\\right]$$$$那么几何平均法求得的权重向量\\ \\omega_i=\\frac{(\\prod^n_{j=1}a_{ij})^{\\frac{1}{n}}}{\\sum^n_{k=1}(\\prod^n_{j=1}a_{kj})^{\\frac{1}{n}}}$$ 特征值法求权重由前面可知，一致矩阵有一个特征值为n，其余特征值为0，而且当特征值为n时，对应的特征向量刚好为$\\boldsymbol{k[\\frac{1}{a_{11}},\\frac{1}{a_{12}}···\\frac{1}{a_{1n}}]^T(k\\ne 0)}$，分析可知$\\boldsymbol{[\\frac{1}{a_{11}},\\frac{1}{a_{12}}···\\frac{1}{a_{1n}}]^T}$就是一致矩阵的第一列上的元素 假如判断矩阵的一致性可以接受，那么也可以仿照一致矩阵权重的求法 求出矩阵A的最大特征值以及其对应的特征向量 对求出的特征向量进行归一化处理即可得到权重 只有判断矩阵通过一致性检验才能使用 层次分析法的局限性 评价的决策层（方案层）不能太多，太多的话n会很大，判断矩阵和一致矩阵差异可能会很大平均随机一致性指标RI的表格中n最多是15 如果决策层中指标的数据是已知，再用层次分析法去主观给出判断矩阵显然是不合理的，那么我们该如何利用这些数据来世的评价更加准确呢？ 层次分析法的权重毕竟都是人为来评分的，主观性太强 层次分析法框架图 从上到下顺序地存在支配关系，并用直线段表示，除目标层外，每个元素至少受上一层一个元素支配，除最后一层外，每个元素至少支配下一层次一个元素，上下层元素的联系比同一层次强，以避免同一层次中不相邻元素存在支配关系； 整个结构中，层次数不受限制 最高层只有一个元素，每一个元素所支配的元素一般不超过9个，元素过多时可进一步分组。 由上图可以看到在准则层中，可以有不同的准则，以及准则之下还可以有子准则。 python实现AHPimport numpy as np class AHP: def __init__(self,array): self.array = array self.n = array.shape[0] RI_list = [0, 0, 0.58, 0.90, 1.12, 1.24, 1.32, 1.41, 1.45] self.RI = RI_list[self.n - 1] def get_eig(self): eig_val ,eig_vector = np.linalg.eig(self.array) \"\"\" The function called np.linalg.eig(array) is used to calculate singular value or right singular value of the array It return an array of eigenvalues and a feature vector \"\"\" max_val = np.max(eig_val) max_val = round(max_val.real,4) self.max_val = max_val \"\"\" get the largest eigenvalue The number of max_val maybe a plural so use \".real\" take the \"max_val\"'s real part The function called \"round\" is used to rounding \"\"\" index = np.argmax(eig_val) max_vector = eig_vector[:,index] max_vector = max_vector.real.round(4) \"\"\" get the feature vector that maximum eigenvalue corresponded through index of the maximum eigenvalue \"\"\" weight_vector = max_vector / sum(max_vector) weight_vector = weight_vector.round(4) print(\"最大特征值：\"+str(max_val)) print(\"对应的特征向量为：\"+str(max_vector)) print(\"归一化后得到的权重向量：\"+str(weight_vector)) return weight_vector def test_consitst(self): CI = (self.max_val - self.n)/(self.n-1) CI = round(CI, 4) print(\"判断矩阵的CI值为\"+str(CI)) print(\"判断矩阵的RI的值为\"+str(self.RI)) if self.n == 2: print(\"仅包含两个子因素，不存在一致性问题\") else: CR = CI / self.RI CR = round(CR,4) if CR &lt; 0.10: print(\"判断矩阵的CR值为：\"+str(CR)+\",通过一致性检验\") return True else: print(\"判断矩阵的CR值为\"+str(CR)+\"，未通过一致性检验\") return False","categories":[{"name":"数学建模学习笔记","slug":"数学建模学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数学建模-TOPSIS法","slug":"数学建模-TOPSIS法","date":"2022-09-09T07:13:37.200Z","updated":"2022-09-09T07:24:22.026Z","comments":true,"path":"2022/09/09/shu-xue-jian-mo-topsis-fa/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-xue-jian-mo-topsis-fa/","excerpt":"","text":"TOPSIS法（优劣解距离法） TOPSIS法是一种常用的综合评价方法，其能充分利用原始数据的信息，其结果能精确地反映各评价方案之间的差距，这种方法==通过构造评价问题的正理想解和负理想解，即各指标的最优解和最劣解，通过计算每个方案到理想方案的相对贴近度，即靠近正理想解和远离负理想解的程度，来对方案进行排序==，从而选出最优方案。 方法和原理设多属性决策方案集为$\\boldsymbol{D= {d_1,d_2,…,d_m } }$，衡量方案优劣的属性变量为$\\boldsymbol{ \\ x_1\\ ,\\ x_2\\ ,…\\ ,x_n }$，这时方案集$\\boldsymbol{ D }$中的每一个方案$\\boldsymbol{\\ d_i(i=1…m) }$的$\\boldsymbol{ n }$个属性值构成的向量是$\\boldsymbol{ { a_{ i1 },…,\\ a_{ in }} }$，它作为$\\boldsymbol{ n }$维空间中的一个点，能唯一表征方案$\\boldsymbol{ \\ d_i }$，这些方案的属性共同构成决策矩阵。 基本概念正理想解正理想解$\\boldsymbol{C^*}$是一个方案集$\\boldsymbol{D}$中不存在的虚拟的最佳方案，它的每个属性值都是决策矩阵中该属性值的最优解。负理想解负理想解$\\boldsymbol{C^0}$则是虚拟的最差方案，它的每个属性值都是决策矩阵中该属性的最差值。 方法在$\\boldsymbol{n}$维空间中，将方案集$\\boldsymbol{D}$中的各备选方案$\\boldsymbol{d_i}$与正理想解$\\boldsymbol{\\ C^*}$和负理想解$\\boldsymbol{\\ C^0}$的距离进行比较，既靠近正理想解又远离负理想解的方案就是方案集$\\boldsymbol{D}$中的最优方案；并可以据此来排定各备选方案的优先序。 原理用TOPSIS法求解多属性决策问题的概念简单，只要在属性空间==定义适当的距离测度==就能通过欧氏距离来计算备选方案与理想解的距离。即用正理想解，又用负理想解的原因是仅仅使用正理想解时有时会出现某两个备选方案与正理想解的距离相同的情况，为了区分这两个方案的优劣，引入负理想解，并计算这两个方案与负理想解的距离，与正理想解距离相同的方案离负理想解远的为优。 TOPSIS算法步骤 用向量规划化的方法求得规范决策矩阵。设多属性决策问题的决策矩阵$\\boldsymbol{A=(a_{ij}){m\\times n}}$，规范化决策矩阵$\\boldsymbol{B=(b{ij}){m\\times n}}$，其中$$\\boldsymbol{b{ij}=\\frac{a_{ij}}{\\sqrt{\\sum_{i=1}^ma_{ij}^2}}(i=1,2,…,m;j=1,2,…,n)}$$ 构成加权规范阵$\\boldsymbol{C=(c_{ij}){m\\times n}}$，设由决策人给定各属性的权重向量为$\\boldsymbol{w=[w_1,w_2,…,w_n]^T}$，则$$\\boldsymbol{c{ij}=w_j\\cdot b_{ij}(i=1,2,…,m;j=1,2,…,n)}$$ 确定正理想解的第$\\boldsymbol{j}$个属性$\\boldsymbol{C^*_j}$和负理想解的第$\\boldsymbol{j}$个属性$\\boldsymbol{C^0_j}$ 计算各方案到正理想解与负理想解的距离，备选方案$\\boldsymbol{d_i}$到正理想解的距离为$$\\boldsymbol{s^*i=\\sqrt{\\sum{j=1}^n(c_{ij}-c_j^*)^2},(i=1,2,…,m)}$$备选方案$\\boldsymbol{d_i}$到负理想解的距离为$$\\boldsymbol{s_i^0=\\sqrt{\\sum^n_{j=1}(c_{ij}-c_j^0)^2}(i=1,2,…,m)}$$ 计算各方案的排队指标值（即综合评价指标），即$$\\boldsymbol{f_i^*=\\frac{s_i^0}{s_i^0+s_i^*}}$$ 按$\\boldsymbol{f_i^*}$由大到小排列方案的优劣次序 属性值的规范化属性值规范化处理的目的在进行决策是，一般要进行属性值的规范化处理，主要有三个作用： 属性值有多种类型，不同类型类型的属性放在同一个表中不便于直接从数值大小判断方案的优劣，因此需要对数据进行预处理，使得表中任意属性下性能越优的方案变换后的属性值越大。 非量纲化，多属性决策方法与评估的困难之一是属性间的不可公度性，即在属性值表中的每一类数具有不同的量纲，在用各种多属性决策方法进行分析评价时，需要排除量纲的选用对决策或评估结果的影响，这就是非量纲化。 归一化，属性值表中不同指标的属性值的数值差别很大们为了直观，更为了便于采用各种多属性决策ui评估方法进行评价，需要把属性值表中数值归一化处理，即把表中数值均变换到$\\boldsymbol{[0,1]}$区间上。 属性值类型 属性值类型 类型特点 效益型 属性值越大越好 成本型 属性值越小越好 区间型 属性值在某个区间内最好 中间型 属性值在中间的时候最好 规范化处理方法1.线性变换原始的决策矩阵$\\boldsymbol{A=(a_{ij}){m\\times n}}$，变换后的决策矩阵$\\boldsymbol{B=(b{ij}){m\\times n}(i=1,…,m;j=1,…,n)}$设$\\boldsymbol{a_j^{max}}$是决策矩阵第$\\boldsymbol{j}$列中的最大值，$\\boldsymbol{a_j^{min}}$是决策矩阵第$\\boldsymbol{j}$列中的最小值，若$\\boldsymbol{x_j}$为效益性属性，则$$\\boldsymbol{b{ij}=\\frac{a_{ij}}{a_j^{max}}}$$此时最差属性值不一定为0，最优属性值为1若$\\boldsymbol{x_j}$为成本型属性，则$$\\boldsymbol{b_{ij}=1-\\frac{a_{ij}}{a_j^{max}}}$$ 2.标准0-1变换为了是每个属性变换后的最优解为1，且最差值为0，可以进行标准0-1变换。对效益性属性$\\boldsymbol{x_j}$，令$$\\boldsymbol{b_{ij}=\\frac{a_{ij}-a^{min}_j}{a_j^{max}-a^{min}j}}$$对成本型属性$\\boldsymbol{x_j}$，令$$\\boldsymbol{\\frac{a_j^{max}-a{ij}}{a_j^{max}-a_j^{min}}}$$ 3.区间型属性的变换设给定的最优属性区间为$\\boldsymbol{[a_J^0,a_j^*]}$，$\\boldsymbol{a’j}$为无法容忍下限，$\\boldsymbol{a’’j}$为无法容忍上限，则$$\\boldsymbol{b{ij}=\\left{\\begin{array}{l} 1-\\frac{(a_j^0-a{ij})}{a_j^0-a_j’}&amp;,&amp;a’j\\le a{ij} \\le a^0_j\\ 1&amp;,&amp;a_j^0\\le a_{ij}\\le a_j^\\ 1-\\frac{a_{ij}-a_j^}{a’’j-a_j^*}&amp;,&amp;a_j^*&lt;a{ij}\\le a’’j\\ 0&amp;,&amp;其他\\end{array}\\right.}$$变换后的属性值$\\boldsymbol{b{ij}}$与原属性值$\\boldsymbol{a_{ij}}$之间的函数图形为一般梯形，当属性值最有区间的上下限相等时，最优区间退化为一个点时，函数图形退化为三角形 4.向量规范化规范化后，各方案的同一属性值的平方和为1，常用于计算各种方案与某种虚拟方案的欧氏距离，一般要先将属性值正向化，即利用上面的变换来实现，正向化后再规范化就能直观从属性值上表示出各方案再某一属性下的情况 5. 标准化处理在实际问题中，不同变量的测量单位往往是不一样的。为了消除变量的量纲效应，使每个变量都具有同等的表现力，数据分析中常对数据进行标准化处理，即$$\\boldsymbol{b_{ij}=\\frac{a_{ij}-\\bar{a}j}{s_j},i=1,2…,m;j=1,2,…,n}$$其中：$\\boldsymbol{\\bar{a}j=\\frac{1}{m}\\sum^m{i=1}a{ij}\\ ,s_j=\\sqrt{\\frac{1}{m-1}\\sum^m_{i=1}(a_{ij}-\\bar{a})^2},j=1,2,…,n}$ 代码实现： import numpy as np import proces_data import math def create_array(dic,require,require1,require2):#,require3 array_of_A = [] name = [] for i in dic.items(): temp = [] temp.append(i[1][require]) temp.append(i[1][require1]) temp.append(i[1][require2]) #temp.append(i[1][require3]) array_of_A.append(temp) name.append(i[0]) array_of_A = np.array(array_of_A) return array_of_A,name def Normalzation(stand_of_b): molecular = stand_of_b Denominator = np.sum(np.square(stand_of_b),axis=0) normal_of_b = molecular / np.sqrt(Denominator) return normal_of_b def Entropy_method(array_of_a): a = array_of_a molecular = a - np.min(a,axis=0) Denominator = np.max(a,axis=0) - np.min(a,axis=0) Positive_index = molecular / Denominator p = Positive_index / np.sum(Positive_index,axis=0) k = (1 / math.log(len(a))) result = np.zeros(shape=p.shape) for i in range(len(p)): for j in range(len(p[i])): if p[i][j] == 0: result[i][j] = 0 else: result[i][j] = p[i][j] * math.log(p[i][j]) Entropy = - k * (np.sum(result,axis=0) ) diff_Enr = 1 - Entropy weight = diff_Enr / np.sum(diff_Enr) #weight = weight[np.newaxis,:] return weight def weighted_array(weight,array_of_n): return array_of_n * weight def calculate(weighted_array): max = np.max(weighted_array,axis=0) min = np.min(weighted_array,axis=0) molecular = np.sqrt(np.sum(np.square(weighted_array-min))) Denominator = molecular + np.sqrt(np.sum(np.square(weighted_array-max),axis=1)) result = molecular / Denominator return result","categories":[{"name":"数学建模学习笔记","slug":"数学建模学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"高等数学习题","slug":"高等数学习题","date":"2022-09-09T07:13:37.188Z","updated":"2022-09-09T07:13:37.188Z","comments":true,"path":"2022/09/09/gao-deng-shu-xue-xi-ti/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/gao-deng-shu-xue-xi-ti/","excerpt":"","text":"有理函数的不定积分要想办法拆分复杂的函数，将其化为简单的，能快速找到原函数的不定积分。 用硬凑的办法将复杂的函数拆分几个简单的函数的不定积分来求解 反三角函数的不定积分，用分部积分的方法，反三角函数在前 定积分在函数求解上的应用，这也说明了定积分求和的性质 利用定积分求导数的应用，定积分的值与积分限和函数表达式有关，与积分变量无关也可以用变限积分的求导公式 三角函数在微积分里如果是多次项，也要想办法将其拆分成简单可操作的，方便找到原函数。 利用夹逼准则求极限，类似放缩，此题修改一下可以变为定积分的问题 构造方法使其满足重要极限，注意：一定要满足重要极限的表达式，不要由式子直接推出满足重要极限的公式，此题就是一个例子 一阶线性微分方程，将一阶导数划到一边后，若另一边是x和y的混合分式，则可以考虑用齐次线性微分方程求解。 对于多项式分式的不定积分，一般采用硬凑的方法与分母相消，这里还应用了有理函数的不定积分 这里n是自变量，$x^n$是指数形式的函数，然而x的取值范围影响指数函数的取值，因此应先对指数函数中x的取值范围进行分类讨论。 等价无穷小实质上是泰勒展开式的前几项，也就是泰勒展开式的不精确计算，由于它的不精确性，等价无穷小的使用是有限制的，不能直接使用等价无穷小，求极限时的加减运算可能会导致项的消除以及合并，这样导致计算结果更加不精确，但是乘除中应用等价无穷小不会导致项的抵消。因此一般将等价无穷小的加减运算转化为乘除运算。 利用重要极限来求解，当${x \\to 0}$指数函数的值都为零，可以化为重要极限来求解。 这是一个验证夹逼准则的几何模型，对于求解一些数学关系问题，我们可以建立相应合理的数学模型来推导物体之间的数学关系 函数最值和介值的解题技巧 介值定理与零点定理的定义区间不一样,介值定理可以取到区间端点，零点定理不能取到区间端点，说明零点必须在区间内 闭区间上的连续函数一定能找到它的最大值和最小值，这里运用的手法是：已知一个函数不同自变量的函数值相加得到的常数，而这个函数一定有最小值和最大值，那么就可以得到一个常数值在这个函数的函数值之间这一个关系，接着结合微分中值定理中的罗尔定理就可以求出想要的结果。 考查函数有界性概念的理解 考查单调有界数列必有极限的定理如果一个数列是单调有界的，那么它的对应自变量也要是单调的，这是一种反推的必然结论 此题无法用等价代换来化简，可以考虑用求极限的定义的方法对该函数进行分区间来求各区间的极限来看是否相等，进而判断函数极限是否存在 此题在上面有相关的介绍 对于可化简为等级无穷小形式的函数，要尽量向等价无穷小靠近，但是还要满足乘除运算的等价无穷小才能等价代换。 泰勒公式在求极限方面的应用 可导一定连续，连续不一定可导，不连续一定不可导，不可导也可能连续。 (4),(5)考得比较多 第一条用得比较多 这是上面(4)的应用 cosh-1趋向于$0_-$,因此由求导的定义，可知这条式子只能判断函数在1处的左导数。 1-cosh趋向于$0_+$,只能判断函数在0处的右导数。 当一个分式的分母为0时，若想它的极限存在，分子也要为0，因为若分子不为零(可能为一个有限值或者是无穷大)，无论哪种情况，有限值除以无穷小是无穷大，无穷大除无穷小，也为无穷大。然而无穷大不能说明极限存在，这与题意不符合。 结合零点定理的微分中值定理问题的求解 定积分在函数多项式相加和求极限方面的应用 洛必达法则的局限性 铅直渐近线的判定步骤：1.先找出函数的间断点2.判断间断点处的函数的值是否为无穷大，满足条件则为铅直渐近线。 求铅直渐近线的例题 求斜渐近线的例题 函数定义域的两端点之间所连接成的直线于函数相交的点可以把定义域分为两部分，进而可以使用两次拉格朗日中值定理，再用罗尔定理 运用介值定理时要考虑在定义域的哪段区间内使用。在解微分中值的题目更要注意定义域上的区间划分。 微分中值定理的题型分组构造法需要结合多一个算子来实现所构造函数的导数，在(1)中这个算子是一个常数。","categories":[{"name":"数学学习笔记","slug":"数学学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数字电子技术基础大杂烩","slug":"数字电子技术基础大杂烩","date":"2022-09-09T07:13:37.177Z","updated":"2022-09-09T07:13:37.178Z","comments":true,"path":"2022/09/09/shu-zi-dian-zi-ji-zhu-ji-chu-da-za-hui/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-zi-dian-zi-ji-zhu-ji-chu-da-za-hui/","excerpt":"","text":"数字电子技术基础 菜鸡学数电，又菜又爱学 两个3线-8线译码器转变成一个4线-16线译码器首先让我们来看看3线-8线译码器（74HC138）这个小玩意长啥样 可以看出这个逻辑器件除了有三个输入端（A，B，C）之外，还有三个附加的控制端（E1，E2，E3）这三个控制端也被称为 “片选” 输入端，利用片选的作用将多片连接起来以扩展译码器的功能，要实现两个3线-8线译码器转换成一个4线-16线译码器就是要用到这些片选输入端 实现原理：由于3线-8线译码器要求 $\\text{E1=1}$，$\\text{E2’+E3’=0}$ 时，译码器处于工作的状态，否则译码器被禁止，所有的输出端被封锁在高电平 接下来看看两个3线-8线译码器实现的4线-16线译码器： 可以看出为了使单个3线-8线译码器能正常工作需要额外给那个控制端一个高电平，另外两个使能端子共同连接在最下面的输入端上，由最下面的输入端控制它的高低电平，==当最下面的输入端为0时表示上面那个3线-8线译码器工作，而下面的3线-8线译码器不工作；若最下面的输入端为1时，表示上面的3线-8线译码器不工作，而下面的3线-8线译码器工作== 需要注意的是：输入端的二进制编码的顺序应该从下往下看才能得到正确的二进制编码例如： 该图从上往下看是0010，对应的十进制数为2，但显示的结果却是4从下往上看是0100，对应的十进制数为4，显然是正确的译码结果，这就说明了输入端二进制编码顺序正确的排序应该是从下到上的数字 同理，利用片选控制端，我们还可以实现 两个4线-16线译码器转变成一个5线-32线译码器首先让我们看看4线-16线译码器的庐山真面目 在该译码器中规定两个片选控制端为低电平时，该译码器工作 于是，得出下图： 8选1数据选择器 数据选择器的作用就是从一组输入数据中选出某个来 不多说，先来看看8选1数据选择器（74HC151）长啥样先 根据前面的知识，可以知道片选端能将多个逻辑元器件进行级联；使能端也可以称为输入端，输入端的二进制编码和校验端进行校验，假设校验成功就输出1，否则输出0 在使用数据选择器进行分析或设计时，需要结合问题要求进行抽象表示，然后列出该问题的真值表，最后根据真值表求得逻辑函数逻辑函数的表示要结合检验端的使能端子一起分析，进而把各个检验端子所需连接的电位求出来 然后根据求得的电位来连接检验端的电位 4位数值比较器 数值比较器用来比较两个数据的大小，从最高位依次向下比较 给你们看个大宝贝 这就是4位的数值比较器（74HC85），是不是很可爱？ 输入端的$A&lt;B,A=B,A&gt;B$表示比较前的大小关系，而输出端的$A&lt;B,A=B,A&gt;B$则可以和其他的数值比较器进行级联从而得到不止四位数的比较 74LS192实现6进制加法计数 使用proteus验证电阻的伏安特性 （这其实是电路与电子技术基础方面的内容，这也让我感觉到了模拟电路与数字电路的区别：数字电路传授的是用逻辑元件组成逻辑电路来实现一些特定的功能，更偏向于理论上；而模拟电路传授的是怎样分析和设计电路） 要想使用好这个仿真软件，了解可以从哪里找到所需的电子元件是我们首先要掌握的，下面来介绍一下所用到的一些电子元件你可以在哪里找到吧 1.==电源器件（直流和交流）==电源在电路中的地位不需要多说，找到它是首位 直流电源在出现的对话框中，你可以直接搜索你想要的电子元件，直流电源一般有单电池（输入CELL可以找到）以及电池组（输入BATTERY可以找到） 单相交流电源在对话框中输入ALTERNATOR，你就可以获得一个史诗级装备，不需要充钱的为啥不要呢？ 2.==电阻== 电阻在软件中的关键字为：**Resistor**，电阻的种类有很多，但常用的电阻可直接输入**RES**就可以得到。 滑动变阻器的关键词为：POT-HG，这个滑动变阻器的好处就是可以直接用鼠标来改变触头位置，精确度和调整的最小单位为阻值的1% 3.==直流电压表（电流表）、交流电压表（电流表）==这些测量仪器对于电路分析的可视化起到十分重要的作用，那么在哪可以找到它们呢？看下面 直流电压表（电流表）直流电压表和直流电流表在上表中的关键词分别为：DC VOLTMETER，DC AMMETER 交流电压表（电流表）交流电压表和交流电流表在上表中的关键词分别为：AC VOLTMETER、AC AMMETER 以上就是所用到的电子元件，接下来直接看仿真出来的结果，由于电路简单就不继续分析了，主要就是要了解电子元件的出处 显然满足$\\text{I}=\\frac{U}{R}$的伏安特性 检测交变电流下的电阻、电容、电感的伏安特性首先要做的就是在软件中找到交变电流源，这个元器件在上面介绍交流电源时已经介绍过在哪可以找到了，接着要找到的是示波器 示波器和直流、交流电压表放在同一个地方，它的关键词为：OSCILLOSCOPE 程序运行起来时，示波器会出现一个界面类似下图： 示波器能完成四个通道的波形显示与测量，待测的四个输入信号分别于示波器的四个通道相接，信号的另一端应接地 出现的界面会显示四个通道的调整信息，以通道A为例，“Position”旋钮用来调整波形的==垂直位移==，下面的旋钮用来调整波形的==幅度显示比例==，外面黄色箭头是粗调，里面的黄色小箭头是细调，当读刻度时，应把里层的箭头顺时针调到最右端。四个通道的对应旋钮使用方法一样。在“Horizaintal”下方的两个旋钮分别用来调整波形的水平位移和扫描频率。其他旋钮可保持原位不动。 在运行过程中，如果关掉了示波器的界面，可以从主菜单的【Debug】中选取最下面的【Digital oscilloscope】来重现 然后要想测电子元器件，也需要找到这些元器件，电阻在哪在上面的学习中我们已经知道，接下来看看我们应该是去哪里找到电容和电感吧 电感电感的关键词为：INDUCTOR，在平常使用一般直接拾取这个元器件就可以，仿真结果如下： 电容电容分为：极性电容和非极性电容，常用的无极性电容的名称为：CAP，极性电容为：CAP-ELEC，仿真结果如下：","categories":[{"name":"数字电路学习笔记","slug":"数字电路学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"软链接和硬链接","slug":"软链接和硬链接","date":"2022-09-09T07:13:37.167Z","updated":"2022-09-09T07:13:37.167Z","comments":true,"path":"2022/09/09/ruan-lian-jie-he-ying-lian-jie/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/ruan-lian-jie-he-ying-lian-jie/","excerpt":"","text":"什么是软链接？什么是硬链接？链接简单说实际上是一种文件共享的方式，是POSIX中的概念，==主流文件系统都支持链接文件==。可以将链接简单地理解为 Windows 中常见的快捷方式（或是 OS X 中的替身），Linux 中常用它来解决一些库版本的问题，通常也会==将一些目录层次较深的文件链接到一个更易访问的目录中==。在这些用途上，我们通常会使用到软链接（也称符号链接）。 软链接和硬链接的区别是？参考博客","categories":[{"name":"操作系统学习笔记","slug":"操作系统学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"虚拟内存","slug":"虚拟内存","date":"2022-09-09T07:13:37.160Z","updated":"2022-09-09T07:13:37.161Z","comments":true,"path":"2022/09/09/xu-ni-nei-cun/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/xu-ni-nei-cun/","excerpt":"","text":"什么是虚拟内存参考资料","categories":[{"name":"操作系统学习笔记","slug":"操作系统学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"动态链接和静态链接","slug":"动态链接和静态链接","date":"2022-09-09T07:13:37.153Z","updated":"2022-09-09T07:13:37.154Z","comments":true,"path":"2022/09/09/dong-tai-lian-jie-he-jing-tai-lian-jie/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/dong-tai-lian-jie-he-jing-tai-lian-jie/","excerpt":"","text":"动态链接和静态链接 参考资料 (87条消息) 深入浅出静态链接和动态链接_kang___xi的博客-CSDN博客_静态链接和动态链接","categories":[{"name":"操作系统学习笔记","slug":"操作系统学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"内核态与用户态","slug":"内核态与用户态","date":"2022-09-09T07:13:37.148Z","updated":"2022-09-09T07:13:37.148Z","comments":true,"path":"2022/09/09/nei-he-tai-yu-yong-hu-tai/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/nei-he-tai-yu-yong-hu-tai/","excerpt":"","text":"内核态和用户态 首先一个操作系统分为两个运行空间：一个是用户空间，另一个是内核空间，用户空间里面运行的是用户代码，例如我们下载的各种应用程序，而内核空间里面放的内核代码，例如管理进程、内存、网络、文件系统等的代码，而一个程序运行时可能会跨越两个空间，因此内核态和用户态是对于程序当前运行的代码的状态而言的 1. 什么是内核态当程序当前执行的代码是位于内核空间的，则称程序此时处于内核态 2. 什么是用户态当程序当前执行的代码是位于用户空间的，则称程序此时处于用户态 3. 什么是内核？内核的作用是什么？ 还没搞懂","categories":[{"name":"操作系统学习笔记","slug":"操作系统学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"什么是句柄","slug":"什么是句柄","date":"2022-09-09T07:13:37.143Z","updated":"2022-09-09T07:13:37.143Z","comments":true,"path":"2022/09/09/shi-me-shi-ju-bing/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shi-me-shi-ju-bing/","excerpt":"","text":"什么叫句柄句柄（Handle）是一个是用来标识对象或者项目的标识符，可以用来描述窗体、文件等，值得注意的是句柄不能是常量 Windows之所以要设立句柄，根本上源于内存管理机制的问题，即虚拟地址。简而言之数据的地址需要变动，变动以后就需要有人来记录、管理变动，因此系统用句柄来记载数据地址的变更。在程序设计中，句柄是一种特殊的智能指针，当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄 句柄一般是指获取另一个对象的方法——一个广义的指针，它的具体形式可能是一个整数、一个对象或就是一个真实的指针，而它的目的就是建立起与被访问对象之间的唯一的联系，句柄（handle）是C++程序设计中经常提及的一个术语，在C++中，要访问一个对象，通常可以建立一个指向对象的指针。但是在很多具体的应用中，直接用指针代表对象并不是一个好的解决方案，因为可能会照常内存泄漏的风险 句柄在 Windows编程中是一个很重要的概念，在 Windows程序中并不是用物理地址来标识一个内存块、文件、任务或动态装入模块的。相反地，Windows API给这些项目分配确定的句柄，并将句柄返回给应用程序，然后通过句柄来进行操作。应该明白的是，句柄是一个标识符，是用来标识对象或者项目的。从数据类型上来看它只是一个16位的无符号整数。应用程序几乎总是通过调用一个Windows函数来获得一个句柄，之后其他的Windows函数就可以使用该句柄，以引用相应的对象。在 Windows编程中会用到大量的句柄 参考资料","categories":[{"name":"操作系统学习笔记","slug":"操作系统学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"win10重装系统","slug":"win10重装系统","date":"2022-09-09T07:13:37.136Z","updated":"2022-09-09T07:13:37.136Z","comments":true,"path":"2022/09/09/win10-chong-zhuang-xi-tong/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/win10-chong-zhuang-xi-tong/","excerpt":"","text":"重装系统首先准备一个大于8G的U盘，要确保这个U盘里的文件已经被备份了，因为接下来要格式化这个U盘，紧接着你需要一台可以上网的电脑。重装系统先要为电脑准备好所需要的系统，因此要到微软官方下载对应的系统版本，因为电脑买来时已经预装好了系统（一般是win10家庭版），电脑在第一次安装激活的时候一系列硬件信息被发送到微软的服务器中，下次激活的时候比对一下服务器里面的信息就可以，因此无需再花冤枉钱再去买个系统来激活，只要安装对应的版本就可以自动激活，在官网下载好对应的版本后，点击运行所下载好的文件，接着点击一系列接受条约 到了这一步：选择为另一台电脑创建安装介质 选择介质：U盘 选择U盘 接下来就是下载windows10系统以及创建介质的过程了，请耐心等待。等到所有过程结束，这个U盘算是准备好了，将准备好的U盘插进要重装系统的电脑，在开机出现品牌logo的时候按下对应键进入BIOS界面（不同的电脑进去该界面的按钮有可能不一样，我的是F12）在BIOS界面选择你的U盘，按下回车键就可以自动进入安装界面了，接着让你选择分区，要是有意识的想重装系统的话，可以事先把电脑里的个人文档、图片备份一下，重要的资料避免丢失，然后在磁盘分区时可以选择格式化一下你的磁盘，可以让你的电脑更加的干净健康，然后再选择一个磁盘将windows系统安装在那里（一般是选择C盘)，如果是迫不得已的重装系统，也可以选择不格式化C盘，将windows系统直接安装。这些工作做完后你就可以像刚刚买到电脑一样一步步去设置你的电脑。","categories":[{"name":"操作系统学习笔记","slug":"操作系统学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"什么是MCU","slug":"什么是MCU","date":"2022-09-09T07:13:37.130Z","updated":"2022-09-09T07:13:37.130Z","comments":true,"path":"2022/09/09/shi-me-shi-mcu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shi-me-shi-mcu/","excerpt":"","text":"什么是MCU参考资料","categories":[{"name":"嵌入式单片机学习笔记","slug":"嵌入式单片机学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"错误合集","slug":"[Jlink]错误合集","date":"2022-09-09T07:13:37.123Z","updated":"2022-09-09T07:13:37.123Z","comments":true,"path":"2022/09/09/jlink-cuo-wu-he-ji/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/jlink-cuo-wu-he-ji/","excerpt":"","text":"Jlink使用过程中遇到的问题","categories":[{"name":"嵌入式单片机学习笔记","slug":"嵌入式单片机学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Jlink","slug":"Jlink","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Jlink/"}]},{"title":"Airkiss原理","slug":"Airkiss原理","date":"2022-09-09T07:13:37.115Z","updated":"2022-09-09T07:13:37.117Z","comments":true,"path":"2022/09/09/airkiss-yuan-li/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/airkiss-yuan-li/","excerpt":"","text":"Airkiss配网技术","categories":[{"name":"嵌入式单片机学习笔记","slug":"嵌入式单片机学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"图像物体分类","slug":"图像物体分类","date":"2022-09-09T07:13:37.111Z","updated":"2022-09-09T07:13:37.111Z","comments":true,"path":"2022/09/09/tu-xiang-wu-ti-fen-lei/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/tu-xiang-wu-ti-fen-lei/","excerpt":"","text":"物体分类与检测的难点与挑战实例层次:针对单个物体实例而言，通常由于图像采集过程中光照条件、拍摄视角、距离的不同，物体自身的非刚体形变以及其他物体的部分遮挡使得物体实例的表观特征产生很大的变化，给视觉识别算法带来了极大的困难。类别层次1.类内差大，即属于同一类的物体表观特征差别比较大eg.不同的人在外观上存在各种各样的差异2.类间模糊性，即不同类的物体实例具有一定的相似性，两个不同的类间纯在某种相似的地方eg.西红柿与圣女果属于两个不同类别，但是无论它们在外观还是在味道都非常的相似3.背景的干扰eg.在恶劣环境下对图像的清晰度的影响语义层面语义困难的一个典型的问题：多重稳定性eg.由计算机图像处理出来的特征有可能被解释为其他的意思什么是图像特征对于图像而言，每一幅图像都具有能够区别于其他类图像的自身特征，如亮度，边缘，纹理和色彩等，有些则需要通过变换和处理才能得到。特征提取的一般原则选取的特征不仅要能够很好地描叙图像，还要能够很好地区分不同类别的图像，那些在同类图像之间差异较小(较小的类内距)，在不同类别的图像之间的类别差异较大的(较大的类间距)，我们称之为最具有区分能力的特征。1.特征应当容易提取2.选取的特征应对噪声和不相关转换不敏感，比如我们所需要检测的图像在不同角度的展示，不能影响我们关心的图像内容，因此就需要得到对几何失真变形等转换不敏感的描绘子，从而得到旋转不变，或是投影失真不变的特征3.总是应试图寻找最具区分能力的特征基本统计特征纹理是图像固有的特征之一，是灰度(对彩色图像而言是颜色)在空间以一定的形式变换而产生的图案(模式)，有时具有一定的周期性。纹理区域的像素灰度具有一定的形式，而直方图正是描述图像中像素灰度级分布的有力工具，因此可以用直方图来描述纹理。相似的纹理具有相似的直方图，直方图本身就是一个向量，向量的维数就是直方图统计的灰度级数，可以直接以此向量作为代表图像纹理的样本特征向量，从而交给分类器处理。还有一种方法就是进一步从直方图中提取出能够代够很好地描述直方图的统计特征，将这些统计特征组合成为样本特征向量，这样大大降低了特征向量的维数。应认识到直方图及其统计特征是一种区分能力相对较弱的特征，这主要因为直方图属于一阶统计特征，而它们的一阶统计特征是无法反映纹理结构的变化的。直方图与纹理的对应关系并不是一对一的：首先，不同的纹理可能具有相同或相似的直方图，其次，即便是两个不同的直方m.也可能具有相同的统计特 征如均值、标准差等。因此，依靠直方图及其统计特征来作为分类特征时需要特别注意。 灰度共现矩阵灰度直方图是一种描述单个像素灰度分布的一阶统计量，灰度共现矩阵共现矩阵描述的则是具有某种空间位置关系的两个像素的联合分布，可以看成是两个像素灰度对的联合直方图，是一种二阶统计量纹理是由灰度分布在空间位置上反复交替变化而形成的，因此在图像中具有某种空间位置关系的两个像素之间会存在一定的灰度关系，这种关系被称为图像灰度的空间相关特性。 特征降维维度灾难通常我们认为特征组合的向量维度越高，便能了解更多方面的属性，应该对提高识别率有利，然而事实并非如此。对于已知的样本数目，存在一个特征数目的最大值，当实际使用的特征数目超过这个最大值时，分类器的性能会退化，而且在高维特征中容易出现特征之间的线性相关，意味着有的特征是冗余的，因此我们可以采用特征降维，来降低样本的数目，通过选择好的特征，摒弃坏的特征，将有助于分类器的性能的提升，在低维空间中计算和分类都变得简单很多。特征降维一般有两种方法：特征抽取和特征选择特征选择：选择全部特征的一个子集作为特征向量特征抽取：是指通过已有特征的组合建立一个新的特征子集，主成分分析principal conponent analysis.PCA就是一种通过特征抽取来实现降维的方法，PCA的实质就是在尽可能好地代表原始数据的前提下，通过线性变换将高维空间的样本数据投影到低维空间中。奇异值分解(SVD算法)特征值和矩阵，以及特征向量之间的关系：根据，可以将矩阵的特征值提取出来，这种方法对于矩阵的局限性较大，要求矩阵必须是方阵对于非方阵的矩阵，我们可以将它的奇异值分解，公式为：在这里U是m×m的矩阵，Σ是m×n的矩阵（除对角线上的值，其余的值全为0），V是n×n的矩阵。在这里矩阵U和V都是酉矩阵，也就是说满足UTU=I，VTV=I（其中I为单位矩阵）。对于SVD的定义如下图","categories":[{"name":"图像处理学习笔记","slug":"图像处理学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"图像滤波去噪","slug":"图像滤波去噪","date":"2022-09-09T07:13:37.104Z","updated":"2022-09-09T07:13:37.104Z","comments":true,"path":"2022/09/09/tu-xiang-lu-bo-qu-zao/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/tu-xiang-lu-bo-qu-zao/","excerpt":"","text":"####图像去噪#####噪声类型图像噪声主要有加性噪声，乘性噪声，加性噪声包括高斯噪声，椒盐噪声等典型噪声。椒盐噪声椒盐噪声是由图像传感器，传输信道，解码处理等产生的亮暗点噪声，所谓椒盐，椒就是黑，盐就是白，椒盐噪声就是图像上随机出现的黑色白色的像素#####图像去噪技术什么是滤波？即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，消除图像中噪声成分叫做图像的平滑化或滤波操作。平滑处理的目的一是抽象出对象特征作为图像识别的特征模式，另一个是为适应图像处理的要求，消除图像混入的噪声。滤波处理的要求一是不能损坏图像的轮廓及边缘等重要信息二是使图像清晰视觉效果好我们使用信噪比(Signal NoiseRate)来衡量图像噪声，图像的信噪比应该等于信号与噪声的功率谱之比，通常功率谱难以计算，有一种方法可以近似图像信噪比，即信号与噪声的方差之比(其实在均值为零的情况下，功率就是方差)先计算图像所有像素的局部方差，取局部方差的最大值作为信号方差，最小值为噪声方差，求出它们的比值，再转成DB数，最后用经验公式修正。线性滤波与非线性滤波线性滤波器的原始数据与滤波结果是一种算术运算，即用加减乘除等运算来实现，线性滤波器是算术运算，有固定的模板，因此滤波器的转移函数可以是确定并且是唯一的(转移函数即模板的傅里叶变换)非线性变换的原始数据与滤波结果是一种逻辑关系，即用逻辑运算实现，如最大值滤波器，中值滤波器等，是通过比较一定邻域内灰度值大小来实现的，没有固定的模板，因而也没有特定的转移函数(因为没有模板做傅里叶变换)，膨胀和腐蚀也是通过最大值，最小值滤波器来实现的。1.空间域方法主要采用各种图像平滑模板对图像进行卷积处理，以达到压抑或消除噪声的目的2.频率域方法主要通过对图像进行变换后，选用适当频率带通滤波器进行滤波处理，经反变换后获得去噪声图像均值滤波基本思想：几个像素灰度的平均值来代替每个像素的灰度。中值滤波值中值滤波是一种非线性信号处理方法基本原理：把数字图像或数字序列中的一点的值用该点的一个领域中的各点值的中值代替。中值滤波就是用一个活动窗口沿图像移动，窗口中心位置的像素灰度用窗口内所有像素灰度的中值来代替。对于一副图象的像素矩阵，取以目标像素为中心的一个子矩阵窗口，这个窗口可根据需要选取，窗口的形状常用有方形，十字形，和圆形。对窗口内的像素灰度排序，取中间一个值作为目标像素的新像素灰度，让周围像素灰度值的差比较大的像素改取与周围的像素值接近的值，从而可以消除孤立的噪声点。利用中值滤波算法可以很好地对图像进行平滑处理。这种算法简单，时间复杂度低，但其对点、线和尖顶多的图像不宜采用中值滤波。很容易自适应化。 小波变换小波变换是一种窗口大小固定但其形状可改变的时频局部化分析方法。小波变换利用的非均匀的分辨率，即在低频段用高的频率分辨率和低的时间分辨率（宽的分析窗口）：而在高频段利用低的频率分辨率和高的时间分辨率（窄的分析窗口），这样就能有效地从信号（如语言，图像等）中提取信息，较好地解决了时间和频率分辨率的矛盾。一个图像的低频分量保持信号特性的重要部分，高频分量则仅仅起到提高信号细节的作用，而且噪声也大多属于高频信息。利用小波变换，噪声信息大多集中在次低频，次高频，以及高频子块中，特别是高频子块，几乎以噪声信息为主，为此，将高频子块设置为零，对次低频和次高频子块进行一定的抑制，则可以达到一定的噪声去除效果。结果分析：均值滤波：对于高斯噪声的抑制比较好，处理后的图像边缘模糊较少，但对于椒盐噪声的影响不大，因为在削弱噪声的同时整幅图像内容总体也变得模糊，其噪声依然存在。中值滤波：对于高斯噪声的抑制效果不明显，这是因为高斯噪声使用随机大小的幅值污染所有的点，因此无论怎样进行数据选择，得到的始终还是被污染的值。中值滤波对去除椒盐噪声可以起到很好的效果，因为椒盐噪声只在画面中的部分点上随机出现，根据中值滤波的原理可知，通过数据排序的方法，将图像中未被噪声污染的点代替代替噪声点的概率比较大，因此噪声的抑制效果比较好，同时画面的轮廓依然比较清晰。对付孤立噪声点，用中值滤波的效果非常好。小波变换：小波变换对于高斯噪声的抑制效果比较好对于小波变换，提高分辨率和有效去除噪声两者不可兼得图像处理后的图像尽管变得比原来模糊，但经处理过后的图像特征更稳定。####数据集的组成机器学习的数据大多数存储在文件，不会存储在数据库mysql的缺点：1.性能瓶颈，内存较大时读取速度受限2.格式不符合机器学习要求数据的格式pandas：读取工具拓展知识：Numpy可以真正实现多线程，因为它释放了GIL（全局解释锁）数据集的结构###特征工程是什么？特征工程是将原始数据转换为更好地代表预测模型的潜在问题的特征的过程，从而提高了对未知数据的预测准确性意义：直接影响预测结果scikit—learn学习工具文本特征抽取 CountVectorizer.get_feature_names()统计文章中的单词，重复只看做一次，但单个字母是不统计的","categories":[{"name":"图像处理学习笔记","slug":"图像处理学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"图像处理","slug":"图像处理","date":"2022-09-09T07:13:37.097Z","updated":"2022-09-09T07:13:37.097Z","comments":true,"path":"2022/09/09/tu-xiang-chu-li/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/tu-xiang-chu-li/","excerpt":"","text":"###图像中蕴含的信息所有精美的图片都是由一个个像素点组成的，对于有色彩的图片的每个像素点都含有三个通道（B、G、R）。在计算机中使用矩阵来数字化表示图像的这些信息，每个像素点都可以用矩阵来坐标表示这个像素点的信息，再用不同的数值来表示该像素点的颜色强弱 图像中有三种常用的色彩空间：灰度、BGR、HSV。灰度色彩空间也是灰度图：去除彩色信息后的图像，灰度图在实现检测方面的功能非常有效；HSV：H是色调，S是饱和度，V表示黑暗的程度 图像通过采样和量化来实现数字化，采样是将空间上连续的图像变换成离散的点，采样频率越高，还原的图像越真实。量化是将采样出来的像素点转换成离散的数量值，一幅数字图像中不同灰度值得个数称为灰度等级，级数越大，图像越是清晰。 ###灰度直方图与二值化灰度直方图反映的是一幅图像中各灰度级像素出现的频率之间的关系，可用于判断图像量化是否恰当，确定图像二值化的阈值，计算图像中物体的面积；计算图像信息量，从灰度直方图可以获得： 暗图像对应的直方图组成成分几种在灰度值较小的左边一侧 明亮的图像的直方图则倾向于灰度值较大的右边一侧 对比度较低的图像对应的直方图窄而集中于灰度级的中部 对比度高的图像对应的直方图分布范围很宽而且分布均匀 如何在灰度直方图中选取阈值原图灰度直方图（利用matplotlib绘制灰度直方图） 当图像中的物体与背景的灰度值比较明显，此时灰度直方图就会包含双峰，分别为图像的前景和后景，前景使得某个灰度区间的灰度值的数量急剧变化，就会产生一个峰值，背景会使得另一个灰度区间的灰度值的数量急剧增加，就产生另一个峰值，两峰间的谷底对应于物体边缘附近相对较少数目的像素点 阈值：两个峰值之间的最低点一般就是最优二值化的分界点，通过这个分界点可以把前景和背景很好地分割开来####二值化 二值化一般是指灰度二值化，将图像中的像素分为两类，最终产生一个二值化的图像。 固定阈值二值化 在进行灰度图二值化时，首先要确定好阈值，对于物体与背景对比度较高的图像，可以选取该阈值作为二值化的值，小于该阈值的像素点赋值为0，大于该阈值的像素点赋值为1（二值化处理） 自适应阈值二值化 虽然说在灰度直方图有机会得到分割图像的阈值，但那是对于物体与背景对比度较高的图像而言，也有可能图像背景的灰度值过于复杂，物体和背景的对比度在图像中也有变化，一个在图像中某一区域效果良好的阈值在其他区域却可能效果很差。 因此用一个二值化的值不能很好的对图像像素进行分类，所以可以将图像划分为多个子图像（区域），对每个子图像单独设置一个二值化的值，分别做二值化处理，然后将这些子图进行拼接，实现更加优化的分割 ####OTSU算法（大津算法、最大类间方差法） 该算法在灰度直方图的基础上用最小二乘法原理推导出来的，核心思想就是使类间方差最大（使得对比分明，分离性最大），类内方差小，要求被分割的物体颜色纹理比较紧凑，在文本图像的处理效果很好。 利用的原理：最佳的阈值能将图像的灰度直方图分割成两部分，使两部分之间的方差取得最大值，即分离性最大 算法过程 理解：首先读取一张图像，并将这张图像转化为灰度图，假设这张灰度图的最大灰度值为L，称图像为具有L级灰度的图像，每个像素的灰度值i称为像素灰度等级，i的取值范围是[0,L-1]，$n_i$是该灰度等级的像素点的个数。 $\\sum_{i=0}^{L-1}n_i$=N为图像中总像素点个数 P(i)=$\\frac{n_i}{N}$为第i个灰度等级的像素在图像中出现的概率 $\\mu=\\sum_{i=0}^{L-1}iP(i)$为图像的平均灰度级 因为阈值是我们想要求得的，我们只能用迭代的方法去找到一个阈值能使得在这个阈值下的类间方差最大。 用迭代的阈值k将图像中的像素点分为目标和背景两类。规定$C_0$类的像素等级为0到k-1，$C_1$类的像素灰度等级为k到L-1。$C_0$类像素占的面积的比例为: $\\omega_0=\\sum_{i=0}^{k-1}P(i)$ $C_1$类像素占的面积的比例为:$\\omega_1=1-\\omega_0$ $C_0$类像素的平均灰度为：$\\mu_0=\\frac{\\sum_{i=0}^{k-1}iP(i)}{\\omega_0}$ $C_1$类像素的平均灰度为：$\\mu_1=1-\\mu_0$ 接着将上面得到的数据代到类间方差公式来求类间方差 类间方差公式：$\\delta^2(k)=\\omega_0(\\mu-\\mu_0)^2+\\omega_1(\\mu-\\mu_1)^2$ 图像的在不同阈值的情况下面积大小也不尽相同，因此要求出两类像素点所占的面积 阈值的迭代范围也是在[0,L-1]参考资料 ####傅里叶变换","categories":[{"name":"图像处理学习笔记","slug":"图像处理学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"为什么要进行图像编码","slug":"为什么要进行图像编码","date":"2022-09-09T07:13:37.089Z","updated":"2022-09-09T07:13:37.090Z","comments":true,"path":"2022/09/09/wei-shi-me-yao-jin-xing-tu-xiang-bian-ma/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/wei-shi-me-yao-jin-xing-tu-xiang-bian-ma/","excerpt":"","text":"为什么要进行图像编码？ 图像编码：图像编码也称图像压缩，是指在满足一定质量（信噪比的要求或主观评价得分）的条件下，以较少比特数表示图像或图像中所包含信息的技术。 信息论学说的奠基人香农曾经论证：不论是语音或图像，由于其信号中包含很多的冗余信息，所以当利用数字方法传输或存储时均可以得到数据的压缩。在他的理论指导下，图像编码已经成为当代信息技术中较活跃的一个分支。 1. 图像的历史图像的成像原理涉及物理的知识，在小孔成像原理的基础上，设计出了照相机的光学系统，再随着电子设备的发展，人们有找到了记录这些光照信息的介质，早些年的胶片，胶片上的感光剂随光发生变化，经显影液显影和定影形成和景物相反或色彩互补的影象（早期洗照片的原因） 然后就是现在大部分使用的数码相机，它主要是使用感光设备将成像的光信号转换为电信号，现在在我看来就是做了模数转换的过程，这样就可以将现实中的模拟量转化为计算机能处理或电子设备能保存的数字量，当然上面介绍的只是图像的来源，和我想要讲解的图像编码关系不大 2. 图像编码的意义让我们从一个设备端的角度看一下图像编码的用处，现在的时代是智能的时代了，不再是从前那个车马慢的时代了，一个人一生也可以爱很多个人了，这都是得益于信号传输的功劳，图像在电子设备看来实际上也就是一些电子信号罢了，我在南方的城市可以看到北京的阅兵仪式，我认为是因为在北京的图像信息经过信号传输被我的设备接收到了，因此我可以看到，但是这其中会产生什么问题呢？ 对于传输端来说：传输信道有传输速率和带宽的限制，传输端想要将图像信息传递出去就必须满足信息容量小于带宽，为什么呢？就像一个萝卜一个坑一样的道理，如果信道不能包含全部传输信息的话，会造成一部分的数据信息丢失也就是失真，别说从南到北的跨地域传输数据了，就算是同一个设备，从获得图像信息的部件传输到处理图像的部件中都可以能发生失真 对于接收端来说：在接收端是对信道进行采样，采样频率与原始信号频率之间有一定的关系，根据奈奎斯特理论，只有采样频率高于原始信号最高频率的两倍时，才能把数字信号表示的信号还原成为原来信号 为了尽可能减少图像失真和图像信息尽可能被接收端采集到，因此引入图像编码是非常有必要的 3. 图像编码的做法图像编码就像将图像信息中的关键信息保留下来，去除那些冗余的信息，从而实现图像的体量变小，同一平面内相邻像素间以及相邻时间的各帧像素间存在相关性，因而数字图像信息具有冗余度，图像编码的基本途径是通过对图像信号样值去相关来消除信息的冗余度。这也就是利用图像信号样值间的相关性来实现图像的频带压缩。参考资料 4. 简单介绍常见的H.265编码和H.264编码 H.265/HEVC编码 H.265是相对于H.264的一个升级版，是在原有H.264标准上的一个拓展和优化。H.265旨在在==有限带宽==下传输更高质量的网络视频，仅需原先的一半带宽即可播放相同质量的视频。这也意味着，我们的智能手机、平板机等移动设备将能够直接在线播放1080P的全高清视频。H.265标准也同时支持4K（4096×2160）和8K（8192×4320）超高清视频参考博客1参考博客2 H.264/AVC编码 H.264是划时代的数字视频压缩标准，在1080P为极致观影追求的时代，H.264是最理想的编码方式参考博客 这两个编码的效果分别如何，我还没有实践过","categories":[{"name":"图像处理学习笔记","slug":"图像处理学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"WDR宽动态","slug":"WDR宽动态","date":"2022-09-09T07:13:37.083Z","updated":"2022-09-09T07:13:37.083Z","comments":true,"path":"2022/09/09/wdr-kuan-dong-tai/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/wdr-kuan-dong-tai/","excerpt":"","text":"宽动态WDR 待实验 参考资料","categories":[{"name":"图像处理学习笔记","slug":"图像处理学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"零基础体验华为云IOT平台的心得体会","slug":"零基础体验华为云IOT平台的心得体会","date":"2022-09-09T07:13:37.077Z","updated":"2022-09-09T07:13:37.078Z","comments":true,"path":"2022/09/09/ling-ji-chu-ti-yan-hua-wei-yun-iot-ping-tai-de-xin-de-ti-hui/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/ling-ji-chu-ti-yan-hua-wei-yun-iot-ping-tai-de-xin-de-ti-hui/","excerpt":"","text":"由于对物联网这个行业感兴趣，有幸参加了华为云的IOT活动，在这个活动的过程中体验了一把部署物联网设备上云，不得不说这对于零基础的小白是非常友好的，个人比较喜欢自顶向下的学习，经过本次活动，我也学会了很多物联网应用层的东西，下面让我聊聊在这个活动中的一些体会吧 个人介绍首先介绍，我是一个计算机专业的在读本科生，由于现在AI大盛行，前段时间学了一段机器学习以及深度学习的一些算法，也做出一些作品，但是大部分时候都是在跑别人的代码，这个过程让我得不到满足感，然后再重新审视了一下方向，觉得还是走一些偏计算机底层的路会比较有乐趣，因此就对物联网产生了兴趣，接下来想往嵌入式软件开发的方向前进。 参加本次本次活动主要目的是对物联网获取基本的了解，其次就是华为的奖品非常的丰厚，有机会获取小熊派开发板，可以让我有学习一些嵌入式设备的机会，而且华为也开发了LiteOS这一轻量的嵌入式操作系统，可以让我跟着华为IOT技术链走下去 第一次使用华为云IOT产品的体验这是我第一次使用华为云的IOT产品，显然经过这次活动，华为让我了解了物联网应用层的一些基本的操作，下面我来介绍一下本次活动的主要内容： 首先在关卡一的时候介绍了如何将物联网设备部署上设备接入平台，以及通过设备接入平台与MQTT.fx模拟了设备与云端物联网平台之间的信息传递，让我对物联网应用层的信息传递有了一定的了解 然后就是关卡二体验“基于IOT平台构建智慧路灯应用”的沙箱实验，这个实验带领体验者，一步步构建起物联网的应用，这里面涉及了其他的华为云服务类似：DevCloud、弹性云服务器之类的，这是为了将物联网应用连接上云展示，并在网页上实现控制设备的操作 上面的两个关卡是比较偏向实践操作的，而关卡三则是偏向理论的，这个步骤的设计确实不错，在知道如何实际部署的前提下，还要求使用者知其所以然，因此设计了一个微认证考核，里面都是选择题，考核使用者是否理解上面两个操作的原因，以及设备接入服务的工作逻辑，考试通过之后你会获得一个证书 体验过程中的踩坑经历及解决小技巧我认为是在关卡一和关卡二中指导书十分详细了，任何操作只需要照着实验指导书上面的操作即可，因此会导致一个对设备接入工作逻辑不理解的情况，只需要按着指导书一步步走下去很少会出现错误，所以在关卡三的时候会出现比较懵的情况，但是不需要惊慌，华为官方对其所有产品都有其详细的说明文档，遇到问题直接到华为官网找相应的官方文档呗这里放设备接入IotDA的文档的链接：设备接入 IoTDA还有一小部分知识在其他文档中，但总是能从官方文档中找到解释 在这个过程中我想分享的小技巧就是：==按照指导书上的步骤一步步进行，不要贪快，多想想每步操作的意义，这样有利于理解这一整套流程==；还有就是看官方文档的小技巧，==先看官方文档对一个产品的简介==，大致了解开发流程之后，再针对需要去看每个小模块的解释，这不止对华为文档有效，现在网上的资料繁杂多样，但是我们开发都要尽可能获取第一手资料也就是看文档，但是文档都会很多内容，而这种方法能大大提高我们的效率 对华为云IOT活动的建议希望能看到对嵌入式操作系统的介绍，在介绍产品的同时，能带给参与者更多的知识，实践与理论的结合才是最好的学习方式，就像马克思原理里面的：“实践是检验真理的唯一标准”，但是总的来说，华为云IOT的本次活动对于我来说，让我受益匪浅，很感谢华为云提供这么简便的方式让使用者能快速入门物联网","categories":[{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"昇腾CANN训练营第二期-模型营第一周作业","slug":"昇腾CANN训练营第二期-模型营第一周作业","date":"2022-09-09T07:13:37.070Z","updated":"2022-09-09T07:13:37.071Z","comments":true,"path":"2022/09/09/sheng-teng-cann-xun-lian-ying-di-er-qi-mo-xing-ying-di-yi-zhou-zuo-ye/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/sheng-teng-cann-xun-lian-ying-di-er-qi-mo-xing-ying-di-yi-zhou-zuo-ye/","excerpt":"","text":"","categories":[{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"昇腾CANN训练营第二期-应用营第一周作业","slug":"昇腾CANN训练营第二期-应用营第一周作业","date":"2022-09-09T07:13:37.064Z","updated":"2022-09-09T07:13:37.065Z","comments":true,"path":"2022/09/09/sheng-teng-cann-xun-lian-ying-di-er-qi-ying-yong-ying-di-yi-zhou-zuo-ye/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/sheng-teng-cann-xun-lian-ying-di-er-qi-ying-yong-ying-di-yi-zhou-zuo-ye/","excerpt":"","text":"MindX SDK快速开发AI应用 目的是为了让我们了解CANN的全栈训练方案，了解MindX SDK的简单用法，从而能使用MindX SDK在昇腾平台上进行简单的开发 1. MindX SDK的功能是什么？MindX SDK的优势是基于流媒体GStreamer的流程编排和插件的开发，在MindX之前的在昇腾架构上开发应用的时候，需要调用的是ACL（Ascend Compute Language）接口实现的，这个开发过程确实比较繁琐的，因此MindX应运而生，为了尽可能减少开发者的开发难度，避免迷失在众多ACL接口中，因此引入了插件式的开发方式，而流程编排可以使开发的代码井然有序 参考资料 2. MindX SDK的结构 MindX SDK主要包含了：mxManufacture SDK 和 mxVision SDK两个SDK mxVision可应用于智能视频/图像分析。典型的业务流程包括图像分类、目标检测、视频结构化等 mxManufacture可应用于制造业的AI智能质量检测。典型的业务流程包括缺陷检测、零部件检测、图像测量等 可以看到两个SDK的软件架构都是相同的，它们的不同之处就在于分别调用的是mxPlugins中的不同插件进行开发编排的，下面逐个介绍一下框架中模块的作用 mxStream用于管理业务Stream StreamManager：负责Stream的构建和销毁，同时提供向其发送数据和获取结果的接口 mxPlugins基础功能插件，例如模型推理插件、图像解码插件 mxBase昇腾AI处理器功能基础库：包括图像解码、裁剪缩放，模型推理 mxToolsSDK提供的开发工具PluginToolkit：提供插件开发的API 参考资料 3. 流程编排流程编排和插件是MindX的特色，先介绍流程编排吧，主要的开发流程编排如下： 通过stream配置文件，Stream manager可识别需要构建的element以及element之间的连接关系，并启动业务流程。Stream manager对外提供接口，用于向stream发送数据和获取结果，帮助用户实现业务对接。 Stream配置文件中，用户必须指定业务流名称、元件名称和插件名称，并根据需要，补充元件属性和下游元件名称信息 Stream配置文件样例： Stream配置文件说明： 插件太多，开发者可以根据开发需要选择相应的插件进行开发，具体插件以及插件的功能可以查看相关文档插件文档 3. MindX SDK与CANN的关系CANN平台是昇腾AI计算平台是华为人工智能全栈全场景使能方案，包括了芯片层、芯片使能层、AI框架层、应用使能层。而CANN是在芯片使能这部分起作用的，什么是芯片使能呢？按我的理解看来，是调度芯片性能和算力决策部件，这是华为基于自研芯片开发的一套专门用于使用芯片的软件平台，我们需要使用昇腾芯片的算力，也就是在昇腾芯片上开发应用，就要使用CANN平台的应用开发框架ACL，这是一个基于昇腾芯片开发的API接口包。按理说，有了这个开发者已经可以实现自我开发了，但是华为做了更进一步的努力，也就是MindX，MindX将ACL开发的功能组装成插件，让开发者能基于插件去开发，同时也引入了流程编排，使得开发更加有序，我认为这就是MindX和CANN的关系 4. MindX SDK开发应用主要有哪四步 转换离线模型 可以使用ATC工具转换将Tensorflow、Mindspore、Caffe训练好的模型或单算子Json文件转化为.om离线模型 开发定制插件（如果需要） MindX已经提供一些基础的插件，开发者可以直接使用这些插件进行开发，或者继承插件的基类进行自定义插件的开发 编排业务流程 流程编排在上面已经介绍得很详细 运行推理服务 (1) 用户通过调用业务流管理API，加载业务流配置文件启动业务流，然后就可以通过调用发送数据和获取结果API运行推理服务，这种运行模式叫做API调用模式 (2) 用户可以通过指定的业务流配置文件（Stream）来启动推理服务，然后用户通过调用http接口，将数据发送给推理服务，同时在返回值中获取结果","categories":[{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"昇腾CANN训练营第一期-应用营第二周作业","slug":"昇腾CANN训练营第一期-应用营第二周作业","date":"2022-09-09T07:13:37.056Z","updated":"2022-09-09T07:13:37.056Z","comments":true,"path":"2022/09/09/sheng-teng-cann-xun-lian-ying-di-yi-qi-ying-yong-ying-di-er-zhou-zuo-ye/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/sheng-teng-cann-xun-lian-ying-di-yi-qi-ying-yong-ying-di-er-zhou-zuo-ye/","excerpt":"","text":"昇腾CANN训练营-应用营 第二周作业本次作业主要是要了解ACL（Ascend Compute Language）的推理应用开发流程主要流程如下图所示： ATC介绍ATC（Ascend Tensor Compiler）是华为昇腾CANN软件栈提供的一个==编译工具==，它的主要功能是将基于开源框架的网络模型（如Caffe、TensorFlow等）以及单算子Json文件，转换成昇腾AI处理器支持的离线模型Offline-Model文件（简称OM文件）。在编译过程中，可以实现算子调度的优化、权值数据重排、内存使用优化等，并且可以脱离设备完成模型的预处理。 它还可以将训练好的权重文件像tensorflow框架下训练出来的pb文件以及checkpoint文件，都可以通过ATC转换成相应的昇腾AI处理器支持的OM模型，还记得之前参加的华为无人车比赛，自己的代码训练好的模型却没办法转换成om模型，导致结果不太理想，这就是那时候应该学会的工具，且ACL还提供了一套用于在昇腾系列处理器上进行加速计算的API。基于这套API，您能够管理和使用昇腾软硬件计算资源，并进行机器学习相关计算。 具体可以看官方开发文档官方文档 运行实验最后的样例","categories":[{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"昇腾CANN训练营第一期-应用营第三周作业","slug":"昇腾CANN训练营第一期-应用营第三周作业","date":"2022-09-09T07:13:37.048Z","updated":"2022-09-09T07:13:37.049Z","comments":true,"path":"2022/09/09/sheng-teng-cann-xun-lian-ying-di-yi-qi-ying-yong-ying-di-san-zhou-zuo-ye/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/sheng-teng-cann-xun-lian-ying-di-yi-qi-ying-yong-ying-di-san-zhou-zuo-ye/","excerpt":"","text":"昇腾CANN训练营-应用营 第三周作业 本次作业的目的是将应用部署到昇腾平台上进行推理，这和第一周的作业的区别在于：第一周的作业是将MindStudio上的样例工程跑通，而本次是不使用MindStudio来将模型进行转换，实际上MindStudio帮我们做的事就是转化模型，以及在平台上运行程序并展示程序的结果，和大多数编译器所做的事差不多，而本次就是用更“命令行”的方式让我们感受一下程序是如何运行起来的 在昇腾平台上部署黑白图像上色的例子前期工作： 在第一周配置好的开发/运行环境 在虚拟机上下载Gitee上的源代码：点这 由于我运行的是python版本的样例，和老谭讲解的不太一样，在配置的路上踩了挺多的坑，因此我觉得参考华为官方文档是很重要的官方文档 我选择的python的版本，首先进入昇腾样例sample仓里面LINK 1. 配置1.首先配置环境和依赖，找到下图，并点击进入超链接 进入之后，由于是在AI1s上面配置，它的教程如下图位置： 2.还记得在第一周安装完toolkit之后显示出来的一大串环境变量需求吗？之前就说过它们的环境变量分别是：离线推理应用环境变量、在线推理应用环境变量、模型转换环境变量 toolkit作为开发者套件包，主要用于用户开发应用、自定义算子和模型转换。在安装完之后想要它能起作用，就必须要让系统能找到它的位置，也就是在操作系统上配置它的环境变量 由于开发环境和运行环境都是在Ai1s上面了，我汇总了一下开发环境和运行环境所需的变量 export install_path=$HOME/Ascend/ascend-toolkit/latest export ASCEND_OPP_PATH=${install_path}/opp export TOOLCHAIN_HOME=${install_path}/toolkit export PYTHONPATH=${install_path}/toolkit/python/site-packages:$PYTHONPATH export PYTHONPATH=${install_path}/pyACL/python/site-packages/acl:$PYTHONPATH export LD_LIBRARY_PATH=$HOME/ascend_ddk/x86/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH=/home/HwHiAiUser/Ascend/nnrt/latest/acllib/lib64:$LD_LIBRARY_PATH export LD_LIBRARY_PATH=/usr/local/python3.7.5/lib:$LD_LIBRARY_PATH export PATH=/usr/local/python3.7.5/bin:$PATH export PATH=${install_path}/atc/ccec_compiler/bin:$PATH export PATH=${install_path}/atc/bin:$PATH export ASCEND_AICPU_PATH=/home/HwHiAiUser/Ascend/nnrt/latest:${ASCEND_AICPU_PATH} export ASCEND_OPP_PATH=${install_path}/nnrt/latest/opp export ASCEND_AICPU_PATH=${install_path} 在业务用户下使用vim ~/.bashrc，编辑bashrc文件并将上面的内容添加到文本末尾，保存之后退出，然后使用source ~/.bashrc使其生效 3.配置好toolkit的环境变量之后，接着开始配置python3的运行环境。 安装pillow的依赖sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev libfreetype6-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk 安装python库python3.6 -m pip install --upgrade pip --user -i https://mirrors.huaweicloud.com/repository/pypi/simple python3.6 -m pip install Cython numpy pillow tornado==5.1.0 protobuf --user -i https://mirrors.huaweicloud.com/repository/pypi/simple 若apt-get安装依赖出现类似报错（dpkg: error processing package *** (–configure)） ，请参考FAQ来解决。 如果python包安装失败，可以试试换个pip源 安装python3-opencvsudo apt-get install python3-opencv 安装ffmpeg，因为atlas_util会调用ffmpeg的so文件 首先创建文件夹，用于存放编译后的文件 mkdir -p /home/HwHiAiUser/ascend_ddk/x86 下载ffmpeg，这个过程会很慢很慢 cd $HOME wget http://www.ffmpeg.org/releases/ffmpeg-4.1.3.tar.gz tar -zxvf ffmpeg-4.1.3.tar.gz cd ffmpeg-4.1.3 安装ffmpeg ./configure --enable-shared --enable-pic --enable-static --disable-x86asm --prefix=/home/HwHiAiUser/ascend_ddk/x86 make -j8 make install 将ffmpeg添加到系统环境变量中，使得其他程序能够找到ffmpeg环境，在root用户下使用vim /etc/ld.so.conf.d/ffmpeg.conf在末尾添加一行/home/HwHiAiUser/ascend_ddk/x86/lib保存退出后使用ldconfig使配置生效，这是一个新文件 配置profile系统文件，使用vim /etc/profile，在末尾添加上export PATH=$PATH:/home/HwHiAiUser/ascend_ddk/x86/bin保存退出后使用source /etc/profile使配置文件生效，接着使用cp /home/HwHiAiUser/ascend_ddk/x86/lib/pkgconfig/* /usr/share/pkgconfig使opencv能找到ffmpeg 最后使用exit退出root用户 2. 准备代码、数据、模型1.前提工作提到的仓库里面存放了本次应用推理所需要的代码，然后将整个仓库下载到虚拟机上，使用 cd $HOME git clone https://gitee.com/ascend/samples.git 下载完之后你的目录下会有一个sample的文件夹 2.下载此次推理需要用到的模型，建议新建一个文件夹我创建了一个temp文件夹，可以从上图sample文件夹下面看到，cd进去之后，使用wget https://modelzoo-train-atc.obs.cn-north-4.myhuaweicloud.com/003_Atc_Models/AE/ATC%20Model/colorization/colorization.prototxt下载caffe模型结构文件，接着再使用wget https://modelzoo-train-atc.obs.cn-north-4.myhuaweicloud.com/003_Atc_Models/AE/ATC%20Model/colorization/colorization.caffemodel下载训练好的权重文件，atc工具就是利用这两个文件转化为能在昇腾设备上运行的om模型 有了这两个文件之后就可以转化模型了，使用atc --input_shape=\"data_l:1,1,224,224\" --weight=\"./colorization.caffemodel\" --input_format=NCHW --output=\"./colorization_yuv\" --soc_version=Ascend310 --framework=0 --model=\"./colorization.prototxt\" 3.获取本次用于推理的数据，首先进入运行工程代码的data文件夹下使用cd samples/python/level2_simple_inference/6_other/colorization_picture/data，接着下载数据，使用wget https://c7xcode.obs.cn-north-4.myhuaweicloud.com/models/colorization_picture-python/dog.png 数据如下 3. 推理首先执行一个推理应用需要数据，模型，代码，这三样东西在上面的操作，已经将它们准备在我们的虚拟机中，还将软件的环境变量配置好了，这就可以进行推理了 1.先将在temp文件夹下存放着的转化好的om模型复制到运行工程代码的model文件夹里，使用cp ./colorization_yuv.om $HOME/samples/python/level2_simple_inference/6_other/colorization_picture/model/ 2.执行python3.6 colorize.py ../data/就可以完成推理过程，推理结果在运行工程文件夹下面out文件夹里面存放着处理之后的结果，可能这个步骤会报ModuleNotFoundError: No module named ‘numpy.core._multiarray_umath‘的错误，这时只需使用pip install --upgrade numpy更新一下numpy就好了 结果如下图所示： 4. 个人代码文件本部分是根据我对如何将推理应用部署到昇腾平台上的理解，来重新实现一遍黑白图像上色， 经过我痛苦的查看华为官方文档以及各种资料，终于实现了重写黑白图像上色的代码 下面是我使用acl来实现的模型推理，它包含了资源初始化，从输入输出的数据结构的构建的过程开始，一步一步申请、创建，这让我对昇腾平台上的应用开发有了更深刻的理解 import acl import numpy as np from ResouceList import resource_list def release(dataset): num = acl.mdl.get_dataset_num_buffers(dataset) for i in range(num): data_buf = acl.mdl.get_dataset_buffer(dataset, i) if data_buf: acl.destroy_data_buffer(data_buf) acl.mdl.destroy_dataset(dataset) class Model(object): def __init__(self, model_path, in_data): self.model_path = model_path self.run_mode, ret = acl.rt.get_run_mode() self._copy_policy = 3 if self.run_mode == 1: self._copy_policy = 2 self.model_id = None self.in_num = 0 self.in_data = in_data self.in_buffer = [] self.in_dataset = None self.out_dataset = None self.model_desc = None self.out_size = 0 self.is_destroyed = False resource_list.register(self) self.Init() def Init(self): self.model_id, ret = acl.mdl.load_from_file(self.model_path) # 模型id是指向模型的指针 self.model_desc = acl.mdl.create_desc() # 声明一个desc类型的地址，相当于指针 acl.mdl.get_desc(self.model_desc, self.model_id) # 获取模型的desc类型的信息 self.out_size = acl.mdl.get_num_outputs(self.model_desc) # 根据desc信息获取模型的输出个数 self.in_num = acl.mdl.get_num_inputs(self.model_desc) # 根据desc信息获取模型的输入个数 self.CreateInputData_Buffer() def CreateOutputDataSet(self): print(\"这里是CreateOutputDataSet\") dataset = acl.mdl.create_dataset() # 声明dataset类型数据的指针 for i in range(self.out_size): size = acl.mdl.get_output_size_by_index(self.model_desc, i) buf, ret = acl.rt.malloc(size, 2) # 声明buffer指针 out_dataset_buffer = acl.create_data_buffer(buf, size) # 创建输出buffer数据类型 _, ret = acl.mdl.add_dataset_buffer(dataset, out_dataset_buffer) # 把buf装到dataset里面 if ret: acl.rt.free(buf) acl.destroy_data_buffer(out_dataset_buffer) self.out_dataset = dataset print(\"成功创建输出dataset\") def CreateInputData_Buffer(self): \"\"\" 获取模型输入数据的buffer空间 :return: \"\"\" for i in range(self.in_num): item = {\"addr\": None, \"size\": 0} self.in_buffer.append(item) # 为输入数据创建一个字典对象来存储 def CreateInputDataSet(self, input_data): print(\"这里是CreateInputDataSet\") self.in_dataset = acl.mdl.create_dataset() # 声明dataset类型的指针 for i in range(self.in_num): data = None size = 0 item = input_data if isinstance(item, np.ndarray): ptr = acl.util.numpy_to_ptr(item) # 将numpy数据类型转换为int类型可以被C函数直接使用 size = item.size * item.itemsize # size为输入图片的像素点总数，itemsize为输入图片的字节数 buffer_item = self.in_buffer[i] # data, ret = acl.rt.malloc(size, 2) if ret != 0: print(\"创建空间失败1\") return None ret = acl.rt.memcpy(data, size, ptr, size, 3) if ret != 0: print(\"创建空间失败2\") acl.rt.free(data) return None if data is None: return None buffer_item['addr'] = data buffer_item['size'] = size if (data is None) or (size == 0): print(\"什么都没有\") break in_dataset_buffer = acl.create_data_buffer(data, size) # 创建输入dataset buffer数据类型 _, ret = acl.mdl.add_dataset_buffer(self.in_dataset, in_dataset_buffer) # 把buffer 装入dataset里 if ret: # 如果将buffer装入dataset失败的话则销毁之前创建的buffer对象 acl.destroy_data_buffer(self.in_dataset) ret = 1 print(\"创建成功\") break if ret == 1: # 创建失败的话 print(\"创建失败\") release(self.in_dataset) self.in_dataset = None def GetOutPutTensor(self): \"\"\" 开辟输出数据所需的numpy数组 :return: \"\"\" output_tensor_list = [] for i in range(self.out_size): dims = acl.mdl.get_output_dims(self.model_desc, i) shape = tuple(dims[0][\"dims\"]) datatype = acl.mdl.get_output_data_type(self.model_desc, i) size = acl.mdl.get_output_size_by_index(self.model_desc, i) if datatype == 0: np_type = np.float32 output_tensor = np.zeros(size // 4, dtype=np_type).reshape(shape) elif datatype == 3: np_type = np.int32 output_tensor = np.zeros(size // 4, dtype=np_type).reshape(shape) elif datatype == 8: np_type = np.uint32 output_tensor = np.zeros(size // 4, dtype=np_type).reshape(shape) elif datatype == 1: np_type = np.float16 output_tensor = np.zeros(size // 2, dtype=np_type).reshape(shape) else: print(\"Unspport model output datatype \", datatype) return None tensor_ptr = acl.util.numpy_to_ptr(output_tensor) output_tensor_list.append({\"ptr\": tensor_ptr, \"tensor\": output_tensor}) return output_tensor_list def GetOutput(self): \"\"\" 将self.out_dataset的数据转化为numpy数据类型 :return: \"\"\" dataset = [] output_tensor_list = self.GetOutPutTensor() for i in range(self.out_size): buf = acl.mdl.get_dataset_buffer(self.out_dataset, i) # 获取模型中的第i个buffer data = acl.get_data_buffer_addr(buf) size = int(acl.get_data_buffer_size(buf)) output_ptr = output_tensor_list[i][\"ptr\"] output_tensor = output_tensor_list[i][\"tensor\"] ret = acl.rt.memcpy(output_ptr, output_tensor.size * output_tensor.itemsize, data, size, self._copy_policy) if ret != 0: print(\"Memcpy inference output to local failed\") return None dataset.append(output_tensor) return dataset def execute(self): result = [] for i in range(len(self.in_data)): self.CreateInputDataSet(self.in_data[i]) self.CreateOutputDataSet() ret = acl.mdl.execute(self.model_id, self.in_dataset, self.out_dataset) # 推理结果存放在self.out_dataset指向的地方 if ret != 0: print(\"推理失败\") dataset = self.GetOutput() result.append(dataset) release(self.in_dataset) self.in_dataset = None return result def __del__(self): if self.is_destroyed: return None release(self.out_dataset) if self.model_id: acl.mdl.unload(self.model_id) if self.model_desc: acl.mdl.destroy_desc(self.model_desc) self._is_destroyed = True resource_list.unregister(self) 下面是我的推理代码，参考了一下sample仓的代码来实现 import cv2 as cv import numpy as np import os import sys path = os.path.dirname(os.path.abspath(__file__)) sys.path.append(os.path.join(path, \"..\")) sys.path.append(os.path.join(path, \"../../../../common/\")) sys.path.append(os.path.join(path, \"../../../../common/atlas_utils\")) from MyModel import Model from acl_resource import AclResource MODEL_WIDTH = 224 MODEL_HEIGHT = 224 out_w = 56 out_h = 56 INPUT_DIR = '../data/' OUTPUT_DIR = '../out/' model_path = '../model/colorization_yuv.om' def preprocess(picPath): img = cv.imread(picPath) img = img.astype(np.float32) img_shape = img.shape[:2] img = img / 255.0 lab_img = cv.cvtColor(img, cv.COLOR_BGR2Lab) img_of_l = lab_img[:, :, 0] lab_img = cv.resize(lab_img, (MODEL_WIDTH, MODEL_HEIGHT)) lab_img = lab_img.astype(np.float32) l_data = lab_img[:, :, 0] l_data = l_data - 50 return img_shape, img_of_l, l_data def postprocess(result_list, pic, orig_shape, orig_l): result_list[0] = result_list[0].reshape(1, 2, 56, 56).transpose(0, 2, 3, 1) result_array = result_list[0][0] ab_data = cv.resize(result_array, orig_shape[::-1]) print(ab_data.shape) result_lab = np.concatenate((orig_l[:, :, np.newaxis], ab_data), axis=2) result_bgr = (255 * np.clip(cv.cvtColor(result_lab, cv.COLOR_Lab2BGR), 0, 1)).astype('uint8') file_name = os.path.join(OUTPUT_DIR, \"out_\" + os.path.basename(pic)) print(file_name) cv.imwrite(file_name, result_bgr) def main(): if not os.path.exists(OUTPUT_DIR): os.mkdir(OUTPUT_DIR) acl_resource = AclResource() acl_resource.init() if os.path.exists(model_path): img_list = [] for file in os.listdir(INPUT_DIR): if os.path.splitext(file)[1] in ['.jpg', '.JPG', '.png', '.PNG', '.bmp', '.BMP', '.jpeg', '.JPEG']: img_list.append(os.path.join(INPUT_DIR, file)) input_list = [] shape_list = [] ori_L_list = [] for item in img_list: orig_shape, orig_l, l_data = preprocess(item) input_list.append(l_data) ori_L_list.append(orig_l) shape_list.append(orig_shape) np.array(input_list) model = Model(model_path, input_list) result = model.execute() for i in range(len(result)): postprocess(result[i], img_list[i], shape_list[i], ori_L_list[i]) break print(\"Execute end\") else: print(\"model not exist\") if __name__ == '__main__': main() 5. 个人亮点我通过代码实现了同时处理多张图片，因为这个模型是一个输入对应一个输出，这是从模型中获取的信息，但是当data文件夹下面有多张图片的时候，并不能全部处理 首先我们清空out文件夹下面的图片 可以看到out已经清空，接着cd到data文件夹下看看有多少图片 有两张图片，下面对比一下运行sample仓代码和我的代码 操作操作很简单，只需要使用第一节课说过的WINSCP将我代码仓里面的代码上传到工程目录下，就是和sample仓的例子的代码放在一起就可以实现","categories":[{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"昇腾CANN训练营第一期-应用营第一周作业","slug":"昇腾CANN训练营第一期-应用营第一周作业","date":"2022-09-09T07:13:37.038Z","updated":"2022-09-09T07:13:37.038Z","comments":true,"path":"2022/09/09/sheng-teng-cann-xun-lian-ying-di-yi-qi-ying-yong-ying-di-yi-zhou-zuo-ye/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/sheng-teng-cann-xun-lian-ying-di-yi-qi-ying-yong-ying-di-yi-zhou-zuo-ye/","excerpt":"","text":"昇腾CANN训练营-应用营 第一周作业这部分主要是为了部署环境，以便接下来开发应用 前提工作： 首先要在华为云上创建属于自己的帐号，这是为了利用华为云上面的AI弹性云服务器来开发 下载一个终端神器——==MobaXterm==，主要是为了让你的终端好看一点，有时候美的东西能提高你的开发效率 需要在昇腾社区下载NNRT以及驱动，还有toolkit，以及MindStudio，这些是在创建是虚拟机上面搭建开发环境的部件 MobaXterm下载链接：https://mobaxterm.mobatek.net/我选择下载的是：installer这个软件会比较卡 Ai1s登录上你的华为云帐号之后，找到控制台，控制台中提供了华为云中的很多功能，我们现在先不管，找到弹性云服务器之后，点击购买弹性云服务器 1.接下来依次设置： 区域可以选择不同区域的服务器，规格只要一块昇腾310就可以满足目前需求了 然后就是配置服务器的镜像，选择Ubantu18.04即可： 2.然后就是配置服务器的网络： 3.再下一步就是高级配置，配置操作系统root用户的密码： 如图所示，你已经创建好你的弹性云服务器： 上面显示了这个服务器的IP地址，我们可以通过远程SSH连接访问到刚刚创建好的云服务器 4.点击远程登录，选择VNC登录 进入之后会出现linux的命令行登陆界面，输入root作为用户名，之后输入你创建的密码 接着输入cat /etc/passwd查看用户的关键信息，这里有已经创建好的用户的用户信息，我们只要知道其用户名即可：HwHiAiUser，接着使用passwd HwHiUser修改一下用户的密码可以和root的密码一样也可以不一样 视频中老谭把sh改为bash，我查了查两者之间的区别：sh 遵循POSIX规范：“当某行代码出错时，不继续往下解释”。bash 就算出错，也会继续向下执行。 这里需要了解一下vim相关指令 5.在获取好用户的信息之后，就可以通过SSH远程访问创建好的虚拟机，使用的是MobaXterm的SSH，这里会让你输入用户的密码 6.之前准备好的NNRT、驱动、toolkit、MindStudio上传到虚拟机中，由于老谭在Windows下使用了一个叫作WINSCP的工具将本地文件上传到虚拟机中，但是我的操作系统是Linux，所以我采用了SCP的方法，复制目录的命令`scp -r local_folder remote_username@remote_ip:remote_folder `，如果你是再次在华为云上创建实例的话，可能会报`Host key for ******.164 has changed and you have requested strict checking.`的错误，这时你可以使用`ssh-keygen -R \"***********\"`，来清除一下当前机器上关于远程服务器的缓存以及公钥信息 7.下面就要给虚拟机安装一些python依赖以及操作系统的依赖，首先要给Ubantu换源首先cd到/etc/apt目录下使用ll指令可以看到sources.list文件，这个文件里面包含了apt-get下载源的信息，由于初始情况下这个源是国外的源，下载速度都非常的慢，因此要换成中国的源，在网上随便找一个源 然后先备份一下这个sources.list文件，cp sources.list sources.list.bak，接着&gt;sources.list清空原来的sources.list文件，接着使用vim sources.list将刚刚复制的源粘贴进去再保存退出后使用apt-get update更新一下源，此步骤在root用户下完成 既然都换了源，为了接下来下载python依赖，也将pip的源给换了，pip的换源需要使用业务用户即：HwHiAiUser用户，同样是在网上任意找一个中国源，然后在/home/HwHiAiUser目录下创建文件夹mkdir .pip隐藏文件夹，然后cd .pip，使用vim pip.conf创建pip.conf文件，接着将复制的源信息粘贴进文件中 8.安装操作系统环境依赖，使用sudo apt-get install -y gcc g++ make cmake zlib1g zlib1g-dev libbz2-dev libsqlite3-dev libssl-dev libxslt1-dev libffi-dev unzip pciutils net-tools libncursesw5-dev ，此步骤在root用户下安装 这个过程可能会出现错误，但是只要在它们安装好之后，再使用一条命令：apt-get install python3.7将安装失败的包重新安装一次 再重复使用sudo apt-get install -y gcc g++ make cmake zlib1g zlib1g-dev libbz2-dev libsqlite3-dev libssl-dev libxslt1-dev libffi-dev unzip pciutils net-tools libncursesw5-dev 就会发现已经安装好了 9.配置python环境变量，linux下环境变量信息存储在.bashrc文件下，使用vim .bashrc指令进入文件中，将光标位置移动到文件最底下，将 #用于设置python3.7.5库文件路径 export LD_LIBRARY_PATH=/usr/local/python3.7.5/lib:$LD_LIBRARY_PATH #如果用户环境存在多个python3版本，则指定使用python3.7.5版本 export PATH=/usr/local/python3.7.5/bin:$PATH 放入文件中，然后保存退出再source .bashrc。此步骤在业务用户下操作， 10.安装python依赖 pip3.7.5 install attrs numpy decorator sympy==1.4 cffi==1.12.3 pyyaml pathlib2 psutil protobuf scipy requests xlrd==1.2.0 --user 11.还记得我们下载好的NNRT、驱动、toolkit、MindStudio吗？我通过SPC上传到downloads下，接下来cd到文件夹中找到它们，使用chmod +x A*给这三个包加可执行权限，dirver驱动要用root用户安装，其他三个用业务用户装，使用./A300-3010-npu-driver_20.2.0_ubuntu18.04-x86_64.run --full安装，选择替换老版本，安装好之后选择reboot，使用VNC远程登录查看变化 重启之后，就可以回到MobaXterm再连接上远程虚拟机了 接着安装NNRT，使用./Ascend-cann-nnrt_3.3.0.alpha001_linux-x86_64.run --install，接着会弹出三条命令 表示相应的环境变量需要配置好，最后配置的环境变量如图： 这里暂且不深究linux下环境变量的格式 还剩下一个toolkit没安装，接下来就使用./Ascend-cann-toolkit_3.3.0.alpha001_linux-x86_64.run --install下载，下面会提出一大堆的要求,第一个环境变量表示离线推理应用环境变量，第二个环境变量表示在线推理应用环境变量，第三个环境变量表示模型转换环境变量 Offline infer develop (cannot coexist with other scenes): PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/toolkit/bin: LD_LIBRARY_PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/acllib/lib64: PYTHONPATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/pyACL/python/site-packages/acl: /home/HwHiAiUser/Ascend/ascend-toolkit/latest/toolkit/python/site-packages: ASCEND_AICPU_PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest: ASCEND_OPP_PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/opp: TOOLCHAIN_HOME includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/toolkit: Third party AI framework develop (cannot coexist with other scenes): PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/fwkacllib/ccec_compiler/bin: /home/HwHiAiUser/Ascend/ascend-toolkit/latest/fwkacllib/bin: /home/HwHiAiUser/Ascend/ascend-toolkit/latest/toolkit/bin: LD_LIBRARY_PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/fwkacllib/lib64: PYTHONPATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/fwkacllib/python/site-packages: /home/HwHiAiUser/Ascend/ascend-toolkit/latest/toolkit/python/site-packages: ASCEND_OPP_PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/opp: ASCEND_AICPU_PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest: TOOLCHAIN_HOME includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/toolkit: Model transformation and operator develop (cannot coexist with other scenes): PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/atc/ccec_compiler/bin: /home/HwHiAiUser/Ascend/ascend-toolkit/latest/atc/bin: /home/HwHiAiUser/Ascend/ascend-toolkit/latest/toolkit/bin: LD_LIBRARY_PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/atc/lib64: PYTHONPATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/atc/python/site-packages: /home/HwHiAiUser/Ascend/ascend-toolkit/latest/toolkit/python/site-packages: ASCEND_OPP_PATH includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/opp: TOOLCHAIN_HOME includes : /home/HwHiAiUser/Ascend/ascend-toolkit/latest/toolkit: 我们先创建一个文件保存下这些vim env.txt，可能后面要用到 接下来就是图形化开发界面MindStudio的安装，由于这是一个压缩包，可以直接使用tar zxvf MindStudio_2.0.0-beta3_linux.tar.gz直接解压，解压出来之后变成一个MindStudio的文件夹，cd进入文件夹中，再进入/bin文件夹，找到MindStudio.sh文件，然后运行该文件，注意此步骤在root用户下运行 第一次运行程序会检查环境需要的依赖，它会告诉你你缺少了下面的东西 先使用sudo apt-get -y install xterm firefox xdg-utils openjdk-8-jdk fonts-droid-fallback fonts-wqy-zenhei fonts-wqy-microhei fonts-arphic-ukai fonts-arphic-uming gnome-keyring安装 ，安装好之后在使用./MindStudio.sh查看还缺少什么，一看原来是/usr/local/python3.7.5/bin/pip3 install --user coverage gnureadline pylint matplotlib pandas xlrd absl-py，装就完事了，但是此步骤要在业务用户下操作 按理说安装完上面所有之后就可以看到MindStudio的图形界面了，但是我却出现了下面的错误Can't connect to X11 window server using 'localhost:11.0' as the value of the DISPLAY variable.，最后发现原来是我使用了root用户运行，接着使用HwHiAiUser运行后，果然出现了MindStudio的图形界面 启动之后要设置它的toolkit，在文件目录下找到Ascend目录下ascend-toolkit文件夹下选择3.3.0alpha001，然后点ok然后就可以进入 点击创建新的工程，来跑一个MindStudio自带的样例，右边可供选择的有算子开发、模型开发、应用开发，这里选择应用开发后点NEXT 选择resnet50的样例工程 进入之后选择readme.md文档，在这你可以查看到跑样例的详细操作","categories":[{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"昇腾AI处理器架构","slug":"昇腾AI处理器架构","date":"2022-09-09T07:13:37.027Z","updated":"2022-09-09T07:13:37.028Z","comments":true,"path":"2022/09/09/sheng-teng-ai-chu-li-qi-jia-gou/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/sheng-teng-ai-chu-li-qi-jia-gou/","excerpt":"","text":"昇腾AI处理器架构架构：均为达芬奇架构 昇腾310该芯片只适用于推理不适用于训练，因为没有求梯度反向传播的算子 *昇腾910用于训练的芯片 1. AI Core：计算单元——Cube UnitAI Core是昇腾芯片的一个部分，也是达芬奇机构的所在地，其主要作用在于：实现优化的矩阵乘法运算，我们知道在学习深度学习的过程中线性代数是必不可少的知识，而数据的表示大多数都是以矩阵的形式来表示，例如：图像数据就是一个很直观的表示，矩阵能表示的数据很多而且矩阵乘法能一次运算将运算结果得出，所以在硬件层次优化就是优化矩阵乘法的次数 卷积神经网络中的卷积也是可以转化为矩阵的乘法，而一个网络模型中，用到的卷积、全连接等运算都是矩阵运算，因此优化矩阵乘法的次数能大大减少神经网络的计算量 理论是如何我忘记了，待复习。。 这个CANN平台的功能模块还是比较多的，需要后续逐渐补充","categories":[{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"小熊派折腾ing","slug":"小熊派折腾ing","date":"2022-09-09T07:13:37.021Z","updated":"2022-09-09T07:13:37.022Z","comments":true,"path":"2022/09/09/xiao-xiong-pai-zhe-teng-ing/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/xiao-xiong-pai-zhe-teng-ing/","excerpt":"","text":"小熊派介绍小熊派IoT开发板一款由南京小熊派智能科技有限公司联合华为技术有限公司基于STM32L431RCT6设计的高性能物联网开发板。开发板充分考虑物联网感知层设备的多样性，具有强大的可扩展性，用于提供给开发者评估及快速设计相关物联网的应用产品。 案例 智慧路灯由于需要尝试华为云的设备接入平台的信息传递的功能，恰好手边有一块之前玩IOT获得的开发板，就打算使用此开发板来进行对信息传递的模拟 小熊派开发板的十分方便安装只需要将相应的模块插入相对应的引脚里面就可以了，相信你上手之后很容易弄懂，这里就不过多描述，让我们把重心放在如何使用它调用设备接入平台的API实现信息传递的功能吧 1. 编译环境配置首先使用Mobaxterm连接上虚拟机上的Linux（Ubantu）环境或者是你购买的云服务器，接下来的配置也是在Linux操作系统下的配置 ls -l /bin/sh查看当前shell是否为bash 安装编译环境所需要的依赖 sudo apt install python3.8 python3-pip sudo pip3 install setuptools kconfiglib pycrytodome ecdsa sudo pip3 install six --update --ignore-installed six 查看当前python版本python -V将系统中原有的python2删除，链接上python3 sudo rm /usr/bin/python sudo ln -s python3.8 /usr/bin/python 安装Scons sudo apt install scons -y 使用scons -v查看是否安装成功 下载的scons版本是3.0.1，但是要求的版本是3.1.2以上的版本，因此需要源码安装去到官网下载https://scons.org/pages/download.html选择下载如下图所示 下载好之后，在Mobaxterm里面左边的文件栏可以实现直接将文件拖入文件夹中的操作，因此现在Mobaxterm里面创建一个文件夹mkdir tools，并将刚刚下载好的压缩包传入文件夹中，在文件夹中解压压缩包tar -xvf 压缩包名 接着进入解压出来的文件夹中，使用sudo python3 setup.py install进行安装，此时再使用scons -v查看时已经是4.0.1的版本满足要求 接下来是安装构建工具gn https://repo.huaweicloud.com/harmonyos/compiler/gn/1523/linux/gn.1523.tar ninja https://repo.huaweicloud.com/harmonyos/compiler/ninja/1.9.0/linux/ninja.1.9.0.tar 交叉编译器gcc_riscv32 https://repo.huaweicloud.com/harmonyos/compiler/gcc_riscv32/7.3.0/linux/gcc_riscv32-linux-7.3.0.tar.gz 下载好这三个压缩包之后同样是使用上面说的方法将这三个压缩包放入tools文件夹里面，使用 tar -xvf gn.1523.tar -C ~/ tar -xvf ninja.1.9.0.tar -C ~/ tar -xvf gcc_riscv32-linux-7.3.0.tar.gz -C ~/ 解压一下三个文件夹，解压出来的文件夹放到~目录下，然后配置一下环境变量，使用vim工具sudo vim .bashrc，将下面的命令拷贝到.bashrc文件底部，使用vim指令wq!保存退出，出来之后使用source ~/.bashrc 使配置生效 export PATH=~/gn:$PATH export PATH=~/ninja:$PATH export PATH=~/gcc_riscv32/bin:$PATH 最后使用riscv32-unknown-elf-gcc -v查看编译工具是否安装成功，至此为止Linux端的编译环境的搭建就已经完成了 2. HarmonyOS的源码首先创建存放HarmonyOS源码的文件夹，使用mkdir code创建存放源码的文件夹，考虑到后面还需要放置其他工程的下载源码，因此为了方便管理，进入code文件夹之后cd code，再创建一个代码文件夹mkdir BearPiCode，这个文件夹就是存放HarmonyOS源码的文件夹，进入该文件夹cd BearPiCode 获取源码的方式一创建文件夹mkdir code_1，并进入文件夹cd code_1，使用wget工具下载wget https://repo.huaweicloud.com/harmonyos/os/1.0/code-1.0.tar.gz，至于多久能下载完毕就要看你的网速了，然后使用tar -vxf code-1.0.tar.gz解压压缩包 获取源码的方式二方式二是从HPM网站上组件式获取，小熊派的开发是按组件来开发代码的，因此这种方式可以让用户自定义所需要的组件，只需要下载源码安装即可以这种方式下载对下载环境有一定的要求，首先要安装Node.js，同样是去到放置工具的文件夹中使用wget https://nodejs.org/dist/v14.15.1/node-v14.15.1-linux-x64.tar.xz下载，下载完成之后使用tar -vxf node-v14.15.1-linux-x64.tar.xz -C ~/将解压出来的压缩包放在~目录下，然后设置一下软链接，软链接的知识点在Linux操作系统那部分讲解，使用 sudo ln -s ~/node-v14.15.1-linux-x64/bin/npm /usr/bin/ sudo ln -s ~/node-v14.15.1-linux-x64/bin/node /usr/bin/ 接着就是安装hpm命令行工具 npm install -g @ohos/hpm-cli sudo ln -s ~/node-v14.15.1-linux-x64/bin/hpm /usr/bin/ 接着使用hpm -V查看hpm的版本，检查是否安装成功 然后就可以通过hpm install 安装组件 以上的所有操作都是为了配置好组件化下载源码的环境，接下来就要去HPM官方网站下载源码了 新建一个文件夹mkdir code_2保存第二种方式获取的源码，cd code_2进入创建好的文件夹，将刚刚下载好的压缩包放入文件夹中，这是一个zip文件，因此需要使用unzip demo.zip，进入解压出来的压缩包cd demo，然后使用hpm install安装一下即可 获取源码的方式三在前面配置好hpm的下载环境的情况下，只需要使用以下指令即可，同样要记得新建一个文件夹来存放代码 hpm init -t default hpm install @bearpi/bearpi_hm_nano 3. HarmonyOS源码目录结构 还需要动手实现或者跑一边样例才能对这个目录结构有更深的理解 4. 映射Linux上的工程在嵌入式开发中，经常会使用Windows作为开发环境，但是工程代码却是只能支持在Linux系统下编译的，如果想实现在Windows下进行代码的开发，该如何实现呢？这就需要将Linux环境下的工程目录映射到Windows环境下，然后使用VSCode打开，在Windows环境下进行烧录和调试 映射方法如下： 在Linux环境下，设置工程代码所在的文件夹为共享文件夹 安装Samba sudo apt-get install samba 配置Samba sudo vim /etc/samba/smb.conf 添加以下内容 [HarmonyOS_Code] path = /home/bearpi/code available = yes valid users = bearpi read only = no browsable = yes public = yes writable = yes 设置Samba用户名和密码 sudo smbpasswd -a bearpi 重启Samba sudo /etc/init.d/smbd restart 在Windows上，鼠标右键单击“此电脑”，选择“映射网络驱动器（N）” 选择一个未使用的驱动器，并设置HarmonyOS源码所在的路径，格式为“\\Linux IP地址\\共享文件夹名称”，如：\\192.168.0.224\\HarmonyOS_Code，点击“完成” 5. 小熊派第一个开发案例——HelloWorld","categories":[{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"对象存储服务OBS","slug":"对象存储服务OBS","date":"2022-09-09T07:13:37.013Z","updated":"2022-09-09T07:13:37.014Z","comments":true,"path":"2022/09/09/dui-xiang-cun-chu-fu-wu-obs/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/dui-xiang-cun-chu-fu-wu-obs/","excerpt":"","text":"对象存储服务OBSOBS桶是我在参加华为无人车的时候使用过的一个工具，当时还不知道这个是什么只是知道它可以存放训练脚本和训练数据集，然后在华为云的ModelArt上面和OBS桶建立联系，使得ModelArt可以根据用户的训练脚本和训练数据来训练自己的模型","categories":[{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"华为云相关产品知识","slug":"华为云相关产品知识","date":"2022-09-09T07:13:37.008Z","updated":"2022-09-09T07:13:37.009Z","comments":true,"path":"2022/09/09/hua-wei-yun-xiang-guan-chan-pin-zhi-shi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/hua-wei-yun-xiang-guan-chan-pin-zhi-shi/","excerpt":"","text":"什么是弹性云服务器（ECS）前几天参加华为的昇腾训练营，其中使用了AI加速性的弹性云服务器作为运行环境，刚开始碰到这个概念，不知道这是什么东西，只是经过训练营浅薄的了解了这是一个布置了昇腾CPU的一个服务器，至于硬件资源如何布置上云，那就要等以后去了解了，现在让我们看看到底什么是弹性云服务器吧 弹性云服务器（Elastic Cloud Server，ECS）是由CPU、内存、操作系统、云硬盘组成的基础的计算组件。弹性云服务器创建成功后，您就可以像使用自己的本地PC或物理服务器一样，在云上使用弹性云服务器。您只需要指定CPU、内存、操作系统、规格、登录鉴权方式即可，同时也可以根据您的需求随时调整弹性云服务器的规格，为您打造可靠、安全、灵活、高效的计算环境。 这就是华为官方的解释，它的弹性就在于能根据需求调整云服务器的规格，现在我们应该对服务器有一定的认识了，服务器实际上就是一台电脑，只是根据其功能称其为服务器，而服务器的功能就是在一台电脑上运行==别人的==程序，这里的别人可以理解为：你再本地上运行的程序叫做自己的程序，但是你想将你的程序放到另一台电脑（使用别人的计算资源）上运行时，这个电脑就叫做服务器，服务器具有很多种类型，但是它们都应该有一个共同点：支持高并发 什么是软件开发平台（DevCloud） 软件开发平台（DevCloud）是集华为近30年研发实践、前沿研发理念、先进研发工具为一体的一站式云端DevOps平台，面向开发者提供的云服务，即开即用，随时随地在云端进行项目管理、代码托管、流水线、代码检查、编译构建、部署、测试、发布等，让开发者快速而又轻松地开启云端开发之旅。 在我看来就是一个在云上管理你的项目的一个平台，但是集成了很多统计报表、人员贡献度、以及缺陷的检测等多功能的一个平台，你可以直接将你的代码放上它的代码托管（相当于github的一个仓库，同样具有github的功能方便协作），利用它的云上编译使你的代码能运行在ecs上，这样就能提高开发与交互的效率 设备管理 这是一个IOT平台，提供提供海量设备的接入和管理，配合华为云其他产品同时使用，帮助快速构筑物联网应用。 设备接入 多网络接入：支持有线和无线的接入方式，如固定宽带、2G/3G/4G/5G、NB-IoT、Z-Wave、ZigBee、eLTE等。 多协议接入：支持HTTPS+MQTTS、MQTTS、LWM2M/CoAP协议接入。 多Agent接入：支持Agent Lite和Agent Tiny，覆盖的语言包括C、Java、Python。Agent与海思、高通主流芯片、模组预集成，缩短TTM。 云端协议解析：支持在云端对接入协议和设备数据进行解析，无需变更设备端数据上报格式，在云端开发插件灵活解析 设备管理IoT平台提供丰富完备的设备管理能力，用户可以通过管理门户或者调用API，对设备进行管理。 有如：产品模型定义、设备注册、设备接入鉴权、设备访问授权、设备数据采集、数据持久化存储、设备实时状态监控、设备影子、规则引擎、设备配置更新、设备命令下发、软固件升级、设备分组及标签、设备批操作、设备日志收集、告警管理 产品模型（也称Profile）用于描述设备具备的能力和特性。开发者通过定义Profile，在IoT平台构建一款设备的抽象模型，使平台理解该款设备支持的服务、属性、命令等信息。==在设备管理的过程中，首先要将产品模型的信息导入设备管理平台== 规则引擎是指用户可以对平台接入的设备设定相应的规则，在条件满足所设定的规则后，平台会触发相应的动作来满足用户需求。包含设备联动和数据转发两种类型。 安全&amp;数据保护IoT提供多种安全防护措施，确保设备安全、数据有效保护。 设备安全：提供一机一密的设备安全认证机制，防止设备非法接入。 信息传输安全：基于TLS、DTLS、DTLS+加密协议，提供安全的传输通道。 数据保护：满足欧盟GDPR数据隐私保护要求。 应用管理IoT平台开放了海量的API接口和SDK，包括应用安全接入、设备管理、数据采集、命令下发、批量处理和消息推送的接口能力，帮助开发者快速孵化行业应用。","categories":[{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"LN882H开发笔记","slug":"LN882H开发笔记","date":"2022-09-09T07:13:37.000Z","updated":"2022-09-09T07:13:37.001Z","comments":true,"path":"2022/09/09/ln882h-kai-fa-bi-ji/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/ln882h-kai-fa-bi-ji/","excerpt":"","text":"LN882H开发笔记USB串口下载的boot模式接线图：","categories":[{"name":"亮牛开发笔记","slug":"亮牛开发笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E4%BA%AE%E7%89%9B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Windows下多版本CUDA","slug":"Windows下多版本CUDA","date":"2022-09-09T07:13:36.993Z","updated":"2022-09-09T07:13:36.994Z","comments":true,"path":"2022/09/09/windows-xia-duo-ban-ben-cuda/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/windows-xia-duo-ban-ben-cuda/","excerpt":"","text":"Windows下多版本CUDA共存有些时候，我们的项目需要使用到不同的框架或者同一框架下的不同版本，例如：tensorflow的版本之间差异比较明显，有时候需要不同的tensorflow版本，而不同版本的tensorflow对CUDA和CUDNN的版本要求也不一样，我们肯定不能每次使用一个版本都重新安装，但是可以多版本的CUDA和CUDNN共存 首先NVIDIA显卡驱动和CUDA ToolKit不是一一对应的，我们一般保持最新的驱动程序，安装其他不同版本的CUDA即可；CUDA和cudnn也不是严格的一一对应关系，但是这个官网上有着明确的对应连接，即什么版本的cuda配置什么样的cudnn","categories":[{"name":"Tensorflow框架学习笔记","slug":"Tensorflow框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Tensorflow%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Tensorflow计算图","slug":"Tensorflow计算图","date":"2022-09-09T07:13:36.986Z","updated":"2022-09-09T07:13:36.987Z","comments":true,"path":"2022/09/09/tensorflow-ji-suan-tu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/tensorflow-ji-suan-tu/","excerpt":"","text":"Tensorflow中的计算可以表示为一个有向图，或称为计算图，其中的每一个运算操作将作为一个节点，节点与节点之间的连接称为边，这个计算图描述了数据的计算流程，它也负责维护和更新状态，计算图中每一个节点可以有任意多个输入和输出，在计算图的边中流动（flow）的数据称为张量（tensor），因此这个框架叫做Tensorflow。 Tensorflow2和Tensorflow1.X的区别在于，Tensorflow1.X采用的方式叫做符号式编程，Tensorflow2采用的是命令式编程，也称为动态图优先模式，不像Tensorflow1.X要先创建计算图之后才能进行运算，Tensorflow2能同时得到计算图和数值结果 我觉得可能属于这部分的内容","categories":[{"name":"Tensorflow框架学习笔记","slug":"Tensorflow框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Tensorflow%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Tensorflow简介","slug":"Tensorflow简介","date":"2022-09-09T07:13:36.981Z","updated":"2022-09-09T07:13:36.981Z","comments":true,"path":"2022/09/09/tensorflow-jian-jie/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/tensorflow-jian-jie/","excerpt":"","text":"Tensorflow简介Tensorflow深度学习框架在构建网络的优势： 加速计算Tensorflow可以利用GPU实现大量矩阵之间的并行计算。 自动梯度Tensorflow提供了自动求导的功能，可以不需要手动推导，即可计算出输出对网络的偏导数。 常用神经网络接口：Keras 内建了常用网络运算函数，常用网络层，网络训练，网络保存和加载，网络部署等一系列深度学习系统的便捷功能。 配套设施成熟 Tensorflow历史更悠久，且社区用户庞大，你可以找到很多问题的解决方案，且很多嵌入式平台也是支持Tensorflow的 1. Pytorch与Tensorflow的主流之争在深度学习成为热门的现在，催生出一大群算法工程师，也使得各种深度学习框架诞生，其中以两个最为多人使用：Pytorch和Tensorflow，那么这两者谁优谁劣呢？我很难去评定，但是普遍现象来看做科研的大多数还是使用的Pytorch，而Tensorflow大多应用于工业领域中，因为在Pytorch火之前，很多嵌入式设备中用于迁移模型的框架还是使用Tensorflow，也就是TF1.X，当然现在TF2.X与TF1.X换代落差太大，照常很多人的学习成本变得更高，而Pytorch也开始支持转换中间模型，让迁移模型更加简单。尽管这样也无法妨碍Tensorflow受到大家的喜欢，毕竟情人眼里出西施，每个人眼中的“好用”都不一样，我的建议是学习框架的思想，这样就可以很方便从一个框架迁移到另外一个框架。 2. Hello Tensorflow想学习深度学习的程序员可以向Tensorflow说一句“Hello Tensorflow”","categories":[{"name":"Tensorflow框架学习笔记","slug":"Tensorflow框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Tensorflow%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"4. TensorFlow2.0Keras高层接口","slug":"4. TensorFlow2.0Keras高层接口","date":"2022-09-09T07:13:36.974Z","updated":"2022-09-09T07:13:36.974Z","comments":true,"path":"2022/09/09/4.tensorflow2.0keras-gao-ceng-jie-kou/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/4.tensorflow2.0keras-gao-ceng-jie-kou/","excerpt":"","text":"Tensorflow之Keras高层接口Keras是一个主要由python语言开发的开源神经网络计算库，它被设计为高度模块化和易扩展的高层神经网络接口，使得用户可以不需要过多的专业知识就可以简洁、快速地完成模型的搭建与训练。==Keras库分为前端和后端，其中后端可以基于现有的深度学习框架实现，如：Theano，CNTK，TensorFlow，前端接口即Keras抽象过的统一接口API== 1. 常见功能模块Keras提供了一系列高层的神经网络类和函数，如常见数据集加载函数，网络层类，模型容器，损失函数类，优化器类，经典模型类等等。对于常见数据集，可以在实现下载、管理、加载功能函数 1. 常见网络层类==对于常见的神经网络层，可以使用张量方式的底层接口函数来实现，这些接口函数一般在tf.nn模块==，更常用地，对于常见的网络层，我们一般直接使用层方式来完成模型的搭建，==在tf.keras.layers命名空间中提供了大量常见网络层类接口，如全连接层，激活含水层，池化层，卷积层，循环神经网络等等==。 对于这些网络层类，只需要在创建时指定网络层的相关参数，并调用__call__方法即可完成前向计算。在调用__call__方法时，Keras会自动调用每个层的前向传播逻辑，这些逻辑一般实现在类的call函数中。 2. 网络容器在搭建一个深层次的网络时，如果需要手动调用每一层的类实例来完成前向传播运算，这会让代码显得很繁琐。因此Keras提供了网络容器Sequential将多个网络层封装成一个大网络模型，只需要调用网络模型的实例一次即可完成数据从第一层到最末层的顺序计算，很大程度上提高了代码的可读性。 import tensorflow as tf from tensorflow.keras import layers,Sequential Network = Sequential([ layers.Dense(128,activation='relu'), layers.Dense(64,activation='relu'), layers.Dense(10,activation=None) ]) X = tf.random.normal([5,784],mean=10,stddev=4) print(Network(X)) Sequential容器也可以通过add()方法继续追加新的网络层，实现动态创建网络的功能 import tensorflow as tf from tensorflow.keras import layers,Sequential Network = Sequential([ layers.Dense(128,activation='relu'), layers.Dense(64,activation='relu'), layers.Dense(10,activation='relu') ]) X = tf.random.normal([5,784],mean=10,stddev=4) print(Network(X)) Network.summary() Network.add(layers.Dense(3,activation='relu')) print(Network(X)) Network.summary() OUT： tf.Tensor( [[ 0.31222105 2.324831 0. 0. 0.8691125 4.446599 0.7532449 0. 0. 7.0183835 ] [ 0. 4.575545 0. 0. 0. 0. 0. 0. 0. 4.863575 ] [ 0. 4.6534796 0. 0. 0. 0. 4.869212 0. 0. 8.841119 ] [ 7.117663 4.2178197 1.489924 0. 0. 1.0914445 0. 0. 0. 15.866627 ] [ 0. 0. 1.4162097 0. 0. 4.338018 4.436591 0. 0. 4.843932 ]], shape=(5, 10), dtype=float32) Model: \"sequential\" _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= dense (Dense) multiple 100480 _________________________________________________________________ dense_1 (Dense) multiple 8256 _________________________________________________________________ dense_2 (Dense) multiple 650 ================================================================= Total params: 109,386 Trainable params: 109,386 Non-trainable params: 0 _________________________________________________________________ tf.Tensor( [[ 5.488745 0. 3.7889113] [ 3.5730066 0. 1.3197422] [ 4.624317 0. 3.2175438] [11.70434 0. 6.9458585] [ 2.813189 0. 5.0816736]], shape=(5, 3), dtype=float32) Model: \"sequential\" _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= dense (Dense) multiple 100480 _________________________________________________________________ dense_1 (Dense) multiple 8256 _________________________________________________________________ dense_2 (Dense) multiple 650 _________________________________________________________________ dense_3 (Dense) multiple 33 ================================================================= Total params: 109,419 Trainable params: 109,419 Non-trainable params: 0 _________________________________________________________________ import tensorflow as tf from tensorflow.keras import layers,Sequential layer_num = 2 # 创建空网络容器 Network = Sequential([]) for _ in range(layer_num): Network.add(layers.Dense(3,activation='relu')) Network.build(input_shape=(2,4)) X = tf.random.normal([2,4]) print(Network(X)) Network.summary() model.summary() 函数的功能是打印网络结构和参数量，如果在使用动态创建网络时，全连接层网络的参数不是自定义的，这时很多类内并没有创建内部权值张量等成员变量，因此需要通过调用类的build方法并指定输入大小，即可自动创建所有层的内部张量 ==可以看见Layer列为每层的名字，这个名字由TensorFlow内部维护，与python的对象名不一样，param#列为层的参数个数，Total Params统计出了总的参数量，Trainable params为待优化的参数量，Non-trainable params为不需要优化的参数量。== ==Squential容量封装多层网络层时，所有层的参数列表将会自动并入Sequential容器的参数列表中，不需要人为合并网络参数列表。Sequential对象的trainable_variables和variables包含了所有层的待优化张量列表和全部张量列表== 2. 模型装配、训练与测试训练网络的一般步骤：通过前向计算获得网络的输出值，再通过损失函数计算网络误差，然后通过自动求导工具计算梯度并更新，同时间隔性地测试网络的性能。这种常用的训练逻辑，可以直接通过Keras提供的模型装配与训练高层接口实现，简洁清晰。 ==在Keras中，有2个比较特殊的类：keras.Model和keras.layers.Layer类。Layer类是网络层的母类，定义了网络层的一些常见功能，如：添加权值，管理权值列表等。Model类是网络的母类，除了具有Layer类的功能，还添加了保存、加载模型，训练与测试模型等便捷功能，Sequential也是Model的子类，因此具有Model类的所有功能== 用Sequential容器封装网络 import tensorflow as tf from tensorflow import keras from tensorflow.keras import layers,Sequential,losses,optimizers,datasets \"预处理数据\" def Process(x,y): x = tf.cast(x,dtype=tf.float32)/255 x = tf.reshape(x,[28*28]) y = tf.cast(y,tf.int32) y = tf.one_hot(y,depth=10) return x,y (train_x, train_y), (test_x, test_y) = datasets.mnist.load_data() \"Label独热编码\" train_ds = tf.data.Dataset.from_tensor_slices((train_x,train_y)) train_ds = train_ds.map(Process).shuffle(60000).batch(128) test_ds = tf.data.Dataset.from_tensor_slices((test_x,test_y)) test_ds = test_ds.map(Process).batch(128) print(train_ds,test_ds) \"模型装配\" Network = Sequential([ layers.Dense(256,activation='relu'), layers.Dense(128,activation='relu'), layers.Dense(64,activation='relu'), layers.Dense(32,activation='relu'), layers.Dense(10)]) Network.build(input_shape=(None,28*28)) Network.summary() \"模型训练\" Network.compile(optimizer=optimizers.Adam(lr=0.001),loss = losses.CategoricalCrossentropy(from_logits=True),metrics=['accuracy']) history = Network.fit(train_ds,epochs=5,validation_data=test_ds,validation_freq=2) print(history.history) sample = next(iter(test_ds)) print(sample) x = sample[0] y = sample[1] pred = Network.predict(x) y = tf.argmax(y,axis=1) pred = tf.argmax(pred,axis=1) print(y) print(pred) 解释上面用到的一些函数的作用 map（）函数根据提供的函数对指定序列进行映射，不改变原有序列而是返回一个新的序列，上面的操作就是对from_tensor_slices函数返回的数据集元组进行Process映射 Sequential容器用来封装网络结构，也可以自己创建一个图层（类）来封装网络层结构 需要特别介绍一下Layer中的__init__()，build()，call()方法，这三个方法是从layers.Layer处继承来的，其中__init__():初始化一些成员变量。build():需要知道输入张量的大小，当然创建网络时不一定要等到调用build来创建变量，也可以在__init__中创建变量，但是在build中创建变量的优点是它可以根据图层将要操作的输入的形状启用后期变量创建，而且在__init__中创建变量时需要指定创建的变量的形状。call函数在类被调用时执行 compile(optimizer, loss=None, metrics=None, loss_weights=None, sample_weight_mode=None, weighted_metrics=None, target_tensors=None)功能：用于配置训练模型。compile主要完成损失函数和优化器的一些配置，是为训练服务的，如果只是需要预测，可以不用compile函数 fit(x=None, y=None, batch_size=None, epochs=1, verbose=1, callbacks=None, validation_split=0.0, validation_data=None, shuffle=True, class_weight=None, sample_weight=None, initial_epoch=0, steps_per_epoch=None, validation_steps=None)功能：以给定数量的轮次（数据集上的迭代）训练模型。返回：一个 History 对象。其 History.history 属性是连续 epoch 训练损失和评估值，以及验证集损失和评估值的记录（如果适用）。 predict(x, batch_size=None, verbose=0, steps=None)功能：为输入样本生成输出预测。计算是分批进行的。返回：预测的 Numpy 数组（或数组列表）。 evaluate(x=None, y=None, batch_size=None, verbose=1, sample_weight=None, steps=None)功能：在测试模式下返回模型的误差值和评估标准值。计算是分批进行的。返回：标量测试误差（如果模型只有一个输出且没有评估标准） 或标量列表（如果模型具有多个输出 和/或 评估指标）。 属性 model.metrics_names 将提供标量输出的显示标签。 3. 模型保存与加载模型训练完成后要保存到文件系统上，方便后续的模型测试与部署工作，事实上，在训练时间间隔性地保存模型状态也是非常好的习惯，这点在训练大规模的网络尤其重要，因为大规模的网络需要训练数天乃至数周的时长，一旦训练过程被中断或者发生死机等意外，之前训练的进度将全部丢失。如果能间断的保存模型状态到文件系统，即使发生意外，也可以从最近一次的网络状态文件中恢复，从而避免浪费大量的训练时间。因此模型的保存与加载非常重要。 1. checkpoint方式网络的状态主要体现在网络的结构以及网络层内部张量参数上，直接保存网络张量参数到文件上是最轻量级的一种方式，通过调用Model.save_weights(path)方法即可将当前的网络参数保存到path路径上。保存好参数文件后，在需要时，只需先创建好网络对象，然后调用网络对象的load_weights(path)方法即可将指定的模型文件中保存的张量数值写入当前网络参数中去 这种形式保存的文件格式是checkpoint的格式 这种保存与加载网络的方式最为轻量级，文件中保存的仅仅是参数的数值，并没有其他额外的结构参数，==但是它需要使用相同的网络结构才能够恢复网络状态，因此一般在拥有网络源文件的情况下使用== 2. h5方式这是一种不需要网络源文件，仅仅需要模型参数文件即可恢复出网络模型的方式。通过==Model.save(xxx.h5)函数==可以将模型的结构以及模型的参数保存到一个path文件上，在不需要网络源文件的条件下，==通过Keras.model.load_model(xxx.h5)函数==即可恢复网络结构和网络参数 如何查看网络结构？ 3. pb方式TensorFlow之所以能够被业界青睐，除了优秀的神经网络层API支持之外，还得益于它强大的生态系统，包括移动端和网页端的支持。当需要将模型部署到其他平台时，采用TensorFlow提出的SavedModel方式更具有平台无关性。通过tf.keras.experimental.export_saved_model(network,path)函数即可将模型以SavedModel方式保存到path目录中，保存好网络文件后，用户无需关心文件的保存格式，只需通过tf.keras.experimental.load_from_saved_model()函数即可恢复出网络结构和参数，方便各个平台能够无缝对接训练好的网络模型 4. 自定义类尽管Keras提供了很多的常用的网络层，但深度学习可以使用的网络层，对于需要创建自定义逻辑的网络层，可以通过自定义类来实现。在创建自定义网络层类时，需要继承来自layers.Layer基类；创建自定义的网络类，需要继承来自keras.Model基类，这样产生的自定义类才能够方便的利用Layer/Model基类提供的参数管理功能，同时也能够与其他的标准网络层类交互使用 1. 自定义网络层自定义的网络层，需要实现初始化__init__方法和前向传播逻辑call方法。以某个具体的自定义的网络层为例，假设需要的是一个没有偏置的全连接层，即bias=0，同时固定激活函数为Relu函数。尽管这可以通过标准的Dense层创建。 class MyDense(layers.Layer): def __init__(self,in_dim,ou_dim): \"super函数MyDense是子类，继承了layers.Layer这个父类\" super(MyDense, self).__init__() self.kernel = self.add_weight('w',[in_dim,ou_dim],trainable=True) self.bias = self.add_weight('b',[ou_dim],trainable=True) def call(self,inputs,training=None): out = inputs @ self.kernel + self.bias out = tf.nn.relu(out) return out trainable设置张量是否需要加入待优化变量，一般设置为True，因为反向传播时要更新参数，所以张量要处于监管状态 2. 自定义网络自定义的网络结构也可以像keras其他标准类一样，通过Sequential容器方便地包裹成一个网络模型，如：在上面创建的自定义网络层的基础上搭建网络结构 Network = Sequential([ MyDense(256,128), MyDense(128,64), MyDense(64,32), MyDense(32,10)]) Network.build(input_shape=(None,28*28)) Network.summary() 在一些情况下也需要通过继承基类来搭建任意逻辑的自定义网络结构，下面是自定义的网络结构 class MyModel(keras.Model): def __init__(self): super(MyModel,self).__init__() self.fc1 = MyDense(28*28,256) self.fc2 = MyDense(256,128) self.fc3 = MyDense(128,64) self.fc4 = MyDense(64,32) self.fc5 = MyDense(32,10) def call(self,inputs): x = self.fc1(inputs) x = tf.nn.relu(x) x = self.fc2(x) x = tf.nn.relu(x) x = self.fc3(x) x = tf.nn.relu(x) x = self.fc4(x) x = tf.nn.relu(x) x = self.fc5(x) return x 自定义网络的优点：Sequential容器也能实现一些网络的搭建，但是Sequential容器在前向传播是依次调用每个网络层的前向传播函数，灵活性一般，而自定义网络的前向逻辑可以任意定制 5. 模型乐园 对于常用的网络模型，如ResNet，VGG等，不需要手动搭建网络，可以直接从==keras.applications==子模块中调用这些经典模型，同时还可以通过设置weights参数加载预训练的网络参数。 1. 加载模型以ResNet50迁移学习为例，==一般将ResNet50去掉最后一层后的网络作为新任务的特征提取子网络，即利用ImageNet上面训练的特征提取方法迁移到我们自定义的数据集上，并根据自定义任务的类别追加一个对应数据类别数的全连接分类层==，从而可以在预训练网络的基础上可以快速、高效地学习新任务。 import tensorflow as tf from tensorflow import keras from tensorflow.keras import layers,Model,Sequential,losses,applications resnet = keras.applications.ResNet50(weights = 'imagenet',include_top = False) resnet.summary() x = tf.random.normal([4,224,224,3]) print(resnet(x)) 在keras中调用了这些常用网络模型后，可以再进行自定义神经网络，可以利用Sequential容器封装自己新的网络，如果不想再训练ResNet网络参数，==可以通过设置resnet.trainable=False可以选择冻结ResNet部分的网络参数，只训练新建的网络层，从而快速、高效完成网络模型的训练。== import tensorflow as tf from tensorflow import keras from tensorflow.keras import layers,Model,Sequential,losses,optimizers,applications resnet = keras.applications.ResNet50(weights = 'imagenet',include_top = False) x = tf.random.normal([4,224,224,3]) global_average_layer = layers.GlobalAveragePooling2D() fc = layers.Dense(100) mynet = Sequential([resnet,global_average_layer,fc]) mynet(x) 6. 测量工具在网络的训练过程中，经常需要统计准确率，召回率等信息，除了可以通过手动计算并平均方式获取统计数据外，Keras提供了一些常用的测量工具Keras.metrics，专门用于统计训练过程中需要的指标数据。 1. 新建测量器在==Keras.metrics模块==下，提供了较多的常用的测量类，如统计平均值的Mean类等等。以统计误差为例，在前向运算时，我们会得到每一个batch的平均误差，但是我们希望统计一个epoch的平均误差，因此我们选择使用Mean测量器： loss_meter = metrics.Mean() 2. 写入数据通过测量器的==update_state函数==可以写入新的数据： loss_meter.update_state(float(loss)) 上述的代码记录采样的数据，上述采样代码放置在每个batch运算完成后，测量器会自动根据采样的数据来统计平均值。 3. 读取统计信息在采样多次后，可以通过测量器的==result()函数==获取统计值： print(step,'loss:',loss_meter.result()) 4. 清除由于测量器会统计所有历史记录的数据，因此在合适的时候有必要清除历史状态，通过==reset_states()函数==即可实现。在每次读取完统计信息后，清零统计信息，以便下一轮统计的开始： if step%100 ==0: print(step,'loss:',loss_meter.result()) loss_meter.reset_states() 7. 可视化在网络训练的过程中，通过Web端监控网络的训练进度，可视化网络的训练结果对于提高开发效率是非常重要的。TensorFlow提供了一个专门的可视化工具，叫做TensorBorad，它可以通过TensorFlow将监控数据写入到文件系统，并利用Web后端监控对应的文件目录，从而可以允许用户从远程查看网络的监控数据TensorBoard的使用需要训练部分和浏览器交互工作 1. 模型端在模型端，需要创建写入监控数据的Summary类，并在需要的时候写入监控数据，首先通过==tf.summary.create_file_writer==创建监控对象，并制定监控数据的写入目录： “创建监控类，监控数据将写入log_dir目录” summary_writer = tf.summary.create_file_write(log_dir) 以监控误差数据和可视化图片数据为例，介绍如何写入监控数据。在前向计算完成后，对于误差这种标量数据，可以通过==tf.summary.scalar函数==记录监控数据，并指定时间戳step： summary_writer = tf.summary.create_file_writer(log_dir) with summary_writer.as_default(): tf.summary.scalar('train-loss',float(loss),step=step) TensorBroad通过字符串ID来区分不同类别的监控数据，因此对于误差数据，将其命名为“train-loss”，其他类的数据不可写入此对象，防止数据污染。 效果如下图： 对于图片类型的数据，可以通过==tf.summary.image函数==写入监控图片数据： summary_writer = tf.summary.create_file_writer(log_dir) with summary_writer.as_default(): tf.summary.scalar('test-acc',float(total_correct/total)，step=step) \"可视化测试用的图片，设置最多可视化9张图片\" tf.summary,image(\"val-onebyone-images:\",val_images,max_outputs=9,step=step) 2. 浏览器端在运行程序时，通过运行tensorboard–logdir path指定Web后端监控的文目录path，此时打开浏览器，输入网址http://localhost:6006即可监控网络训练进度。TensorBoard可以同时显示多条监控记录，在监控页面的左侧可以选择监控记录 在监控页面的上端还可以选择不同类型数据的监控页面，比如标量监控页面SCALARS，图片可视化页面IMAGES等。如图所示：","categories":[{"name":"Tensorflow框架学习笔记","slug":"Tensorflow框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Tensorflow%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"3. TensorFlow2.0神经网络实现","slug":"3. TensorFlow2.0神经网络实现","date":"2022-09-09T07:13:36.963Z","updated":"2022-09-09T07:13:36.964Z","comments":true,"path":"2022/09/09/3.tensorflow2.0-shen-jing-wang-luo-shi-xian/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/3.tensorflow2.0-shen-jing-wang-luo-shi-xian/","excerpt":"","text":"Tensorflow搭建神经网络 机器学习的目的是为了训练出一组参数使得训练模型最好地学习到一种映射关系，使得训练模型通过这种关系能很好地去预测新的样本 1. 感知机（Perceptron） 感知机就是一种线性模型，这是早期的网络模型，通过线性映射可以解决一些简单的视觉分类任务，比如区分三角形，圆形，矩形等。 感知机模型如下： 它接受长度为$n$的一维向量$\\boldsymbol{x}=\\left[x_{1}, x_{2}, \\ldots, x_{n}\\right]$，每个输入节点通过权值为$\\boldsymbol{w_i,i\\in[1,n]}$ 连接相加得：$\\boldsymbol{z=w_{1} x_{1}+w_{2} x_{2}+\\cdots+w_{n} x_{n}+b}$，其中$b$称为 感知机的偏置（bias），$\\boldsymbol{z}$称为感知机的==净活性值==，写成向量形式：$$\\boldsymbol{z=\\boldsymbol{w}^{T} \\boldsymbol{x}+b}$$ 感知机并不能处理非线性的问题，因此要加入激活函数后得到==活性值==：$$\\boldsymbol{a=\\sigma(z)=\\sigma\\left(\\boldsymbol{w}^{T} \\boldsymbol{x}+b\\right)}$$ 此时的激活函数还是一些像是阶跃函数，符号函数等不连续的函数. 2. 全连接层 感知机模型的不可导特性严重约束了它的潜力，使得它只能解决极其简单的任务。实际上，现代深度学习动辄数百万甚至上亿的参数规模，它的核心结构与感知机并没有多大差别，它在感知机的基础上，将不连续的阶跃激活函数换成了其他平滑连续激活函数，并通过堆叠多层网络层来增强网络的表达能力 全连接层模型如下： 假设现有两个样本，$\\boldsymbol{x^{1}=\\left[x_{1}^{1}, x_{2}^{1}, x_{3}^{1}\\right], \\quad x^{2}=\\left[x_{1}^{2}, x_{2}^{2}, x_{3}^{2}\\right]}$，通过权重矩阵相乘连接，再与偏置相加，得到：$$\\boldsymbol{\\left[\\begin{array}{cc}o_{1}^{1} &amp; o_{2}^{1} \\o_{1}^{2} &amp; o_{2}^{2}\\end{array}\\right]=\\left[\\begin{array}{ccc}x_{1}^{1} &amp; x_{2}^{1} &amp; x_{3}^{1} \\x_{1}^{2} &amp; x_{2}^{2} &amp; x_{3}^{2}\\end{array}\\right] @\\left[\\begin{array}{cc}W_{11} &amp; W_{12} \\W_{21} &amp; W_{22} \\W_{31} &amp; W_{32}\\end{array}\\right]+\\left[\\begin{array}{cc}b_{0} &amp; b_{1}\\end{array}\\right]}$$ 可以看出输出矩阵中的每个输出节点 $\\boldsymbol{o_i^j}$ 都与全部输入节点连接，这种网络层叫做全连接层 1. 张量方式实现X = tf.random.normal([2,784]) W1 = tf.Variable(tf.random.truncated_normal([784,256])) b1 = tf.Variable(tf.zeros([256])) o1 = tf.matmul(X,W1) + b1 o1 = tf.nn.relu(o1) # 激活函数 print(o1) 2. 层方式实现 from tensorflow.keras import layers 全连接层本质上就是矩阵的相乘相加运算，可以直接通过张量来实现，但是TensorFlow中有更加高层，使用更方便的层实现方式：layer.Dense(units，activation)==只需要指定输出节点数units和激活函数类型即可。== 运行“黑匣子”：输入节点数将根据第一次运算时的输入shape确定，同时根据输入、输出节点数==自动创建并初始化权值矩阵$\\boldsymbol{W}$和偏置向量$\\boldsymbol{b}$==，使用非常方便。 x = tf.random.normal([4,28*28]) fc = layers.Dense(512,activation=tf.nn.relu) # 创建全连接层，指定输出节点数和激活函数 h1 = fc(x) # 通过fc类完成一次全连接层的计算 print(h1) OUT： tf.Tensor( [[0.4445603 0. 0. ... 0. 0. 1.9244801 ] [0.37167704 0.5069377 0.03083919 ... 0. 2.0557394 0. ] [0. 0.9400093 0. ... 0. 1.136771 0.02230924] [2.4392984 0.14651556 0. ... 1.9309815 0. 0.8839622 ]], shape=(4, 512), dtype=float32) layer.Dense函数 创建一层全连接层，返回一个类，向这个类传入输入数据x，输入节点数在传入时获取，接着在类的内部创建权值矩阵$\\boldsymbol{W}$和$\\boldsymbol{b}$，可以通过类内部的成员名kernel和bias来获取权值矩阵$\\boldsymbol{W}$和$\\boldsymbol{b}$，在优化参数时，需要获得网络的所有待优化的参数张量列表，可以通过类的trainable_variables来返回待优化参数列表，non_trainable_variables成员返回所有不需要优化的参数列表，variable返回所有内部张量列表 x = tf.random.normal([4,28*28]) fc = layers.Dense(512,activation=tf.nn.relu) h1 = fc(x) print(h1,fc.kernel,fc.bias,fc.trainable_variables) 3. 全连接神经网络==前一层的输出节点数与当前层的输入节点数匹配，即可堆叠出任意层数的网络，这种由神经元构成的网络叫做神经网络== 全连接神经网络如下图： 1. 张量方式实现#layer1 w1 = tf.Variable(tf.random.normal([784,256],stddev=0.1)) b1 = tf.Variable(tf.zeros([256])) #layer2 w2 = tf.Variable(tf.random.normal([256,128],stddev=0.1)) b2 = tf.Variable(tf.zeros([128])) #layer3 w3 = tf.Variable(tf.random.normal([128,64],stddev=0.1)) b3 = tf.Variable(tf.zeros([64])) #output_layer w4 = tf.Variable(tf.random.normal([64,10],stddev=0.1)) b4 = tf.Variable(tf.zeros([10])) x = tf.random.normal([10,784]) with tf.GradientTape() as tape: \"梯度记录器\" h1 = x@w1 + tf.broadcast_to(b1,[x.shape[0],256]) h1 = tf.nn.relu(h1) h2 = h1@w2 + tf.broadcast_to(b2,[x.shape[0],128]) h2 = tf.nn.relu(h2) h3 = h2@w3 + tf.broadcast_to(b3, [x.shape[0], 64]) h3 = tf.nn.relu(h3) h4 = h3@w4 + tf.broadcast_to(b4,[x.shape[0],10]) gradients = tape.gradient([h1,h2,h3,h4],[w1,w2,w3,w4]) print(gradients) 将待优化张量用tf.Variable包裹起来，方便跟踪梯度的变化，而且==GradientTape==默认只监控由tf.Variable创建的trainable=True属性（默认）的变量，因此有时需要使用watch函数来引入监控梯度的变化，在使用TensorFlow自动求导功能计算梯度时，需要将前向计算过程放在tf.GradientTape()环境中，==从而利用GradientTape对象的gradient()方法自动求解参数的梯度，并用optimizers对象更新参数。== 另外，默认情况下GradientTape的资源在调用gradient函数后就被释放，再次调用就无法计算了。所以如果需要多次计算梯度，需要开启GradientTape（persistent=True）属性 2. 层方式实现x = tf.random.normal([10,728]) model = keras.Sequential([ keras.layers.Dense(256,activation=tf.nn.relu), keras.layers.Dense(128,activation=tf.nn.relu), keras.layers.Dense(64,activation=tf.nn.relu), keras.layers.Dense(10,activation=None)]) out = model(x) print(out) ==通过Sequential容器封装成一个网络大类对象，调用大类的前向计算函数即可完成所有层的前向计算== 3. 优化目标神经网络从输入到输出的计算过程叫做前向传播过程，也是数据张量（tensor）从第一层，途径每个隐藏层（flow），直至输出层的过程，这也是TensorFlow框架名字意义所在，前向传播的最后一步就是要优化参数，通过目标函数得到误差，利用==反向传播算法==向后传播参数 从另一个角度来理解神经网络，它完成的是特征的维度变换的功能，比如4层的MNIST手写数字图片识别的全连接神经网络，它依次完成了$\\boldsymbol{784 \\rightarrow 256 \\rightarrow 128 \\rightarrow 64 \\rightarrow 10}$的特征降维过程。原始的特征通常具有较高的维度，包含了很多底层特征及无用信息，通过神经网络的层层特征变换，将较高的维度降维到较低的维度，此时的特征一般包含了与任务强相关的高层特征信息，通过对这些特征进行简单的逻辑判定即可完成特定的任务 4. 输出层设计网络的最后一层除了和所有的隐藏层一样，完成维度变换、特征提取的功能，还作为输出层使用，需要根据具体的任务场景来决定是否使用激活函数，以及使用什么类型的激活函数 ==根据任务场景的不同输出值也会不同，我们根据输出值二点区间范围来分类讨论：== $\\boldsymbol{o \\in R^d}$输出属于整个实数空间，或者某段普通的实数空间，比如函数值趋势的预测，年龄额预测问题 $\\boldsymbol{o \\in[0,1]}$输出值特别地落在$\\boldsymbol{[0,1]}$的区间，如图片生成，图片像素值一般用$\\boldsymbol{[0,1]}$表示；或者二分类问题的概率，如硬币正反面的概率预测问题 $\\boldsymbol{o \\in [0,1],\\sum_io_i=1}$输出值落在$\\boldsymbol{[0,1]}$的区间，并且所有输出值之和为1，常见的如多分类问题，如MNIST手写数字图片识别，图片属于10个类别的概率之和为1，主要用于多分类任务 $\\boldsymbol{o \\in [-1,1]}$输出值在$\\boldsymbol{[-1,1]}$之间 5. 损失函数设计 常见的误差计算函数有均方误差、交叉熵、KL散度、Hinge Loss函数等。 1. 均方差将输出向量（预测）和真实向量映射到直角坐标系的两个点上，计算两个点之间的欧氏距离来衡量两个向量之间的差距：$$\\boldsymbol{\\mathrm{MSE}:=\\frac{1}{d_{\\text {out}}} \\sum_{i=1}^{d_{\\text {out}}}\\left(y_{i}-o_{i}\\right)^{2}}$$ MSE误差函数的值总是大于等于0，==当MSE误差函数达到最小值0时，输出等于真实标签，此时神经网络的参数达到最优状态。== 张量形式实现 o = tf.random.normal([2,10]) y_onehot = tf.constant([1,3]) y_onehot = tf.one_hot(y_onehot,depth = 10) loss = keras.losses.MSE(y_onehot,o) print(loss) OUT： tf.Tensor([0.87758476 0.5987398 ], shape=(2,), dtype=float32) keras.MSE函数返回的是每个样本的均方差，需要在样本数量上再次平均来获得batch的均方差 层形式实现 o = tf.random.normal([2,10]) y_onehot = tf.constant([1,3]) y_onehot = tf.one_hot(y_onehot,depth = 10) criteon = keras.losses.MeanSquaredError() loss = criteon(y_onehot,o) print(loss) OUT： tf.Tensor(0.907153, shape=(), dtype=float32) MSE函数对应的类keras.losses.MeanSquaredError(pred,label) 2. 交叉熵 熵的概念：熵越大，代表不确定性越大，信息量也就越大 熵计算：$$\\boldsymbol{H(P):=-\\sum_{i} P(i) \\log {2} P(i)}$$交叉熵的计算：$$\\boldsymbol{H(p, q):=-\\sum{i=n} p(i) \\log {2} q(i)}$$通过变换，交叉熵可以分解为p的熵$\\boldsymbol{H(p)}$与$\\boldsymbol{p,q}$的KL散度的和：$$\\boldsymbol{H(p, q)=H(p)+D{K L}(p | q)}$$其中KL的定义为：$$\\boldsymbol{D_{K L}(p | q)=\\sum_{x \\in \\mathcal{X}} p(x) \\log \\left(\\frac{p(x)}{q(x)}\\right)}$$KL散度是用于衡量两个分布之间距离的指标，$\\boldsymbol{p=q}$ 时，$\\boldsymbol{D_{KL}(p|q)}$ 取得最小值0.需要注意的是，交叉熵和KL散度都不是对称的：$$\\boldsymbol{\\begin{aligned}H(p, q) &amp; \\neq H(q, p) \\D_{K L}(p | q) &amp; \\neq D_{K L}(q | p)\\end{aligned}}$$交叉熵可以很好地衡量2个分布之间的差别，特别地，当分类问题中y的编码分布p采用one_hot编码时，$\\boldsymbol{H(y)=0}$,此时$$\\boldsymbol{H(\\boldsymbol{y}, \\boldsymbol{o})=H(\\boldsymbol{y})+D_{K L}(\\boldsymbol{y} | \\boldsymbol{o})=D_{K L}(\\boldsymbol{y} | \\boldsymbol{o})}$$退化到真实标签分布 $\\boldsymbol{y}$ 与输出概率分布 $\\boldsymbol{o}$ 之间的KL散度上，根据KL散度的定义，我们推导分类问题中交叉熵的计算表达式：$$\\boldsymbol{H(y,o)=D_{KL}(y|o)=\\sum_jy_j\\log(\\frac{y_j}{o_j})=1\\log\\frac{1}{o_i}+\\sum_{j\\ne i}0\\log(\\frac{0}{o_j})=-\\log o_i}$$其中 $\\boldsymbol{i}$ 为one-hot编码中为1的索引号，也是当前输入的真实类别。可以看到，交叉熵损失函数只与真实类别$\\boldsymbol{i}$上的概率$\\boldsymbol{o_i}$有关，对应概率$\\boldsymbol{o_i}$越大，$\\boldsymbol{H(y,o)}$越小，当对应概率为1时，交叉熵$\\boldsymbol{H(y,o)}$取得最小值0，此时网络输出$\\boldsymbol{o}$与真实标签$\\boldsymbol{y}$完全一致，神经网络取得最优状态。 最小化交叉熵的过程也是最大化正确类别的预测概率的过程。 纯概念了，具体实现方法还需再查一下资料 6. 神经网络类型 ==全连接层是神经网络最基本的网络类型，对后续神经网络类型的研究有巨大的贡献，全连接层前向计算简单，梯度求导也较简单，但是在处理较大特征长度的数据时，全连接层的参数量往往较大，使得训练深层数的全连接层网络比较困难。下面是一系列神经网络变种类型== 卷积神经网络 循环神经网络 注意力（机制）网络 图神经网络","categories":[{"name":"Tensorflow框架学习笔记","slug":"Tensorflow框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Tensorflow%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"2. TensorFlow2.0进阶","slug":"2. TensorFlow2.0进阶","date":"2022-09-09T07:13:36.958Z","updated":"2022-09-09T07:13:36.959Z","comments":true,"path":"2022/09/09/2.tensorflow2.0-jin-jie/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/2.tensorflow2.0-jin-jie/","excerpt":"","text":"TensorFlow2.0进阶1. 合并与分割1. 合并合并是指将多个张量在某个维度上合并为一个张量。 以某学校班级成绩册数据为例，设张量$A$保存了1~4号班机的成绩册，每个班级35个学生，共8门科目，则张量A的shape为$[4,35,8]$； 同样的方式，张量$B$保存了剩下的6个班级的成绩册，shape为$[6,35,8]$，为了得到全校的成绩册，需要合并这两个张量，便可以得到包含全校学生成绩的成绩册张量$C$，shape为$[10,35,8]$ 张量的合并可以通过拼接和堆叠操作来实现，拼接不会产生新的维度，堆叠会创建新的维度，选择使用拼接还是堆叠操作来合并张量，取决于具体的场景是否需要创建新的维度。 拼接 拼接操作可以在任意的维度上进行，唯一的约束是==非合并维度的长度必须一致==。通过**tf.concat(tensors,axis)**来实现，==注意的是concat是将tensor元组中后面的元素合并到前面的元素后面== a = tf.random.normal([4,35,8]) b = tf.random.normal([6,35,8]) c = tf.concat([a,b],axis=0) # tensor参数用方括号包起来，axis表示在哪个维度上合并 print(c.shape) OUT:(10, 35, 8) 堆叠 继续以学生成绩册为例：假设张量$A$保存了某个班的成绩册，shape为$[35,8]$ 张量$B$保存了另一个班级的成绩册，shape为$[35,8]$,合并这两个班的数据时，需要创建一个新维度，定义为班级数量维度，且新维度可以选择放置在任意位置，一般根据大小维度的经验法则，将较大概念的班级维度放置在学生维度之前，则合并后的张量的新shape为$[2,35,8]$ 如果在合并数据时，希望创建一个新的维度，则需要使用tf.stack(tensors,axis)来实现，tf.stack也需要满足张量堆叠合并条件，需要==所有合并的张量的shape完全一致==才可以合并 a = tf.random.normal([35,8]) b = tf.random.normal([35,8]) c = tf.stack([a,b],axis=0) print(c.shape) OUT:(2, 35, 8) 2. 分割分割是合并操作的逆操作，继续以学生成绩册为例：假设现在有全校的成绩册。shape为$[10,35,8]$，需要将每个班级的成绩册分离出来，保存在每个张量中 通过**tf.split(x,axis,num_or_size_splits)**来实现 x 表示待分割张量 axis 表示分割的维度索引号 num_or_size_splits 表示切割方案，若为单个数值时，表示切割的份数，当为list时，每个元素表示每份的长度，如$[2,4,2,2]$表示切割为4份，每份的长度为2，4，2，2 x = tf.random.uniform([2, 3, 4, 5], maxval=100, dtype=tf.int32) print(x) x = tf.split(x, axis=0, num_or_size_splits=2) print(x) OUT: tf.Tensor( [[[[71 26 63 6 53] [99 38 5 99 20] [40 99 65 54 18] [59 90 62 7 82]] [[68 6 86 3 47] [ 4 58 61 73 46] [71 94 46 62 93] [ 0 10 7 60 16]] [[18 35 34 67 8] [23 98 68 55 79] [23 79 88 5 84] [93 49 11 31 12]]] [[[42 3 15 37 55] [ 5 7 41 31 37] [88 66 79 59 27] [27 57 64 44 33]] [[85 76 34 22 50] [ 7 88 46 80 16] [ 8 16 26 43 37] [56 83 28 96 76]] [[ 2 0 48 17 29] [20 0 25 52 3] [36 67 5 43 84] [18 80 93 27 93]]]], shape=(2, 3, 4, 5), dtype=int32) [&lt;tf.Tensor: shape=(1, 3, 4, 5), dtype=int32, numpy= array([[[[71, 26, 63, 6, 53], [99, 38, 5, 99, 20], [40, 99, 65, 54, 18], [59, 90, 62, 7, 82]], [[68, 6, 86, 3, 47], [ 4, 58, 61, 73, 46], [71, 94, 46, 62, 93], [ 0, 10, 7, 60, 16]], [[18, 35, 34, 67, 8], [23, 98, 68, 55, 79], [23, 79, 88, 5, 84], [93, 49, 11, 31, 12]]]])&gt;, &lt;tf.Tensor: shape=(1, 3, 4, 5), dtype=int32, numpy= array([[[[42, 3, 15, 37, 55], [ 5, 7, 41, 31, 37], [88, 66, 79, 59, 27], [27, 57, 64, 44, 33]], [[85, 76, 34, 22, 50], [ 7, 88, 46, 80, 16], [ 8, 16, 26, 43, 37], [56, 83, 28, 96, 76]], [[ 2, 0, 48, 17, 29], [20, 0, 25, 52, 3], [36, 67, 5, 43, 84], [18, 80, 93, 27, 93]]]])&gt;] 2. 数据统计在神经网络的计算过程中，经常需要统计数据的各种属性，如最大值，均值，范数等。由于张量的shape比较大，直接观察数据很难获得有用信息，TensorFlow提供了快速获得这些数据的途径 1. 向量范数向量范数是表征向量“长度”的一种度量方法，常用来表示张量的权值大小，梯度大小等。 $\\boldsymbol{L1}$范数，定义为向量$\\boldsymbol{x}$的所有元素绝对值之和$$\\boldsymbol{|x|{1}=\\sum{i}\\left|x_{i}\\right|}$$ $\\boldsymbol{L2}$范数，定义为向量$\\boldsymbol{x}$的所有元素的平方和，再开根号$$\\boldsymbol{|x|{2}=\\sqrt{\\sum{i}\\left|x_{i}\\right|^{2}}}$$ $\\boldsymbol{\\infty-}$范数，定义为向量$\\boldsymbol{x}$的所有元素绝对值的最大值$$\\boldsymbol{|x|_{\\infty}=\\max {i}\\left(\\left|x{i}\\right|\\right)}$$** 对于矩阵、张量，同样可以利用向量范数的计算公式，等价于将矩阵、张量打平成向量后计算 可以通过tf.norm(x,ord)求解张量的$\\boldsymbol{L1,L2,\\infty}$等范数，其中参数ord指定为1，2时计算$L1,L2$范数，指定为np.inf时计算$\\infty$范数 import tensorflow as tf import numpy as np x = tf.ones([2,2]) print(tf.norm(x,ord=1)) print(tf.norm(x,ord=2)) print(tf.norm(x,ord=np.inf)) OUT： tf.Tensor(4.0, shape=(), dtype=float32) tf.Tensor(2.0, shape=(), dtype=float32) tf.Tensor(1.0, shape=(), dtype=float32) 2. 最大最小值、均值、和可以通过**tf.reduce_max()，tf.reduce_min()，tf.reduce_mean()，tf.reduce_sum()**可以求解张量在某个维度上的最大、最小、均值、和，也可以求全局最大、最小、均值、和信息。 除了希望获取张量的最值信息，还希望获得最值所在的索引号，例如在分类任务的标签预测。考虑10分类问题，得到神经网络的输出张量out，shape为$[2,10]$，代表2个样本属于10个类别的概率，由于元素的位置索引代表了当前样本属于此类别的概率，预测时往往会选择概率值最大的元素所在的索引号作为样本类别的预测值，可以通过**tf.argmax(x,axis)，tf.argmin(x,axis)**来求解在axis轴上，x的最大值、最小值所在的索引号 tf.reduce_max(tensor,axis) x = tf.random.normal([5,5],mean=1,stddev=2) print(tf.reduce_max(x,axis=1)) tf.reduce_min(tensor,axis) x = tf.random.normal([5,5],mean=1,stddev=2) print(tf.reduce_min(x,axis=1)) **tf.reduce_mean(tensor,axis)**，在求解误差函数时，需要计算样本的平均误差，此时可以通过tf.reduce_mean在样本数维度上计算均值 x = tf.random.normal([5,5],mean=1,stddev=2) print(tf.reduce_mean(x,axis=1)) **tf.reduce_sum(tensor,axis)**，与均值函数相似，可以求解张量在axis轴上所有特征的和 x = tf.random.normal([5,5],mean=1,stddev=2) print(tf.reduce_sum(x,axis=1)) tf.argmax(tensor,axis) x = tf.random.normal([5,5],mean=1,stddev=2) print(tf.argmax(x,axis=1)) tf.argmin(tensor,axis) x = tf.random.normal([5,5],mean=1,stddev=2) print(tf.argmin(x,axis=1)) 3. 张量比较为了计算分类任务的准确率（acc）等指标，一般需要将预测结果和真实标签比较，统计比较结果中正确的数量来计算准确率。 可以通过**tf.equal(a,b)或tf.math.equal(a,b)**来比较这2个张量是否相等 但是**tf.equal()**函数返回布尔型的张量比较结果，需要统计张量中True的个数，就知道预测正确的个数。为了达到这个目的，我们先将布尔型转换为整形张量 常用比较函数 函数 功能 tf.math.greater() $a&gt;b$ tf.math.less() $a&lt;b$ tf.math.greater_equal() $a\\ge b$ tf.math.less_equal() $a\\le b$ tf.math.not_equal() $a\\ne b$ tf.math.is_nan() $a=nan$ 4. 填充与复制1. 填充对于图片数据的高和宽、序列信号的长度，维度长度可能各不相同。为了方便网络的并行计算，需要将不同长度的数据扩张为相同长度。 在==TensorFlow基础中介绍的数据复制==可以增加数据的长度，但是重复复制数据会破坏原有的数据结构，并不适合于此处，==通常做法是，在需要补充长度的信号开始或结束处填充足够数量的特定数值，如0，使得填充后长度满足系统要求。== 填充操作可以通过**tf.pad(x,paddings)**函数实现，paddings是包含了多个$[left Padding,Right padding]$的嵌套方案list 如$\\begin{bmatrix}\\begin{bmatrix}0,0\\end{bmatrix},\\begin{bmatrix}2,1\\end{bmatrix},\\begin{bmatrix}1,2\\end{bmatrix}\\end{bmatrix}$表示第一个维度不填充，第二个维度左边(起始处)填充两个单元，右边(结束处)填充一个单元，第三个维度左边填充一个单元，右边填充两个单元 a = tf.constant([1,2,3,4,5,6]) b = tf.constant([7,8,1,6]) b = tf.pad(b,[[0,2]]) print(b) c = tf.stack([a,b],axis=0) print(c) OUT： tf.Tensor([7 8 1 6 0 0], shape=(6,), dtype=int32) tf.Tensor( [[1 2 3 4 5 6] [7 8 1 6 0 0]], shape=(2, 6), dtype=int32) 第一个列表表示第一维的左右，数值表示左右填充多少个单元 2. 复制在TensorFlow中已经介绍了数据复制的相关知识，在此再复习一遍，就是通过**tf.tile(tensor，multiples)**函数来实现，multiples为一个列表，分别指明了各维度上的数据复制多少次 a = tf.constant([[[1,2,3],[4,5,6],[7,8,9]],[[9,9,9],[8,8,8],[7,7,7]],[[1,1,1],[2,2,2],[3,3,3]]]) print(a) a = tf.tile(a,multiples=[1,2,3]) print(a) OUT: tf.Tensor( [[[1 2 3] [4 5 6] [7 8 9]] [[9 9 9] [8 8 8] [7 7 7]] [[1 1 1] [2 2 2] [3 3 3]]], shape=(3, 3, 3), dtype=int32) tf.Tensor( [[[1 2 3 1 2 3 1 2 3] [4 5 6 4 5 6 4 5 6] [7 8 9 7 8 9 7 8 9] [1 2 3 1 2 3 1 2 3] [4 5 6 4 5 6 4 5 6] [7 8 9 7 8 9 7 8 9]] [[9 9 9 9 9 9 9 9 9] [8 8 8 8 8 8 8 8 8] [7 7 7 7 7 7 7 7 7] [9 9 9 9 9 9 9 9 9] [8 8 8 8 8 8 8 8 8] [7 7 7 7 7 7 7 7 7]] [[1 1 1 1 1 1 1 1 1] [2 2 2 2 2 2 2 2 2] [3 3 3 3 3 3 3 3 3] [1 1 1 1 1 1 1 1 1] [2 2 2 2 2 2 2 2 2] [3 3 3 3 3 3 3 3 3]]], shape=(3, 6, 9), dtype=int32) 5. 数据限幅非线性激活函数ReLU函数其实可以通过简单的数据限幅运算实现的，限制数据的范围$\\boldsymbol{x\\in[0,+\\infty]}$即可 **tf.maximum(x,a)实现数据的下限幅$\\boldsymbol{x\\in[a,+\\infty]}$；通过tf.minimum(x,a)**实现数据上限幅$\\boldsymbol{x\\in[-\\infty,a]}$ x = tf.range(9) print(tf.maximum(x,2)) OUT: tf.Tensor([2 2 2 3 4 5 6 7 8], shape=(9,), dtype=int32) 更方便的，我们可以使用**tf.clip_by_value()**函数来实现上下限幅 超过限幅的值将使用限幅来代替 6. 数据采样上述操作都是比较简单的操作，接下来就要介绍一些复杂一点的功能函数 tf.gather(tensor，[index]，axis) **tf.gather()**可以==实现根据索引号收集数据的目的==。 例如：班级成绩册的例子，共有4个班级，每个班级35个学生，8门科目，保存成绩册的张量的shape为$[4,35,8]$，现在需要收集第1~2个班级的成绩册，可以给定需要收集班级的索引号：[0,1]，班级维度为axis=0 x = tf.random.normal([4,35,8]) a = tf.gather(x,[0,1],axis=0) print(a.shape) OUT： (2, 35, 8) **tf.gather()**非常适合索引没有规则的场合，其中索引号可以乱序排序，此时收集的数据也是对应顺序 x = tf.range(9) a = tf.reshape(x,[3,3]) print(a) print(tf.gather(a,[0,2,1],axis=0)) OUT： tf.Tensor( [[0 1 2] [3 4 5] [6 7 8]], shape=(3, 3), dtype=int32) tf.Tensor( [[0 1 2] [6 7 8] [3 4 5]], shape=(3, 3), dtype=int32) **tf.gather()**可以组合起来使用，来索引多维数据中的某个数据，继续以学生成绩册为例，抽查第2~3班的3，4，6，27号学生的成绩 x = tf.random.uniform([4,35,8],minval=0,maxval=100,dtype=tf.int32) class_1 = tf.gather(x,[1,2],axis=0) print(class_1.shape) students = tf.gather(class_1,[3,4,6,27],axis=1) print(students) OUT： (2, 35, 8) tf.Tensor( [[[90 81 88 55 17 23 9 18] [36 61 39 16 46 84 76 21] [81 67 5 33 70 52 76 74] [99 67 3 1 47 18 35 20]] [[83 62 1 39 54 18 54 93] [83 28 47 84 69 5 88 8] [10 59 85 6 67 64 99 76] [52 84 60 44 33 26 80 23]]], shape=(2, 4, 8), dtype=int32) tf.gather_nd(tensor，[index_list]) 通过tf.gather_nd(),可以通过指定每次采样的坐标来实现采样多个点的目的，实现多维度坐标收集数据 继续以学生成绩册为例，我们希望抽查第2个班级的第2个同学的所有科目，第3个班级的第3个同学的所有科目，第4个班级的第4个同学的所有科目的成绩，这3个采样点的索引坐标可以记为：$[1,1]，[2,2]，[3,3]$，我们将这3个采样点的索引合并为一个List$[[1,1]，[2,2],[3,3]]$ x = tf.random.uniform([4,35,8],minval=0,maxval=100,dtype=tf.int32) print(tf.gather_nd(x,[[1,1],[2,2],[3,3]])) OUT: tf.Tensor( [[ 3 42 28 94 98 37 19 69] [70 56 89 85 6 26 95 41] [ 3 88 85 66 82 21 98 93]], shape=(3, 8), dtype=int32) tf.boolean_mask(tensor，[mask_list]，axis) 除了可以通过给定索引号的方式采样，还可以通过给定掩码（mask）的方式采样，但是要==注意掩码的长度必须与对应维度的长度一致==，继续以学生成绩册为例，在班级维度上采样 x = tf.random.uniform([4,35,8],minval=0,maxval=100,dtype=tf.int32) print(tf.boolean_mask(x,mask=[True,False,False,True],axis=0).shape) OUT： (2, 35, 8) 多维掩码 x = tf.random.uniform([2,4],minval=0,maxval=100,dtype=tf.int32) print(x) print(tf.boolean_mask(x,mask=[[True,False,False,True],[True,False,False,True]])) OUT： tf.Tensor( [[12 66 5 66] [59 56 56 55]], shape=(2, 4), dtype=int32) tf.Tensor([12 66 59 55], shape=(4,), dtype=int32) tf.where(cond，tensor_a，tensor_b) 可以通过cond条件的真假从tensor_a或tensor_b中读取数据，判断条件： $$\\boldsymbol{o_{i}=\\left{\\begin{array}{ll}a_{i} &amp; \\text { cond }{i} \\text { 为True } \\ b{i} &amp; \\text { cond }_{i} \\text { 为False }\\end{array}\\right.}$$其中$i$为张量的索引，返回张量大小与$a,b$张量一致，相当于条件选择语句，如果$cond_i$为True，则选择从$a_i$中复制数据，否则从$b_i$中复制数据当$a=b=None$时，即$a，b$参数不指定时，tf.where会返回cond张量中所有True的元素的索引坐标 c = tf.where([[True,False,True],[False,True,True],[True,True,True]]) print(c) OUT： tf.Tensor( [[0 0] [0 2] [1 1] [1 2] [2 0] [2 1] [2 2]], shape=(7, 2), dtype=int64) 那么返回索引值的坐标有什么用呢？假设我们需要提取张量中所有正数的数据和索引： 首先创建张量a，并通过比较运算（tf.equal()）得到所有正数的位置掩码，然后将掩码输入tf.where不指定任何张量，tf.where返回掩码为True的索引位置列表，接着将这个列表输入tf.gather_nd来获取所有的正数，实际上，在得到mask索引后，也可以直接通过tf.boolean_mask获取对应元素 a = tf.random.normal([3,3],mean=1,stddev=2) zero = tf.zeros([3,3]) mask = tf.math.greater_equal(a,zero) # 获取掩码 index = tf.where(mask) num = tf.gather_nd(a,index) print(num) OUT： tf.Tensor([4.1355724 1.3075178 0.77469975 0.83479714], shape=(4,), dtype=float32) tf.scatter_nd(indices，updatas，shape) 通过该函数可以高效地刷新张量的部分数据，但是只能在全0张量的白板上刷新，因此可能需要结合其他操作来实现现有张量的数据刷新功能 一维张量白板的刷新运算白板的形状表示为shape参数，需要刷新的数据索引为indices，新数据为updates，其中每个需要刷新的数据对应在白板中的位置，根据indices给出的索引位置将updates中新的数据依次写入白板中并返回更新后的白板张量。 import tensorflow as tf indices = tf.constant([[4],[3],[1],[7]]) updates = tf.constant([4.4,3.3,1.1,7.7]) print(tf.scatter_nd(indices,updates,[8])) OUT: tf.Tensor([0. 1.1 0. 3.3 4.4 0. 0. 7.7], shape=(8,), dtype=float32) 三维张量白板的刷新运算 indices = tf.constant([[1],[3]]) updates = tf.constant([[[5,5,5,5,],[6,6,6,6],[7,7,7,7],[8,8,8,8]],[[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]]]) print(tf.scatter_nd(indices,updates,[4,4,4])) OUT: tf.Tensor( [[[0 0 0 0] [0 0 0 0] [0 0 0 0] [0 0 0 0]] [[5 5 5 5] [6 6 6 6] [7 7 7 7] [8 8 8 8]] [[0 0 0 0] [0 0 0 0] [0 0 0 0] [0 0 0 0]] [[1 1 1 1] [2 2 2 2] [3 3 3 3] [4 4 4 4]]], shape=(4, 4, 4), dtype=int32) tf.meshgrid(x,y) 如果想要绘制3D图，通过该函数能方便地生成二维网络采样点坐标，方便可视化等应用场合。 x = np.linespace(-8,8,100) #设置x坐标的间隔 y = np.linespace(-8,8,100) #设置y坐标的间隔 x,y = tf.meshgrid(x,y) #生成网格点，并拆分后返回","categories":[{"name":"Tensorflow框架学习笔记","slug":"Tensorflow框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Tensorflow%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"1. Tensorflow2.0基础","slug":"1. Tensorflow2.0基础","date":"2022-09-09T07:13:36.948Z","updated":"2022-09-09T07:13:36.949Z","comments":true,"path":"2022/09/09/1.tensorflow2.0-ji-chu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/1.tensorflow2.0-ji-chu/","excerpt":"","text":"Tensorflow2.0基础知识1. 数据类型1. 数值型张量Tensor是Tensorflow的主要数据载体，它可能为： 标量（Scalar）：单个的实数 向量（Vector）：n个实数的有序集合，通过中括号包裹 矩阵（Matrix）：n行m列实数的有序集合，如 $[[1,2][3,4]]$,每个维度上的长度不定，shape为[n,m] 张量（Tensor）：所有维度数dim&gt;2的数组统称为张量。张量的每个维度也叫做轴（axis），一般维度代表了具体的物理含义，比如shape为[2，32，32，3]共有四个维度，如果表示图片数据的话，每个维度代表的含义分别是图片数量、图片高度、图片宽度、图片通道数，当然张量的维度数以及每个维度所代表的具体物理含义需要用户自行定义 创建标量： tf.constant(1.2) 创建张量： tf.constant([1, 2., 3.3]) 创建矩阵： tf.constant([[[1,2],[3,4]],[[4,5],[6,7]]]) 张量是一个对象，使用print打印其信息时会出现它包含的信息，它也有特有的方法，如：x =tf.constant([1, 2., 3.3]) ，而x.numpy()则是将tensor中的数据返回为Numpy.array类型的数据，这是为了方便将数据导出到系统的其他模块 2. 字符串类型在Tensorflow中创建字符串类型的张量，tf.string模块中提供了常见字符串型的工具函数，但字符型类型在Tensorflow中使用不多 a = tf.constant(\"Hello world!\") 说实话，没怎么使用过这个功能，不知道是不是底层会使用，我觉得是微软想要大家直接使用Tensorflow就可以，而不需要使用标准库的函数。而且tf.string库里面包含了很多类似join()、length()、split()等函数 3. 布尔类型需要注意的是，Tensorflow的布尔类型和python语言的布尔类型并不对等 \"布尔类型\" a = tf.constant(True) \"布尔类型的向量\" a = tf.constant([True,False]) 2. 数值精度1. 精度类型对于数值类型的张量，可以保持为不同字节长度的精度，如浮点数3.14既可以保存为16—bit长度，也可以保存为32—bit甚至64—bit的精度。bit越长，精度越高，同时占用的内存空间也就越大。常用的精度类型有：tf.int16，tf.int32，tf.int64，tf.float16，tf.float32 print(tf.constant(123456789,dtype=tf.int16),tf.constant(123456789,dtype=tf.int32)) OUt:tf.Tensor(-13035, shape=(), dtype=int16) tf.Tensor(123456789, shape=(), dtype=int32) #第一个保存精度过低导致溢出，对于浮点数，高精度的张量可以表示更精准的数据 2. 读取精度通过访问张量得到dtype成员属性可以判断张量的保存精度 a = tf.constant(1,dtype=tf.float16) print(a.dtype) OUT： &lt;dtype: 'float16'&gt; 3. 精度转换对于不符合要求的张量的类型及精度，需要通过**tf.cast()**函数进行转换 if a.dtype != tf.float32: a = tf.cast(a,tf.float32) print(a.dtype) OUT: &lt;dtype: 'float32'&gt; \"布尔型与整形之间相互转换\" a = tf.constant([True,False]) tf.cast(a,tf.int16) print(a) OUT: tf.Tensor([1 0], shape=(2,), dtype=int16) 3. 待优化张量为了区分需要计算梯度信息的张量与不需要计算梯度信息的张量，Tensorflow增加了一种专门的数据类型来支持梯度信息的记录：tf.Variable tf.Variable类型在普通的张量类型基础上添加了name，trainable等属性来支持计算图的构建。由于梯度运算会消耗大量的计算资源，而且会自动更新相关参数，对于不需要的优化的张量，如神经网络的输入X，不需要通过tf.Variable封装；相反，==对于需要计算梯度并优化的张量，如神经网络层的W和b，需要通过tf.Variable包裹以便Tensorflow跟踪相关梯度信息。name属性用于命名计算图中的变量，这套命名体系是TensorFlow内部维护的，trainable表征当前张量是否需要被优化，创建Variable对象是默认启用优化标志，可以设置trainable=False来设置张量不需要优化== 对于计算图将在后面进行解释 a = tf.constant([-1,0,1,2]) aa = tf.Variable(a) print(aa.name,aa.trainable) OUT： Variable:0 True 除了通过普通张量的方式创建Variable，也可以直接创建 a = tf.Variable([[1,2],[3,4]]) print(a) OUT： &lt;tf.Variable 'Variable:0' shape=(2, 2) dtype=int32, numpy= array([[1, 2], [3, 4]])&gt; Numpy Array数组和Python List是Python程序中非常重要的数据载体容器，很多数据都是通过Python语言将数据加载至Array或者List容器中，再转换为Tensor类型，通过TensorFlow运算处理后导出到Array或者List容器中，方便其他模块使用。 tf.convert_to_tensor可以创建新Tensor，并将保存在Python List对象或Numpy Array对象中的数据导入代新的Tensor中，实际上，**tf.constant()和tf.Variable()以及tf.convert_to_tensor()**都可以自动二点把Numpy数组或Python List数据类型转化为Tensor类型，使用其一即可。 arr = np.array([[1., 2., 3.], [4., 5., 6.]]) print(arr) a = tf.convert_to_tensor(arr) print(a) OUT: [[1. 2. 3.] [4. 5. 6.]] tf.Tensor( [[1. 2. 3.] [4. 5. 6.]], shape=(2, 3), dtype=float64) 4. 创建张量1. 创建全为0或全为1的张量考虑到有一些参数矩阵需要通过训练得出，例如线性变换$y=wx+b$中的$w$和$b$就需要反向传播更新参数，那么一开始应该将它们初始化，将$w$初始化为1，$b$初始化为0，使得该线性变化层输出 $y=x$，这是一种比较好的层初始化状态。通过**tf.zeros()和tf.ones()**即可创建任意形状全为0或1的张量 权重初始化不可以初始化为0，因为这样反向传播就无法传播了 print(tf.zeros([1]),tf.ones([1])) OUT： tf.Tensor([0.], shape=(1,), dtype=float32) tf.Tensor([1.], shape=(1,), dtype=float32) print(tf.zeros([2,2]),tf.ones([2,2])) OUT： tf.Tensor( [[0. 0.] [0. 0.]], shape=(2, 2), dtype=float32) tf.Tensor( [[1. 1.] [1. 1.]], shape=(2, 2), dtype=float32) 有时候要求初始化的矩阵与某个矩阵的大小相等，这时可以通过**tf.zeros_like(),tf.ones_like()**可以方便地创建与某个张量shape一致，内容全为0或全为1的张量 2. 创建自定义数值张量有时候需要全部初始化为某个自定义数值的张量，可以通过**tf.fill()**可以创建全为自定义数值Value的张量。 print(tf.fill([2,2],100)) OUT： tf.Tensor( [[100 100] [100 100]], shape=(2, 2), dtype=int32) 3. 创建已知分布的张量正态分布和均匀分布是最常见的分布之一，当需要数据随机性采样时，就需要创建采集遵循这些分布的数据样本 创建正态分布张量 可通过$\\boldsymbol{tf.random.normal(shape,mean=0.0,stddev^2})$ shape表示创建的形状，均值为mean，标准差为stddev的正态分布 print(tf.random.normal([2,2],mean=1,stddev=2)) OUT： tf.Tensor( [[-0.2810527 -1.4531558 ] [-0.59204316 0.29616654]], shape=(2, 2), dtype=float32) 创建均匀分布张量 tf.random.uniform(shape,minval=0,maxval=None) 可以创建采样自[minval,maxval]区间的均匀分布的张量，如果需要均匀采样整形类型的数据，必须指定采样取间的最大值maxval参数，同时制定数据类型为tf.intxx型 print(tf.random.uniform([2,2],maxval=100)) OUT： tf.Tensor( [[55.972492 20.881033] [31.853653 41.91586 ]], shape=(2, 2), dtype=float32) print(tf.random.uniform([2,2],maxval=100,dtype=tf.int32)) OUT： tf.Tensor( [[41 68] [25 91]], shape=(2, 2), dtype=int32) 4. 创建序列在循环计算或者对张量进行索引时，经常需要创建一段连续的整形序列，可以通过tf.range()函数来实现，tf.range(limit,delta=1)可以创建[0，limit]之间，步长为delta的整形序列，不包含limit本身 创建0~9，步长为1的整形序列 print(tf,range(10)) OUt: tf.Tensor([0 1 2 3 4 5 6 7 8 9], shape=(10,), dtype=int32) 通过**tf.range(start,limit,delta=1)**可以创建[start,limit]，步长为delta的序列，不包含limit本身 print(tf.range(1,10,delta=2)) OUT：tf.Tensor([1 3 5 7 9], shape=(5,), dtype=int32) 5. 张量的应用介绍完张量的相关属性和创建方式后，接下来要介绍每种维度下张量的典型应用，方便更直观地联想到张量的主要物理意义和用途，为后续张量的维度变换等一系列抽象操作的学习打下基础 标量 标量就是一个简单的数字，维度数为0，标量的典型用途之一是误差值的表示，各种测量指标的表示，比如准确度（Accuracy，acc）精度（Precision）和召回率（Recall） 向量 向量是一种非常常见的数据载体，如在全连接层和卷积神经网络层中，偏置张量$b$就是使用向量 矩阵 矩阵也是非常常见的张量类型，比如全连接层的批量输入$X=\\begin{bmatrix}b,d_{in}\\end{bmatrix}$，其中$b$表示输入样本的个数，即batch size，$d_{in}$表示输入特征的长度。 3维张量 三维的张量一个典型应用是表示序列信号，它的格式是$$X=[b,sequence len,feature len]$$其中$b$表示序列信号的数量，$sequence$ $len$表示序列信号在时间维度上的采样点数，$feature$ $len$表示每个点的特征长度，例如自然语言处理中句子的表示，如评价句子的是否为正面情绪的情感分类任务网络，为了能够方便字符串被神经网络处理，一般将单词通过嵌入层（Embedding Layer）编码为固定长度的向量，比如两个等长（单词数为5）的句子序列可以表示为shape为[2,5,3]的3维张量，其中2个表示句子个数，5表示单词数量，3表示单词向量的长度。 4维张量 4维张量在卷积神经网络中应用的非常广泛，它用于保存特征图（Feature Maps）数据，一般定义为$\\begin{bmatrix}b,h,w,c\\end{bmatrix}$,$b$表示输入的数量，$w,h$分别表示特征图的宽高，$c$表示特征图的通道数 6. 索引与切片 索引 在TensorFlow中，支持基本的$[i][j]$标准索引方式，也支持通过逗号分隔索引号的索引方式。 x = tf.random.normal([4,32,32,3]) print(x) # 取第一张图的数据 print(x[0]) # 取第一张图的第一行的像素 print(x[0][0]) # 取第一张图的第一行第一列的像素 print(x[0][0][0]) # 去第一张图的第一行第一列的第一个通道的像素 print(x[0][0][0][0]) 当张量的维度数较高时，使用$[i][j]……[k]$的书写不方便，可以采用$[i,j,……,k]$的方式索引，它们是等价的 切片 通过$start🔚step$切片方式可以方便地提取一段数据，其中$start$为开始读取位置的索引，$end$为结束读取位置的索引（不包括$end$位），$step$为读取步长，这三个参数可以根据需要选择性地省略，全部省略即$::$，表示从最开始读取到最末尾，步长为1，即不跳过任何元素。特别地，$step$可以为负数，$step=-1$表示从$start$开始，逆序读取至$end$结束（不包括$end$），且索引号$end \\le start$ Tensorflow切片方法 5. 维度变换 在神经网络运算过程中，维度变换是最核心的张量操作，通过维度变换可以将数据任意地切换形式，满足不同场合的运算需求 1. 为什么需要维度变换？$$\\boldsymbol{\\mathrm{Y}=\\mathrm{X} @ \\mathrm{W}+b}$$ 其中$X$包含了2个样本，每个样本的特征长度为4，$X$的shape为$[2,4]$。 线性层的输出为3个节点，即$W$的shape定义为$[4,3]$，那么$\\boldsymbol{\\mathrm{X}@\\mathrm{W}}$运算张量shape为$[2,3]$，需要叠加上shape为$[3]$的偏置$\\boldsymbol{b}$。 那么不同的shape的2个张量怎么直接相加呢？ 回到我们设置偏置的初衷，我们给每个层的每个输出节点添加一个偏置，这个偏置数据是对所有的样本都是共享的，换言之，每个样本都应该累加上同样的偏置向量$\\boldsymbol{b}$。因此对于两个样本的输入X，我们需要将shape为$[3]$的偏置$\\boldsymbol{b}$$$\\begin{bmatrix}b_0\\b_1\\b_2\\\\end{bmatrix}$$按样本数量复制1份，变成矩阵形式$B’$：$$\\boldsymbol{B’=\\begin{bmatrix}b_0&amp;b_1&amp;b_2\\b_0&amp;b_1&amp;b_2\\end{bmatrix}}$$ $$\\mathrm{X}^{\\prime}=\\mathrm{X} @ \\mathrm{W}$$ $$X^{\\prime}=\\left[\\begin{array}{ccc}x_{00}^{\\prime} &amp; x_{01}^{\\prime} &amp; x_{02}^{\\prime} \\x_{10}^{\\prime} &amp; x_{11}^{\\prime} &amp; x_{12}^{\\prime}\\end{array}\\right]$$ $$Y=X^{\\prime}+B^{\\prime}=\\left[\\begin{array}{lll}x_{00}^{\\prime} &amp; x_{01}^{\\prime} &amp; x_{02}^{\\prime} \\x_{10}^{\\prime} &amp; x_{11}^{\\prime} &amp; x_{12}^{\\prime}\\end{array}\\right]+\\left[\\begin{array}{lll}b_{0} &amp; b_{1} &amp; b_{2} \\b_{0} &amp; b_{1} &amp; b_{2}\\end{array}\\right]$$ 为了实现矩阵相加的这种形式，将$\\boldsymbol{b}$插入一个新的维度，把它定义为batch（样本）维度。 算法的每个模块对于数据张量的格式有不同的逻辑要求，当现有的数据格式不满足算法要求时，需要通过维度变换将数据调整为正确的格式，这就是维度变换的功能 2. 张量的视图和存储 张量维度的视图： ==张量的视图就是我们理解张量的方式==，比如shape为$[2,4,4,3]$的张量A，我们从逻辑上可以理解为2张图片，每张图片4行4列，每个位置有RGB3个通道的数据 张量的存储： ==张量的存储体现在张量在内存上保存为一段连续的内存区域，对于同样的存储，我们可以有不同的理解方式==，比如同样是shape为$[2,4,4,3]$，在不改变张量的存储方式的前提下，可以理解为2个样本，每个样本的特征的长度为48的向量shape为$[2,4,4,3]$的数据在内存中存储的格式： $$\\begin{array}{|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|} \\hline 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; \\dots &amp; \\dots &amp; \\dots &amp; 93 &amp; 94 &amp; 95 \\ \\hline \\end{array}$$ 由图可见，==内存并不支持这个维度层级概念，只能以平铺方式按序写入内存，因此这种层级关系需要人为管理，也就是说，每个张量的存储顺序需要人为跟踪==，为了方便表达，我们把shape中相对靠左侧的维度叫做大维度，相对靠右侧的维度叫做小维度，改变张量的视图仅仅是改变了张量的理解方式，并不会改变张量的存储方式。 ==改变视图实际上是要告诉计算机应该怎样去读取平铺排列的数据==，但是改变视图操作在提供便捷性的同时，也会带来很多逻辑隐患，主要原因是张量的视图与存储不同步造成的。 在TensorFlow中，可以通过张量的ndim和shape成员属性获得张量的维度数和形状 a = tf.random.normal([2,2],mean=1,stddev=2) print(a.ndim) print(a.shape) OUT: 2 [2,2] 基本的维度变换包含了改变视图的reshape，插入新维度expand_dims，删除维度squeeze，交换维度transpose，复制数据tile等 3. Reshape从语法上来说，视图变换只需要满足新视图的元素总量与内存区域大小相等即可，即新视图的元素数量等于$b\\times h\\times w\\times c$ 即可。 改变视图是神经网络中非常常见的操作，可以通过串联多个Reshape 操作来实现复杂逻辑，但是在通过Reshape 改变视图时，必须始终记住张量的存储顺序，新视图的维度顺序不能与存储顺序相悖，否则需要通过交换维度操作将存储顺序同步过来。 例如：对于shape 为 $[4,32,32,3]$ 的图片数据，通过Reshape 操作将shape 调整为 $[4,1024,3]$，此时视图的维度顺序为 $𝑏 − 𝑝𝑖𝑥𝑒𝑙 − 𝑐$ ，张量的存储顺序为$[𝑏, ℎ, w, 𝑐]$。可以将[4,1024,3]恢复为 $[𝑏, ℎ, w, 𝑐]=[4,32,32,3]$，新视图的维度顺序与存储顺序无冲突，可以恢复出无逻辑问题的数据 $[𝑏, w, h, 𝑐]=[4,32,32,3]$，新视图的维度顺序与存储顺序冲突 $[h\\times w\\times c, b]=[4,32,32,3]$，新视图的维度顺序与存储顺序冲突 尽管reshape成功，数据也是没有用的 a = tf.random.normal([4,32,32,3],mean=1,stddev=2) print(a) b = tf.reshape(a,[4,1024,3]) print(b) 4. 增删维度 增加维度 增加一个长度为1的维度相当于给原有的数据增加一个新维度的概念，维度长度为1，故数据并不需要改变，仅仅是改变数据的理解方式，因此它其实可以理解为改变视图的一种特殊方式。 通过tf.expand_dims(x,axis)可以在指定axis轴前插入一个新的维度 x = tf.random.uniform([5,5],maxval=10,dtype=tf.int32) print(x) x = tf.expand_dims(x,axis=2) # 在尾部给张量增加一个新的维度 print(x) x = tf.expand_dims(x,axis=0) # 在张量最前面增加一个新的维度 print(x) OUT: tf.Tensor( [[4 2 2 5 5] [8 6 7 6 9] [6 1 5 2 1] [8 6 8 4 2] [2 6 1 1 1]], shape=(5, 5), dtype=int32) tf.Tensor( [[[4] [2] [2] [5] [5]] [[8] [6] [7] [6] [9]] [[6] [1] [5] [2] [1]] [[8] [6] [8] [4] [2]] [[2] [6] [1] [1] [1]]], shape=(5, 5, 1), dtype=int32) tf.Tensor( [[[[4] [2] [2] [5] [5]] [[8] [6] [7] [6] [9]] [[6] [1] [5] [2] [1]] [[8] [6] [8] [4] [2]] [[2] [6] [1] [1] [1]]]], shape=(1, 5, 5, 1), dtype=int32) 可以看到，插入一个新维度后，数据的存储顺序并没有改变，仅仅是在插入一个新的维度后，改变了数据的视图 删除维度 删除维度只能删除长度为1的维度，也不会改变张量的存储，可以通过tf.squeeze(x,axis)函数，axis参数为待删除的维度的索引号 x = tf.random.uniform([5,5],maxval=10,dtype=tf.int32) x = tf.expand_dims(x,axis=2) x = tf.expand_dims(x,axis=0) print(x) x = tf.squeeze(x,axis=0) print(x) OUT：tf.Tensor( [[[[3] [1] [9] [6] [4]] [[4] [0] [5] [5] [3]] [[4] [2] [3] [6] [9]] [[1] [4] [9] [4] [9]] [[1] [7] [4] [7] [1]]]], shape=(1, 5, 5, 1), dtype=int32) tf.Tensor( [[[3] [1] [9] [6] [4]] [[4] [0] [5] [5] [3]] [[4] [2] [3] [6] [9]] [[1] [4] [9] [4] [9]] [[1] [7] [4] [7] [1]]], shape=(5, 5, 1), dtype=int32) 5. 交换维度改变视图、增删维度都不会影响张量的存储。在实现算法逻辑时，在保持维度顺序不变的条件下，仅仅改变张量的理解方式是不够的，有时需要直接调整数据的存储顺序即交换维度，这改变了张量的存储顺序，也改变了张量的视图。 交换维度的应用：在TensorFlow中图片张量的默认存储格式是通道后行格式：$[b,h,w,c]$，但是部分库的图片格式是通道先行：$[b,c,h,w]$，因此需要完成$[b,h,w,c]$到$[b,c,h,w]$维度的交换运算 可以通过tf.transpose(x,perm)函数完成维度交换运算，perm表示新维度的顺序 x = tf.random.uniform([2, 3, 4, 5], maxval=100, dtype=tf.int32) print(x) x = tf.transpose(x, [0, 3, 1, 2]) print(x) OUT: tf.Tensor( [[[[86 15 96 67 83] [87 82 80 62 20] [19 68 43 59 21] [86 15 17 46 22]] [[51 32 65 48 44] [74 71 11 63 54] [10 44 42 61 60] [14 22 56 43 29]] [[41 11 2 61 18] [66 51 93 84 73] [44 53 7 13 55] [ 1 66 73 63 60]]] [[[65 77 66 50 26] [99 70 64 25 44] [75 40 30 4 93] [ 4 28 59 10 83]] [[59 7 3 58 41] [34 79 15 53 16] [54 84 34 3 61] [28 27 77 49 81]] [[17 74 43 33 68] [62 50 6 11 98] [43 65 76 99 96] [40 0 17 99 79]]]], shape=(2, 3, 4, 5), dtype=int32) tf.Tensor( [[[[86 87 19 86] [51 74 10 14] [41 66 44 1]] [[15 82 68 15] [32 71 44 22] [11 51 53 66]] [[96 80 43 17] [65 11 42 56] [ 2 93 7 73]] [[67 62 59 46] [48 63 61 43] [61 84 13 63]] [[83 20 21 22] [44 54 60 29] [18 73 55 60]]] [[[65 99 75 4] [59 34 54 28] [17 62 43 40]] [[77 70 40 28] [ 7 79 84 27] [74 50 65 0]] [[66 64 30 59] [ 3 15 34 77] [43 6 76 17]] [[50 25 4 10] [58 53 3 49] [33 11 99 99]] [[26 44 93 83] [41 16 61 81] [68 98 96 79]]]], shape=(2, 5, 3, 4), dtype=int32) 6. 数据复制通过增加维度操作插入新的维度后，可能希望在新的维度上面复制若干份数据，以满足后续算法的格式要求，类比$\\boldsymbol{\\mathrm{Y}=\\mathrm{X} @ \\mathrm{W}+b}$中的$\\boldsymbol{b}$ 可以通过**tf.tile(tensor,multiples)**函数完成数据在指定维度上的复制操作，multiple分别指定了每个维度上面的复制倍数，1表示不复制，2表示复制原来长度的2倍，即数据复制一份，以此类推。 需要注意的是，tf.tile 会创建一个新的张量来保存复制后的张量，由于复制操作涉及到大量数据的读写IO 运算，计算代价相对较高。神经网络中不同shape之间的运算操作十分频繁，那么有没有轻量级的复制操作呢？这就是接下来要介绍的Broadcasting 操作。 7. Broadcasting（广播机制）它是一种轻量级张量复制手段，在逻辑上扩展张量数据的形状，但是只在需要的时候才会执行实际存储复制操作。对于大部分场景，Broadcasting机制都能通过优化手段避免实际复制数据而完成逻辑运算，从而相对于**tf.tile()函数，减少了大量计算代价。==它的最终效果和tf.tile()**复制相同，但是Broadcasting机制节省了大量计算资源，建议在运算过程中尽可能地利用Broadcasting提高计算效率。== 上述$\\boldsymbol{\\mathrm{Y}=\\mathrm{X} @ \\mathrm{W}+b}$的例子，我们通过tf.expand_dims和tf.tile完成实际复制数据运算，将$\\boldsymbol{b}$变换为$[2,3]$，然后再与$\\boldsymbol{\\mathrm{X} @ \\mathrm{W}}$进行矩阵相加，但是==实际上，我们可以直接将两个shape不相等的矩阵进行相加，这是为什么呢？== 因为在进行相加的时候，它==自动调用==了Broadcasting函数**tf.broadcast_to(x,new_shape)**，将两者shape扩张为相同的shape，上式可以等价为：$$y=x\\left(w+t f . b \\text { roadcast }_{-} \\operatorname{to}(b,[2,3])\\right.$$ Broadcasting并不是对所有shape不同的张量的运算都有相同的效果，所有运算都要在正确的逻辑下运行，Broadcasting机制不会扰乱正常的计算逻辑，它只会针对==最常见的场景==自动完成增加维度并复制数据的功能，提高开发效率和运行效率 最常见的场景是什么？ Broadcasting机制的核心思想是普适性，即同一份数据能普遍适合于其他位置 普适性的判断： 在验证普适性之前要对维度进行一些操作：==将张量shape靠右对齐== 对于长度为1的维度，默认这个数据普遍适合于当前维度的其他位置；对于不存在的维度，则在增加新维度后默认当前数据也是普适性与新维度，从而可以扩展为更多维度数，其他长度的张量形状。 例如：shape为$[w,1]$的张量A，需要扩展为shape：$[b,h,w,c]$$$\\begin{array}{|l|l|l|l|}\\hline b &amp; h &amp; w &amp; c \\\\hline &amp; &amp; w &amp; 1 \\\\hline\\end{array}$$将维度靠右对齐后，对于通道维度$c$，张量现长度为1，则默认此数据同样适合当前维度的其他位置，将数据逻辑上复制$c-1$份，长度变为$c$，对于不存在的$b$和$h$维度，则自动插入新维度，新维度长度为1，同时默认当前的数据普适于新维度的其他位置，即对于其他的图片 、其他的行来说，与当前的这一行的数据完全一致，这样将数据$b,h$维度的长度自动扩展为$b,h$$$\\begin{array}{|l|l|l|l|}\\hline b &amp; h &amp; w &amp; c \\\\hline &amp; &amp; w &amp; 1 \\\\hline\\end{array}\\Rightarrow\\begin{array}{|l|l|l|l|}\\hline b &amp; h &amp; w &amp; c \\\\hline 1 &amp; 1 &amp; w &amp; 1 \\\\hline\\end{array}\\Rightarrow\\begin{array}{|l|l|l|l|}\\hline b &amp; h &amp; w &amp; c \\\\hline b &amp; h &amp; w &amp; c \\\\hline\\end{array}$$ 6. 数学运算 加：tf.add 减：tf.subtract 乘：tf.multiply 除：tf.divide 乘方：tf.pow(x,a)，相当于$x^a$ 平方:tf.square(x) 平方根：tf.sqrt(x) 指数：tf.exp() 对数：tf.math.log(x) 矩阵相乘:tf.matmul(a,b)","categories":[{"name":"Tensorflow框架学习笔记","slug":"Tensorflow框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Tensorflow%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"0. Tensorflow-gpu-2.5.0环境搭建","slug":"0. Tensorflow-gpu-2.5.0环境搭建","date":"2022-09-09T07:13:36.936Z","updated":"2022-09-09T07:13:36.936Z","comments":true,"path":"2022/09/09/0.tensorflow-gpu-2.5.0-huan-jing-da-jian/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/0.tensorflow-gpu-2.5.0-huan-jing-da-jian/","excerpt":"","text":"Tensorflow-gpu-2.5.0环境搭建1. 材料准备由于tensorflow-gpu不同版本对应深度学习加速框架CUDA版本的要求也不一样，我们在安装对应的tensorflow-gpu版本的时候需要查看一下对应的CUDA所需要的版本tensorflow-gpu对应版本，这里以下载最新版的为例 CUDA驱动下载地址 ​ 下载好驱动之后点击安装 ​ 选择自定义安装 接着照着需要的东西去选择安装即可，最后查看： CUDA ​ 选择好对应的系统平台下载，在电脑已经有驱动的情况下直接安装CUDA可能会系统兼容性检查不通过，这可能是驱动的版本太高的原因，而该CUDA所需要的显卡驱动连同CUDA一起安装 ​ CUDNN神经网络加速库 ​ 找到对应CUDA版本的CUDNN的版本下载，这个下载需要NVIDIA账号，当然可以使用APPLE账号，注册也不是难事 2. 安装tensorflow-gpu配置好上面的东西之后，就差tensorflow-gpu以及tensorflow的下载了，为了便于多种工程下的环境管理，引入miniconda来对环境以及安装包的管理 首先使用conda创建一个专门配置tensorflow安装包的虚拟环境：conda create -n you_env_name python=x.x 创建好环境之后，先使用conda search tensorflow-gpu 查看一下有没有我们想要的版本，我这里要的是tensorflow-gpu2.5.0 的版本 然后使用conda install tensorflow-gpu=2.5.0下载即可 3. 验证是否安装成功在python编译器环境下输入 import tensorflow as tf tf.test.is_gpu_available() 大功告成！","categories":[{"name":"Tensorflow框架学习笔记","slug":"Tensorflow框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Tensorflow%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"主机字节序和网络字节序","slug":"[socket网络编程]主机字节序和网络字节序","date":"2022-09-09T07:13:36.928Z","updated":"2022-09-09T07:13:36.928Z","comments":true,"path":"2022/09/09/socket-wang-luo-bian-cheng-zhu-ji-zi-jie-xu-he-wang-luo-zi-jie-xu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/socket-wang-luo-bian-cheng-zhu-ji-zi-jie-xu-he-wang-luo-zi-jie-xu/","excerpt":"","text":"主机字节序和网络字节序1、主机字节序字节序，就是自己的主机内部，内存中数据的存储方式 主机字节序取决于CPU 对于单字节，大部分处理器以相同的顺序处理比特位，因此单字节的存放和传输方式一般相同，像字符数据就是一个字节一个字节的数据不存在存放顺序的不同 对于多字节数据，如整型(32位机中一般占4字节)，在不同的处理器的存放方式主要有两种： 1. 大端按照内存的增长方向，高位数据存储于低位内存中 2. 小端按照内存的增长方向，高位数据存储于低位内存中 3. 为什么会有大小端之分 一开始是由于不同架构的CPU处理多个字节数据的顺序不一样，比如x86的是小端模式，KEIL C51是大端模式。但是后来互联网流行，TCP/IP协议规定为大端模式，为了跨平台通信，还专门出了网络字节序和主机字节序之间的转换接口（ntohs、htons、ntohl、htonl） 大小端模式各有优势：小端模式强制转换类型时不需要调整字节内容，直接截取低字节即可；大端模式由于符号位为第一个字节，很方便判断正负。 4. 判断大小端的方法 通过强制类型转换截断 BOOL IsBigEndian() { short a = 0x1234; char b = *(char*)&amp;a; if(0x12 == b) { return TRUE; } return FALSE; } 利用联合体共享内存的特性，截取低地址部分 BOOL IsBigEndian() { union NUM { short a; char b; }num; num.a = 0x1234; if(0x12 == num.b) { return TRUE; } return FALSE; } 2、 网络字节序网络传输一般采用大字节序，TCP协议采用的是网络字节序 两机之间进行数据传输一般要经过这样的过程： a的主机字节序———-网络字节序 ———b的主机字节序 网络字节序起到的是标准化的作用，网络字节序与主机字节序之间的转换函数：htons(), ntohs(), htons()，htonl()，位于头文件&lt;netinet/in.h&gt;，htons和ntohs完成16位无符号数的相互转换，htonl和ntohl完成32位无符号数的相互转换。 h是主机host，n是网络net，l是长整形long，s是短整形short 3、内存对齐 注意内存对齐和结构体对齐的不同 参考资料： 一文讲清楚大小端模式，字节对齐与左右对齐_afeik的博客-CSDN博客_字节左对齐 字节对齐_大小端_位序_樱木的追风者的博客-CSDN博客_字节序对齐","categories":[{"name":"socket网络编程学习笔记","slug":"socket网络编程学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"socket网络编程","slug":"socket网络编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"socket 编程及API简介","slug":"[socket网络编程]socket 编程及API简介","date":"2022-09-09T07:13:36.921Z","updated":"2022-09-09T07:13:36.922Z","comments":true,"path":"2022/09/09/socket-wang-luo-bian-cheng-socket-bian-cheng-ji-api-jian-jie/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/socket-wang-luo-bian-cheng-socket-bian-cheng-ji-api-jian-jie/","excerpt":"","text":"socket编程及API简介socket就是插座，运行在计算机中的两个程序通过socket建立起一个通道，数据在通道中传输 流式socket：基于TCP，是一个有序、可靠、双向字节流的通道，传输数据不会丢失、不会重复、顺序也不会错乱。 数据报socket：基于UDP，不需要建立和维持连接，可能会丢失或错乱。 socket是两台机器通信的管道 1. C/S模式（client/server）经典的服务端和客户端的模型 2. 实现代码1、客户端#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;netdb.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; int main(int argc,char *argv[]) { if (argc!=3) { printf(\"Using:./client ip port\\nExample:./client 127.0.0.1 5005\\n\\n\"); return -1; } // 第1步：创建客户端的socket。 int sockfd; if ( (sockfd = socket(AF_INET,SOCK_STREAM,0))==-1) { perror(\"socket\"); return -1; } // 第2步：向服务器发起连接请求。 struct hostent* h; if ( (h = gethostbyname(argv[1])) == 0 ) // 指定服务端的ip地址。 { printf(\"gethostbyname failed.\\n\"); close(sockfd); return -1; } struct sockaddr_in servaddr; memset(&amp;servaddr,0,sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(atoi(argv[2])); // 指定服务端的通信端口。 memcpy(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length); if (connect(sockfd, (struct sockaddr *)&amp;servaddr,sizeof(servaddr)) != 0) // 向服务端发起连接清求。 { perror(\"connect\"); close(sockfd); return -1; } char buffer[1024]; // 第3步：与服务端通信，发送一个报文后等待回复，然后再发下一个报文。 for (int ii=0;ii&lt;3;ii++) { int iret; memset(buffer,0,sizeof(buffer)); sprintf(buffer,\"这是第%d个超级女生，编号%03d。\",ii+1,ii+1); if ( (iret=send(sockfd,buffer,strlen(buffer),0))&lt;=0) // 向服务端发送请求报文。 { perror(\"send\"); break; } printf(\"发送：%s\\n\",buffer); memset(buffer,0,sizeof(buffer)); if ( (iret=recv(sockfd,buffer,sizeof(buffer),0))&lt;=0) // 接收服务端的回应报文。 { printf(\"iret=%d\\n\",iret); break; } printf(\"接收：%s\\n\",buffer); } // 第4步：关闭socket，释放资源。 close(sockfd); } 2、服务端#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;netdb.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; int main(int argc,char *argv[]) { if (argc!=2) { printf(\"Using:./server port\\nExample:./server 5005\\n\\n\"); return -1; } // 第1步：创建服务端的socket。 int listenfd; if ( (listenfd = socket(AF_INET,SOCK_STREAM,0))==-1) { perror(\"socket\"); return -1; } // 第2步：把服务端用于通信的地址和端口绑定到socket上。 struct sockaddr_in servaddr; // 服务端地址信息的数据结构。 memset(&amp;servaddr,0,sizeof(servaddr)); servaddr.sin_family = AF_INET; // 协议族，在socket编程中只能是AF_INET。 servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // 任意ip地址。 //servaddr.sin_addr.s_addr = inet_addr(\"192.168.190.134\"); // 指定ip地址。 servaddr.sin_port = htons(atoi(argv[1])); // 指定通信端口。 if (bind(listenfd,(struct sockaddr *)&amp;servaddr,sizeof(servaddr)) != 0 ) { perror(\"bind\"); close(listenfd); return -1; } // 第3步：把socket设置为监听模式。 if (listen(listenfd,5) != 0 ) { perror(\"listen\"); close(listenfd); return -1; } // 第4步：接受客户端的连接。 int clientfd; // 客户端的socket。 int socklen=sizeof(struct sockaddr_in); // struct sockaddr_in的大小 struct sockaddr_in clientaddr; // 客户端的地址信息。 clientfd=accept(listenfd,(struct sockaddr *)&amp;clientaddr,(socklen_t*)&amp;socklen); printf(\"客户端（%s）已连接。\\n\",inet_ntoa(clientaddr.sin_addr)); // 第5步：与客户端通信，接收客户端发过来的报文后，回复ok。 char buffer[1024]; while (1) { int iret; memset(buffer,0,sizeof(buffer)); if ( (iret=recv(clientfd,buffer,sizeof(buffer),0))&lt;=0) // 接收客户端的请求报文。 { printf(\"iret=%d\\n\",iret); break; } printf(\"接收：%s\\n\",buffer); strcpy(buffer,\"ok\"); if ( (iret=send(clientfd,buffer,strlen(buffer),0))&lt;=0) // 向客户端发送响应结果。 { perror(\"send\"); break; } printf(\"发送：%s\\n\",buffer); } // 第6步：关闭socket，释放资源。 close(listenfd); close(clientfd); } 注意 网络字节顺序的对齐 服务端大多数没有图形界面，因此需要学会使用gdb工具进行调试 3. socket编程注意事项在socket通信的客户端和服务器的程序里，出现了多种数据结构，调用了多个函数，涉及到很多方面的知识，对初学者来说，更重要的是了解socket通信的过程、每段代码的用途和函数调用的功能，不要去纠缠这些结构体和函数的参数，这些函数和参数虽然比较多，但可以修改的非常少，别抄错就可以了，需要注意的地方我会提出。 1、socket文件描述符在UNIX系统中，一切输入输出设备皆文件，socket()函数的返回值其本质是一个文件描述符，是一个整数。 2、服务端程序绑定地址如果服务器有多个网卡，多个IP地址，socket通信可以指定用其中一个地址来进行通信，也可以任意ip地址。 指定ip地址的代码 m_servaddr.sin_addr.s_addr = inet_addr(\"192.168.149.129\"); // 指定ip地址 任意ip地址的代码 m_servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // 本主机的任意ip地址 服务端程序绑定的通信端口 m_servaddr.sin_port = htons(5000); // 通信端口 客户端程序指定服务端的ip地址 struct hostent* h; if ( (h = gethostbyname(\"118.89.50.198\")) == 0 ) // 指定服务端的ip地址。 { printf(\"gethostbyname failed.\\n\"); close(sockfd); return -1; } 客户端程序指定服务端的通信端口 servaddr.sin_port = htons(5000); send函数 send函数用于把数据通过socket发送给对端。不论是客户端还是服务端，应用程序都用send函数来向TCP连接的另一端发送数据。 函数声明： ssize_t send(int sockfd, const void *buf, size_t len, int flags); sockfd为已建立好连接的socket buf为需要发送的数据的内存地址，可以是C语言基本数据类型变量的地址，也可以数组、结构体、字符串，内存中有什么就发送什么。 len需要发送的数据的长度，为buf中有效数据的长度。 flags填0, 其他数值意义不大。 函数返回已发送的字符数。出错时返回-1，错误信息error被标记。 注意，就算是网络断开，或socket已被对端关闭，send函数不会立即报错，要过几秒才会报错。 如果send函数返回的错误（&lt;=0），表示通信链路已不可用。 recv函数 recv函数用于接收对端socket发送过来的数据。 recv函数用于接收对端通过socket发送过来的数据。不论是客户端还是服务端，应用程序都用recv函数接收来自TCP连接的另一端发送过来数据。 函数声明： ssize_t recv(int sockfd, void *buf, size_t len, int flags); sockfd为已建立好连接的socket。 buf为用于接收数据的内存地址，可以是C语言基本数据类型变量的地址，也可以数组、结构体、字符串，只要是一块内存就行了。 len需要接收数据的长度，不能超过buf的大小，否则内存溢出。 flags填0, 其他数值意义不大。 函数返回已接收的字符数。出错时返回-1，失败时不会设置error的值。 如果socket的对端没有发送数据，recv函数就会等待，如果对端发送了数据，函数返回接收到的字符数。出错时返回-1。如果socket被对端关闭，返回值为0。 如果recv函数返回的错误（&lt;=0），表示通信通道已不可用。 服务端有两个socket 对服务端来说，有两个socket，一个是用于监听的socket，还有一个就是客户端连接成功后，由accept函数创建的用于与客户端收发报文的socket。 程序退出时先关闭socket socket是系统资源，操作系统打开的socket数量是有限的，在程序退出之前必须关闭已打开的socket，就像关闭文件指针一样，就像delete已分配的内存一样，极其重要。 值得注意的是，关闭socket的代码不能只在main函数的最后，那是程序运行的理想状态，还应该在main函数的每个return之前关闭。 4. 相关的库函数1、socket函数socket函数用于创建一个新的socket，也就是向系统申请一个socket资源。socket函数用户客户端和服务端。 函数声明： int socket(int domain, int type, int protocol); 参数说明： domain：协议域，又称协议族（family）。常用的协议族有AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域Socket）、AF_ROUTE等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。 type：指定socket类型。常用的socket类型有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等。流式socket（SOCK_STREAM）是一种面向连接的socket，针对于面向连接的TCP服务应用。数据报式socket（SOCK_DGRAM）是一种无连接的socket，对应于无连接的UDP服务应用。 protocol：指定协议。常用协议有IPPROTO_TCP、IPPROTO_UDP、IPPROTO_STCP、IPPROTO_TIPC等，分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。 说了一大堆废话，第一个参数只能填AF_INET，第二个参数只能填SOCK_STREAM，第三个参数只能填0。 除非系统资料耗尽，socket函数一般不会返回失败。 返回值：成功则返回一个socket，失败返回-1，错误原因存于error中。 2、gethostbyname函数把ip地址或域名转换为hostent 结构体表达的地址。 函数声明： struct hostent *gethostbyname(const char *name); 参数name，域名或者主机名，例如”192.168.1.3”、”www.freecplus.net\"等。 返回值：如果成功，返回一个hostent结构指针，失败返回NULL。 gethostbyname只用于客户端。 gethostbyname只是把字符串的ip地址转换为结构体的ip地址，只要地址格式没错，一般不会返回错误。失败时不会设置error的值 3、connect函数向服务器发起连接请求。 函数声明： int connect(int sockfd, struct sockaddr * serv_addr, int addrlen); 函数说明：connect函数用于将参数sockfd 的socket 连至参数serv_addr 指定的服务端，参数addrlen为sockaddr的结构长度。 返回值：成功则返回0，失败返回-1，错误原因存于error中。 connect函数只用于客户端。 如果服务端的地址错了，或端口错了，或服务端没有启动，connect一定会失败。 4、bind函数服务端把用于通信的地址和端口绑定到socket上。 函数声明： int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen); 参数sockfd，需要绑定的socket。 参数addr，存放了服务端用于通信的地址和端口。 参数addrlen表示addr结构体的大小。 返回值：成功则返回0，失败返回-1，错误原因存于error中。 如果绑定的地址错误，或端口已被占用，bind函数一定会报错，否则一般不会返回错误。 5、listen函数listen函数把主动连接socket变为被动连接的socket，使得这个socket可以接受其它socket的连接请求，从而成为一个服务端的socket。 函数声明： int listen(int sockfd, int backlog); 返回：0-成功， -1-失败 参数sockfd是已经被bind过的socket。socket函数返回的socket是一个主动连接的socket，在服务端的编程中，程序员希望这个socket可以接受外来的连接请求，也就是被动等待客户端来连接。由于系统默认时认为一个socket是主动连接的，所以需要通过某种方式来告诉系统，程序员通过调用listen函数来完成这件事。 参数backlog，这个参数涉及到一些网络的细节，比较麻烦，填5、10都行，一般不超过30。 当调用listen之后，服务端的socket就可以调用accept来接受客户端的连接请求。 返回值：成功则返回0，失败返回-1，错误原因存于error中。 listen函数一般不会返回错误。 6、accept函数服务端接受客户端的连接。 函数声明： int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen); 参数sockfd是已经被listen过的socket。 参数addr用于存放客户端的地址信息，用sockaddr结构体表达，如果不需要客户端的地址，可以填0。 参数addrlen用于存放addr参数的长度，如果addr为0，addrlen也填0。 accept函数等待客户端的连接，如果没有客户端连上来，它就一直等待，这种方式称之为阻塞。 accept等待到客户端的连接后，创建一个新的socket，函数返回值就是这个新的socket，服务端使用这个新的socket和客户端进行报文的收发。 返回值：成功则返回0，失败返回-1，错误原因存于error中。 accept在等待的过程中，如果被中断或其它的原因，函数返回-1，表示失败，如果失败，可以重新accept。 7、函数小结服务端函数调用的流程是：socket-&gt;bind-&gt;listen-&gt;accept-&gt;recv/send-&gt;close 客户端函数调用的流程是：socket-&gt;connect-&gt;send/recv-&gt;close 其中send/recv可以进行多次交互。 5. 常问问题1、程序最多能建立多少个socket？（边界性问题）文件描述符最多是1024个，这和linux系统设置有关可以临时把打开文件最大数修改 涉及服务器高性能并发时需要注意，压力测试 参考资料: 网络通信基础socket (freecplus.net) socket()函数详解_哔哩哔哩_bilibili","categories":[{"name":"socket网络编程学习笔记","slug":"socket网络编程学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"socket网络编程","slug":"socket网络编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"树莓派上安装ROS","slug":"树莓派上安装ROS","date":"2022-09-09T07:13:36.914Z","updated":"2022-09-09T07:13:36.914Z","comments":true,"path":"2022/09/09/shu-mei-pai-shang-an-zhuang-ros/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shu-mei-pai-shang-an-zhuang-ros/","excerpt":"","text":"树莓派上安装ROS在树莓派中下载Ubuntu Install Ubuntu on a Raspberry Pi | Ubuntu (80条消息) ububtu20.04安装ROS_zhangsxa的博客-CSDN博客_ubuntu20.04 安装ros (80条消息) ubuntu安装ROS进行到rosdep update时出现错误，如ERROR: unable to process source …_学习道路上的小学生的博客-CSDN博客","categories":[{"name":"ROS学习笔记","slug":"ROS学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Qt安装教程","slug":"[Qt配置]Qt安装教程","date":"2022-09-09T07:13:36.907Z","updated":"2022-09-09T07:13:36.908Z","comments":true,"path":"2022/09/09/qt-pei-zhi-qt-an-zhuang-jiao-cheng/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-pei-zhi-qt-an-zhuang-jiao-cheng/","excerpt":"","text":"","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt配置","slug":"Qt配置","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E9%85%8D%E7%BD%AE/"}]},{"title":"CLion配置Qt开发环境","slug":"[Qt配置]CLion配置Qt开发环境","date":"2022-09-09T07:13:36.902Z","updated":"2022-09-09T07:13:36.902Z","comments":true,"path":"2022/09/09/qt-pei-zhi-clion-pei-zhi-qt-kai-fa-huan-jing/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-pei-zhi-clion-pei-zhi-qt-kai-fa-huan-jing/","excerpt":"","text":"","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt配置","slug":"Qt配置","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E9%85%8D%E7%BD%AE/"}]},{"title":"QTimer","slug":"[Qt组件]QTimer","date":"2022-09-09T07:13:36.898Z","updated":"2022-09-09T07:13:36.898Z","comments":true,"path":"2022/09/09/qt-zu-jian-qtimer/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-zu-jian-qtimer/","excerpt":"","text":"QTimer类","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt组件","slug":"Qt组件","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E7%BB%84%E4%BB%B6/"}]},{"title":"QTextEdit组件","slug":"[Qt组件]QTextEdit组件","date":"2022-09-09T07:13:36.890Z","updated":"2022-09-09T07:13:36.891Z","comments":true,"path":"2022/09/09/qt-zu-jian-qtextedit-zu-jian/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-zu-jian-qtextedit-zu-jian/","excerpt":"","text":"QT——QTextEdit组件1. toPlainText()通过 toPlainText() 来获取 QTextEdit 对象输入框中输入的文本 QTextEdit *textedit; textedit = new QTextEdit(); qDebtextedit-&gt;toPlainText();","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt组件","slug":"Qt组件","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E7%BB%84%E4%BB%B6/"}]},{"title":"QTextBrowser组件","slug":"[Qt组件]QTextBrowser组件","date":"2022-09-09T07:13:36.882Z","updated":"2022-09-09T07:13:36.882Z","comments":true,"path":"2022/09/09/qt-zu-jian-qtextbrowser-zu-jian/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-zu-jian-qtextbrowser-zu-jian/","excerpt":"","text":"QT——QTextBrowser组件是一个大面积的面板，主要用于展现内容 1. toPlainText()多行简单文本框 QTextBrowser *textBrowser; textBrowser = new QTextBrowser(); auto text = textBrowser-&gt;toPlainText(); text.append(\"XXX\"); textBrowser-&gt;setText(text); textBrowser-&gt;moveCursor(QTextCursor::End); 2. toHtml()3.","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt组件","slug":"Qt组件","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E7%BB%84%E4%BB%B6/"}]},{"title":"QTabWidget组件","slug":"[Qt组件]QTabWidget组件","date":"2022-09-09T07:13:36.872Z","updated":"2022-09-09T07:13:36.872Z","comments":true,"path":"2022/09/09/qt-zu-jian-qtabwidget-zu-jian/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-zu-jian-qtabwidget-zu-jian/","excerpt":"","text":"QT——QTabWidget组件QTabWidget类提供了选项卡式的窗口控件 选项卡小部件提供了一个选项卡栏和一个“页面区域”，该页面区域用于显示与每个选项卡相关的页面。 默认情况下，选项卡栏显示在页面区域上方，但是可以使用不同的配置。 每个选项卡都与一个不同的窗口小部件相关联。页面区域中仅显示当前页面。其他所有页面均被隐藏。 1. TabWidget组件的使用 创建选项卡容器： 在主界面中创建QTabWidget作为选项卡容器，因为在主界面中大概率会依托在别的布局上，如QFrame（基本控件的基类）或者直接是QWidget（QFrame的基类），这时候就需要指定父对象，来表明QTabWidget组件是依附于父对象上面的 //代码不贴完全 //gridFrame1是tabWidget依附的父对象 tabWidget = new QTabWidget(gridFrame1); tabWidget-&gt;setObjectName(QString::fromUtf8(\"tabWidget\")); 添加tab页面： tab页面只需要创建一个QWidget作为页控件，不需要为它们指定父对象 tab_5 = new QWidget(); tab_5-&gt;setObjectName(QString::fromUtf8(\"tab_5\")); //将页面添加进入QTabWidget容器中 tabWidget-&gt;addTab(tab_5, QString()); 页面布局： 从Qt Designer来看页面有三种布局方式：格栅布局、水平布局、垂直布局 下面只介绍格栅布局的代码编写： gridLayout_8 = new QGridLayout(tab_5); gridLayout_8-&gt;setObjectName(QString::fromUtf8(\"gridLayout_8\")); 接下来只需要将所用到的控件添加进入gridLayout_8布局中即可 pushButton_5 = new QPushButton(tab_5); pushButton_5-&gt;setObjectName(QString::fromUtf8(\"pushButton_5\")); gridLayout_8-&gt;addWidget(pushButton_5, 0, 0, 1, 1); 2. 常用函数3. 信号与槽通信机制 参考资料 (80条消息) Qt之容器控件（QTabWidget）_Shijia Yin的博客-CSDN博客","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt组件","slug":"Qt组件","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E7%BB%84%E4%BB%B6/"}]},{"title":"QComboBox组件","slug":"[Qt组件]QComboBox组件","date":"2022-09-09T07:13:36.864Z","updated":"2022-09-09T07:13:36.865Z","comments":true,"path":"2022/09/09/qt-zu-jian-qcombobox-zu-jian/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-zu-jian-qcombobox-zu-jian/","excerpt":"","text":"QT——QComboBox组件1. 添加item QStringList 先把item使用IO流输入到QStringList对象中，再使用combobox中的添加items函数添加到combobox中 #include &lt;QStringList&gt; QstringList Qlist; Qlist.clear(); QList.clear(); QList&lt;&lt;QString(\"BL\")&lt;&lt;QString(\"BS\")&lt;&lt;QString(\"G\")&lt;&lt;QString(\"N\"); comboBox_5-&gt;clear(); comboBox_5-&gt;addItem(QString(\"None\")); comboBox_5-&gt;addItems(QList); comboBox_5-&gt;setCurrentIndex(0); for循环添加 for(int i=1;i&lt;=14;i++) { comboBox_4-&gt;addItem(QString::number(i)); } comboBox_4-&gt;setCurrentIndex(0); 2. 设置combobox初始选项combobox-&gt;setCurrentIndex(0);","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt组件","slug":"Qt组件","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E7%BB%84%E4%BB%B6/"}]},{"title":"Qt常用的工具","slug":"[Qt工具类]Qt常用的工具","date":"2022-09-09T07:13:36.858Z","updated":"2022-09-09T07:13:36.859Z","comments":true,"path":"2022/09/09/qt-gong-ju-lei-qt-chang-yong-de-gong-ju/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-gong-ju-lei-qt-chang-yong-de-gong-ju/","excerpt":"","text":"Qt常用的工具1. UIC2. Qt Designer3. windeployqt","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt工具类","slug":"Qt工具类","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"线程之间访问顺序化QMutex类","slug":"[Qt多线程编程]线程之间访问顺序化QMutex类","date":"2022-09-09T07:13:36.852Z","updated":"2022-09-09T07:13:36.852Z","comments":true,"path":"2022/09/09/qt-duo-xian-cheng-bian-cheng-xian-cheng-zhi-jian-fang-wen-shun-xu-hua-qmutex-lei/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-duo-xian-cheng-bian-cheng-xian-cheng-zhi-jian-fang-wen-shun-xu-hua-qmutex-lei/","excerpt":"","text":"","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt多线程编程","slug":"Qt多线程编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"}]},{"title":"Qt多线程类QThread","slug":"[Qt多线程编程]Qt多线程类QThread","date":"2022-09-09T07:13:36.846Z","updated":"2022-09-09T07:13:36.846Z","comments":true,"path":"2022/09/09/qt-duo-xian-cheng-bian-cheng-qt-duo-xian-cheng-lei-qthread/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-duo-xian-cheng-bian-cheng-qt-duo-xian-cheng-lei-qthread/","excerpt":"","text":"Qt多线程编程","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt多线程编程","slug":"Qt多线程编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"}]},{"title":"信号和槽","slug":"[Qt信号与槽]信号和槽","date":"2022-09-09T07:13:36.840Z","updated":"2022-09-09T07:13:36.840Z","comments":true,"path":"2022/09/09/qt-xin-hao-yu-cao-xin-hao-he-cao/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-xin-hao-yu-cao-xin-hao-he-cao/","excerpt":"","text":"信号和槽使用信号槽机制，必须满足: 这个类必须从QObject类或者是其子类进行派生 在定义类的头文件中加入 Q_OBJECT 宏 1. 自定义信号1）信号的声明要求： 信号是类的成员函数 返回值是 void 类型 信号的名字可以根据实际情况进行指定 参数可以随意指定, 信号也支持重载 信号需要使用 signals 关键字进行声明, 使用方法类似于public等关键字 信号函数只需要声明, 不需要定义(没有函数体实现) 在程序中发送自定义信号: 发送信号的本质就是调用信号函数 习惯性在信号函数前加关键字: emit，emit只是显示的声明一下信号要被发送, 没有特殊含义，底层 emit == #define emit class Test : public QObject { Q_OBJECT signals: void testsignal(); // 参数的作用是数据传递, 谁调用信号函数谁就指定实参 // 实参最终会被传递给槽函数 void testsignal(int a); }; 2）信号的使用 一个信号连接另一个信号，这种方式是被允许的，当信号被 emit后，相连的另一个信号会被emit。 信号可以通过引用的方式，返回出参。 信号可以继承，子类中可以直接 emit 父类的信号。 emit只能发送该类内的信号 2. 自定义槽函数Qt5 中，槽函数既可以是普通的全局函数、也可以是类的成员函数、静态成员函数、友元函数、虚函数，还可以用 lambda 表达式表示。 1）槽函数的声明要求： 返回值是 void 类型 槽函数需要指定多少个参数, 需要看连接的信号的参数个数 槽函数的参数是用来接收信号发送的数据的, 信号发送的数据就是信号的参数 槽函数需要指定多少个参数, 需要看连接的信号的参数个数 槽函数的参数应该和对应的信号的参数个数, 类型一一对应 信号函数：void testsig(int a, double b); 槽函数: void testslot(int a); 这里槽函数只接受信号函数中的第一个参数 槽函数可以使用关键字进行声明: slots (Qt5中slots可以省略不写) public private protected 2）信号槽的使用 一个信号连接多个槽，每个槽都会被一一执行，但是如果在多线程情况下，执行的顺序是不确定的，因为主要依赖事件循环，并不一定能够确定多线程的顺序。 一个信号对应一个槽，这种方式是我们最常见的。多个信号连接到一个槽，这种方式下，任何一个信号被 emit，槽函数都会被执行。 槽也是函数, 因此也支持重载 3. connect（）需要在添加头文件#include &lt;QObject&gt; 在QT4一般写成这样： QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot())); 在Qt 5中提供了一种新的格式： connect(sender, &amp;Sender::signal,receiver,&amp;Receiver::slot); 注意：当Sender::signal有不同参数列表使，需要清晰指出是哪个参数的信号被关联 信号和槽既然能被 connect，同样也可以被 disconnect。 1. connect的第五个参数第五个参数，是缺省的参数 Qt::AutoConnection 信号的发送者与信号的接收者在同一线程，则默认使用Qt::DirectConnection：如果不在同一线程，则默认使用Qt::QueuedConnection ``Qt::DirectConnection` 信号的发送者与信号的接收者在同一线程中执行，当发出信号后，会马上进入槽函数，看上去就像在信号 发送位置调用了槽函数，在多线程下会比较危险，容易造成崩溃 Qt::QueuedConnection 信号的发送者与信号的接收者不在同一线程中执行，槽函数运行于信号的接收者线程，当发送信号后， 槽函数不会马上被调用，等待信号的接收者把当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个 Qt::BlockingQueuedConnection 槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个 Qt::UniqueConnection 可以通过按位或（|）与以上四个结合在一起使用。当设置此参数时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是避免了重复连接 参考资料： Qt自定义信号槽的使用浅析+实例 - 进击的汪sir - 博客园 (cnblogs.com) (68条消息) Qt 信号和槽机制_slowlytalk的博客-CSDN博客_qt信号和槽机制","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt信号与槽","slug":"Qt信号与槽","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"}]},{"title":"串口多线程","slug":"[Qt串口编程]串口多线程","date":"2022-09-09T07:13:36.831Z","updated":"2022-09-09T07:13:36.832Z","comments":true,"path":"2022/09/09/qt-chuan-kou-bian-cheng-chuan-kou-duo-xian-cheng/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-chuan-kou-bian-cheng-chuan-kou-duo-xian-cheng/","excerpt":"","text":"串口多线程 建议： 窗口类主线程不要放任何while循环，甚至窗口主线程只需要发送信号让子线程执行即可，否则会出现窗口卡死的情况 参考资料 Qt 多线程串口通信问题? - 诸葛不亮的回答 - 知乎 (80条消息) Qt串口QSerialPort的多线程 及 QSerialPort的waitForReadyRead函数的问题_韭菜钟的博客-CSDN博客_qt waitforreadyread QT做的串口助手，子线程里waitforreadyread的问题-CSDN社区 (80条消息) QT线程同步技术详解_MingoJ的博客-CSDN博客_qreadwritelock (81条消息) 简析奇妙的Qt多线程，其同时兼备同步和异步_溪渣渣_梁世华的博客-CSDN博客_qt多线程同步异步 LzhYasuo/WebSocketClient (github.com) changfeng1050/SerialWizard: 使用C++ 20 &amp; Qt 编写的跨平台多功能串口调试工具 (github.com)","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt串口编程","slug":"Qt串口编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E4%B8%B2%E5%8F%A3%E7%BC%96%E7%A8%8B/"}]},{"title":"Qt串口类QSerialPortInfo和QSerialPort","slug":"[Qt串口编程]Qt串口类QSerialPortInfo和QSerialPort","date":"2022-09-09T07:13:36.824Z","updated":"2022-09-09T07:13:36.825Z","comments":true,"path":"2022/09/09/qt-chuan-kou-bian-cheng-qt-chuan-kou-lei-qserialportinfo-he-qserialport/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/qt-chuan-kou-bian-cheng-qt-chuan-kou-lei-qserialportinfo-he-qserialport/","excerpt":"","text":"Qt串口编程这里使用了QSerialPort模块提供的两个类：QSerialPort类和QSerialPortInfo类。 QSerialPort类提供了对串口的操作。 QSerialPortInfo类提供了对串口信息的获取。 1. 打开串口的方式 参考资料 Qt5 串口数据读取 - 简书 (jianshu.com)","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"Qt串口编程","slug":"Qt串口编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E4%B8%B2%E5%8F%A3%E7%BC%96%E7%A8%8B/"}]},{"title":"Qt编译错误","slug":"[error]Qt编译错误","date":"2022-09-09T07:13:36.817Z","updated":"2022-09-09T07:13:36.818Z","comments":true,"path":"2022/09/09/error-qt-bian-yi-cuo-wu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/error-qt-bian-yi-cuo-wu/","excerpt":"","text":"1. undefined reference to `vtable for MainWindow’问题描述Qt编译出现错误undefined reference to ‘vtable for MainWindow' 我是用CMake来构建Qt工程时出现了这个错误，直观意思是MainWindow的虚表没有定义，猜测是某些子类没有构建成功，无法链接。 解决办法 类的构造函数、析构函数没有进行定义（只在.h中声明没定义） 头文件中出现了一些Qt的关键词，如Q_OBJECT、signals等，这时候要将头文件也放到CMakeLists.txt的add_executable中，不然不会将这些关键词编译，也就没有办法正确生成类了。如果使用Qt工程，头文件则要放到.pro文件的HEADERS中。 2. no matching function for call to (类名):：connect()问题描述参数不匹配，具体情况尚未深究 解决办法使用另一种参数的connect QObject::connect(sender, SIGNAL(sendersignal(arg)),receiver, SLOT(slotfunc(ar))); 调用的函数原型是： QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection); 如果想使用下面这种方式进行连接信号与槽 connect(sender, &amp;Object::signal_xxx, reciever, &amp;Object::slot_xxx); 则调用的函数原型是： [static] QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection); 但是这种方式会有一个艰难的选择，就是如果有多个同名但参数列表不一样的信号，如果我们直接这样写，编译器就会报错，需要指定具体是哪一个信息被关联。我们也有相应的解决方法： QComboBox 的 currentIndexChanged 信号有两个 void currentIndexChanged(int index); void currentIndexChanged(const QString &amp;text); 如果我们直接使用上面取地址的写法。编译器是会报错的no matching function for call to (类名):：connect() connect(ui-&gt;cmb, &amp;QComboBox::currentIndexChanged, this, &amp;XXXWidget::slot_storageChanged); 因为currentIndexChanged有两个不同参数列表的信号。编译的时候，编译器会无法确定需要哪个重载函数。所以我们需要告诉编译器需要调用哪个重载函数。 connect(ui-&gt;cmb, static_cast&lt;void(QComboBox::*)(const QString&amp;)&gt;(&amp;QComboBox::currentIndexChanged), this, &amp;XXXWidget::slot_storageChanged); 一般QPushButton::clicked只有一种参数形式 找到一个比较符合我的情况的博客 (68条消息) Qt 信号和槽机制_slowlytalk的博客-CSDN博客_qt信号和槽机制","categories":[{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"}],"tags":[{"name":"error","slug":"error","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/error/"}]},{"title":"Pytorch安装配置","slug":"Pytorch安装配置","date":"2022-09-09T07:13:36.808Z","updated":"2022-09-09T07:13:36.809Z","comments":true,"path":"2022/09/09/pytorch-an-zhuang-pei-zhi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/pytorch-an-zhuang-pei-zhi/","excerpt":"","text":"Pytorch安装配置 Anaconda或者miniconda这些环境管理软件、以及CUDA的配置在这里就不过多介绍了，环境管理软件不是必须要有但最好有，因为这不会让你的电脑环境变得一团糟，方便管理，所以还没安装的同学可以自行百度解决 首先使用 conda create -n env_name python =x.x 创建出MindSpore虚拟环境 接着激活所创建的环境 然后使用conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 -c pytorch 安装好之后进入 python 环境，输入import torch 然后输入torch.cuda.is_available() 假如输出True 则说明配置成功","categories":[{"name":"Pytorch框架学习笔记","slug":"Pytorch框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Pytorch%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"代码报错情况及解决方法","slug":"代码报错情况及解决方法","date":"2022-09-09T07:13:36.802Z","updated":"2022-09-09T07:13:36.802Z","comments":true,"path":"2022/09/09/dai-ma-bao-cuo-qing-kuang-ji-jie-jue-fang-fa/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/dai-ma-bao-cuo-qing-kuang-ji-jie-jue-fang-fa/","excerpt":"","text":"字符串索引过界索引值与索引对象里有的元素不符合，即索引值超过了索引对象的元素之和 n=input('请输入一段由单词和数字组成的字符串:') number=[] string=[] for i in range(len(n)): s=n[i] if s.isalpha(): string.append(s) elif s.isdigit(): number.append(s) else: print('%s 不属于数字或单词' %s) print(\"\".join(string)) print(\"\".join(number),end=\" \") if number == number[::-1]:#用切片的方法判断列表的排列顺序 print('yes') else: print('no')``` ​```\"\"\" 分离 \"\"\" n = input() list_number = [] list_str = [] for i in range(len(n)): # 防止索引越界 if i == len(n) - 1: if n[i].isalpha(): list_str.append(n[i]) else: list_number.append(n[i]) else: # 如果是字母 if n[i].isalpha(): # 判断是否为最后一个 if n[i + 1].isalpha(): list_str.append(n[i]) else: list_str.append(n[i]) list_str.append(\" \") else: list_number.append(n[i]) print(\"\".join(list_str)) print(\"\".join(list_number), end=\" \") if list_number == list_number[::-1]: print(\"Yes\", end=\"\") else: print(\"No\", end=\"\") 矩阵与列表的区别","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"解析文件","slug":"[脚本]解析文件","date":"2022-09-09T07:13:36.794Z","updated":"2022-09-09T07:13:36.794Z","comments":true,"path":"2022/09/09/jiao-ben-jie-xi-wen-jian/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/jiao-ben-jie-xi-wen-jian/","excerpt":"","text":"解析文件 在现在的大数据时代，我们可以通过处理这些大量的数据来实现某个目标，那么这些大量的数据应该存储在哪里呢？很多数据都是通过写入一些文本文件中，存储在文本文件中，这种存储数据的文件类型有很多，比如：json，xml，txt等。由于最近接触的比赛的数据集是xml文件，接下来就说说==如何用python解析xml文件。== xml（Extensible Markup Language）文件简介XML指可扩展标记语言，被设计用来传输和存储数据，用于标记电子文件使其具有结构性的标记语言xml简单易于在任何应用程序中读/写，使得xml很快成为数据交换的唯一公共语言，程序可以更容易的与windows、Mac os、Linux以及其他平台下产生的信息结合，然后可以很容易加载XML数据到程序中并分析它，并以XML格式输出结果 xml可用作数据的说明、储存、传输举个“栗子”：假设在一个微信群里面小明发了一条消息“你吃了吗？”，而这条消息发出后会被储存到服务器里，而当你进入微信的时候，这条消息就会从服务器里抓取过来显示到你的手机上。而这个抓取的过程中假设是以xml文件来传输（当然也有json，json和xml用途很相似，json，xml都有自己的格式，只是包装数据的格式不同而已，重要的是其中含有的数据，而不是包装的格式），以我们人的观念来看这些信息是这样表示的： 发送者：小喜 聊天组：XXXX 信息：你吃了吗？显然上面的形式是我们很容易看懂的，但是机器却看不懂，所以传入之前它是通过xml的格式来让机器能识别出来,它的格式大概是这样：&lt;msg&gt; &lt;sender = \"小喜\"/&gt; &lt;groupid = 123445/&gt; &lt;type = test/&gt; &lt;content = \"你吃了吗？\"/&gt; &lt;/msg&gt; xml文件现在多用于作配置文件，设置文件比较多，很多软件，框架都会采取xml作为配置文件。像在Android Studio中创建一个项目时，像在Andriod Studio中创建一个项目时，开始会弹出一个Configure your project，而你在上面输入的项目名，包名什么的都会帮你存储到AndroidManifest.xml文件里。此xml文件里还会默认配置好项目的一些属性和一个ManinActivity以及这个activity的一些属性，并且在之后一些组件（Activity，service等）都是要在这里面注册并配置的。 xml的优点 格式统一，符合标准 容易与其他系统进行远程交互，数据共享比较方便 xml的缺点 xml文件庞大，文件格式复杂，传输占用带宽较大 服务器端和客户端都需要花费大量代码来解析，导致服务器端和客户端代码变得异常复杂且不易维护 客户端不同浏览器之间解析xml文件的方式不一致，需要重复编写很多代码 服务器端和客户端解析xml花费较多的资源和时间 JSON（Javascript Object Notation）文件简介JSON是一种轻量级的数据交换格式。它基于ECMScript（欧洲计算机协会制定的js规范）的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得JSON成为理想的数据交换语言。易于人阅读和编写，同时爷易于机器解析和生成，并有效地提升网络传输效率 可读性方面JSON和XML的数据可读性基本相同，JSON和XML的可读性可谓是不相上下，一边是建议的语法，一边是规范的标签形式，XML可读性较好些 可扩展性方面XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展而JSON不能的 编码难度方面JSON的编码明显比XML容易很多，即使不借助工具也能写出JSON的代码，但是要编码XML文件就不太容易了，XML有丰富的编码工具，比如：Dom4j、JDom等 解码难度方面XML的解析得考虑子节点父节点，而JSON得解析难度几乎为0 JSON的优点 数据格式比较简单，易于读写，格式都是压缩的，占用的带宽较小 易于解析，客户端Javascript可以简单的通过eval（）进行JSON数据的读取 支持多种语言，便于服务器端解析 JSON的缺点 没有XML格式那么强的通用性 JSON格式目前在Web Service中推广还属于初级阶段 利用Python解析XML文件 我在进行数据集的解析时使用Python中的一个库：==xml.dom.minidom==，解析出图像标注的数据信息，这些信息保存在xml文件中 xml.dom.minidom是文档对象模型接口额最小实现，其API类似于其他语言，它的目标是比完整的DOM更简单，也更小。 首先调用该库里面的一个函数：==parse（filename_or_file[, parser[, bufsize]]）==，该函数的参数可以是文件名或者是文件对象，一般传入的参数为文件对象名，==Document Object Model==从给定的输入中被返回，也就是DOM 1. 什么是DOM我们先来介绍一下什么是DOM，它是由W3C组织定义的一个标准。在前端开发时，我们往往需要在页面某个地方添加或者删除元素，添加或删除元素的操作是通过DOM来实现的。说白了DOM就是一个接口，通过DOM来操作页面中各种元素 W3C中的DOM被分为3个不同的部分/级别： 核心 DOM用于任何结构化文档的标准模型 XML DOM用于XML文档的标准模型 HTML DOM用于HTML文档的标准模型 2. DOM的结构DOM采用树形结构作为分层结构，以树节点形式表示页面总各种元素或内容，只介绍XML DOM，XML DOM是将XML文档作为一个树形结构，XML文件格式如下： &lt;bookstore&gt; &lt;book category=\"children\"&gt; &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category=\"cooking\"&gt; &lt;title lang=\"en\"&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt; &lt;book category=\"web\" cover=\"paperback\"&gt; &lt;title lang=\"en\"&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt; &lt;book category=\"web\"&gt; &lt;title lang=\"en\"&gt;XQuery Kick Start&lt;/title&gt; &lt;author&gt;James McGovern&lt;/author&gt; &lt;author&gt;Per Bothner&lt;/author&gt; &lt;author&gt;Kurt Cagle&lt;/author&gt; &lt;author&gt;James Linn&lt;/author&gt; &lt;author&gt;Vaidyanathan Nagarajan&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;49.99&lt;/price&gt; &lt;/book&gt; &lt;/bookstore&gt; 可以看到XML文件是由标签对组成： &lt;book&gt;&lt;/book&gt; 标签对可以有属性： &lt;book catagory=“web” cover=\"paperback\"&gt;&lt;/book&gt; 标签对可以嵌入数据： &lt;author&gt;James McGovern&lt;/author&gt; 标签对可以嵌入子标签： &lt;book category=\"web\" cover=\"paperback\"&gt; &lt;title lang=\"en\"&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt; 其树形结构如下图： 在DOM中，每个元素看成一个节点，而每一个节点就是一个“对象” ，**在操作元素时，把每个元素节点看成一个对象，然后使用这个对象的属性和方法进行相关操作**，每一个节点都有它的nodeName：节点名字，nodeValue：节点的值，只对文本节点有效，nodeType：节点的类型（一般不常用） 在解析XML DOM之前还要引入一些基本概念： 根节点（Root element） 每个XML DOM都会有个根节点，上述例子中的根节点就是：bookstore XML文件都是将数据保存在根节点下的子节点中，若想获取那些信息就先要解析出根节点，就像剥洋葱一样，一层一层地解析出数据。 父（子）节点 一个节点之上的节点就是该节点的父节点，一个节点之下就是该节点的子节点，比如：book是bookstore的子节点，也是author的父节点 兄弟节点 如果多个节点在同一层次，并拥有相同的父节点，那么这几个节点就是兄弟节点 2. 解析XML文件函数parse（）的功能就是做一个“DOM生成器”，可以从任何SAX解析器（暂时不用去了解）解析接受事件，即：文件夹或文件对象，并将它们转换成DOM树 首先需要引入xml.dom.minidom模块 import xml.dom.minidom 接着调用模块中函数：parse()，传入xml文件名作为参数，来打开这个xml文件，并将这个文件对象转化为dom对象 dom = xml.dom.minidom.parse(\"sample.xml\") 前面说到了，数据一般存储到根节点下的子节点中，因此要先解析出根节点，而==documenElement==就是用于得到dom对象的文档元素，并把获得的对象给root root = dom.documentElement 接下来就是要获取根节点下的子节点，对于知道元素名字的子元素，可以使用==getElementsByTagName==方法来获取,函数返回为List对象，这个列表里面包含了根节点下所有nodeName为”book”的子节点，其索引方式与列表的索引方式完全相同，假如获取得到的子节点下面还有子节点，则需要再次使用==getElementsByTagName==方法，前提是知道节点的名字 book = root.getElementsByTagName(\"book\") 当然有一种比较神奇的xml文件分布，就是对于具有同一个节点名的节点列表，它们的父节点有可能不是在同一个节点列表里，此时==getElementsByTagName==方法同样会返回具有同一个节点名的列表，因此在解析xml文件时，要看看数据在文件中的分布 标签对中包含着标签的属性值。如何将其获取出来呢？可以用==getAttribute==方法获得标签的属性所对应的值，传入属性名作为参数,而且只能通过一个元素节点来调用它 catalog = book[0].getAttribute(\"catalog\") 数据一般会存储在标签对之间，获取标签对之间的数据有很多种方法，DOM的成员有很多种比如有：firstChild成员返回被选节点下的第一个子节点，data成员返回该节点或该属性的文本，childNodes返回被选节点下的一个子节点列表，但是这个子节点列表的格式是：子节点信息被Text node给包围，也就是说，子节点信息的位置位于这个childNodes列表的奇数位置。 获取标签对之间的文本信息： text = book[0].childNodes[1::2].data","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"Python包管理工具miniconda","slug":"[包管理]Python包管理工具miniconda","date":"2022-09-09T07:13:36.788Z","updated":"2022-09-09T07:13:36.789Z","comments":true,"path":"2022/09/09/bao-guan-li-python-bao-guan-li-gong-ju-miniconda/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/bao-guan-li-python-bao-guan-li-gong-ju-miniconda/","excerpt":"","text":"miniconda包管理下面分享几个conda的之类 conda list 查看安装了哪些安装包 conda env list 以及 conda info -e 查看创建的虚拟环境 conda create -n env_name python =x.x 创建python版本为 x.x 的虚拟环境 conda activate env_name 激活你的虚拟环境，也就是切换环境 conda deactivate env_name 从当前环境退出到 base 环境中 conda remove -n env_name --all 删除虚拟环境 conda search package_name 查找安装包的版本 conda config --add channels XXXXXX添加国内镜像源的指令 conda config --set show_channel_urls yes 和上面的搭配使用","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"包管理","slug":"包管理","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"}]},{"title":"pip使用","slug":"[包管理] pip使用","date":"2022-09-09T07:13:36.782Z","updated":"2022-09-09T07:13:36.782Z","comments":true,"path":"2022/09/09/bao-guan-li-pip-shi-yong/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/bao-guan-li-pip-shi-yong/","excerpt":"","text":"pip使用1、pip下载1. 方案一：对于比较小的库，可以延时处理——– pip –default-timeout=100 install -U pip——– pip –default-timeout=100 install 第三方库名 2. 方案二：更换安装源————网上可以查找很多豆瓣源如https://pypi.tuna.tsinghua.edu.cn/simple/pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyechartspip install -i https://pypi.tuna.tsinghua.edu.cn/simple 库名出错使用这种 ：pip install –index-url https://pypi.tuna.tsinghua.edu.cn/simple/ lightgbm 3. 方案三：下载离线包python所有库：(https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml)———然后通过pip install 保存路径/加上下载的文件名 进行安装（如pip install C:\\Users\\HP\\Desktop\\scikit_image-0.14.1-cp37-cp37m-win32.whl）阿里源：pip install -i https://mirrors.aliyun.com/pypi/simple 2、pip卸载pip uninstall PackageName","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"包管理","slug":"包管理","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"}]},{"title":"系统相关","slug":"[Python常用库]系统相关","date":"2022-09-09T07:13:36.775Z","updated":"2022-09-09T07:13:36.775Z","comments":true,"path":"2022/09/09/python-chang-yong-ku-xi-tong-xiang-guan/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-chang-yong-ku-xi-tong-xiang-guan/","excerpt":"","text":"系统相关库函数作用和使用1、platform该模块用来访问平台相关属性。 常见属性和方法 platform.machine()返回平台架构，若无法确定，则返回空字符 platform..node()返回计算机网络名称（可能未被完全限定）如果无法确定该值,则返回空字符串。 platform.platform(aliased = 0,terse = 0)系统版本 platform.processor()返回处理器名称 platform.system()返回系统名称 2、os库os库是Python标准库，包含几百个函数,常用路径操作、进程管理、环境参数等几类。os.path子库以path为入口，用于操作和处理文件路径。 路径操作：os.path子库，处理文件路径及信息 进程管理：启动系统中其他程序 环境参数：获得系统软硬件信息等环境参数 os.path.normpath(path) # 归一化path的表示形式，统一用\\\\分隔路径 os.path.relpath(path) # 返回当前程序与文件之间的相对路径 (relative path) os.path.dirname(path) # 返回path中的目录名称 os.path.basename(path) # 返回path中最后的文件名称 os.path.join(path, *paths) # 组合path与paths，返回一个路径字符串 os.path.exists(path) # 判断path对应文件或目录是否存在，返回True或False os.path.isfile(path) # 判断path所对应是否为已存在的文件，返回True或False os.path.isdir(path) # 判断path所对应是否为已存在的目录，返回True或False os.path.getatime(path) # 返回path对应文件或目录上一次的访问时间 os.path.getmtime(path) # 返回path对应文件或目录最近一次的修改时间 os.path.getctime(path) # 返回path对应文件或目录的创建时间 os.path.getsize(path) # 返回path对应文件的大小，以字节为单位 os.chdir(path) # 修改当前程序操作的路径 os.getcwd() # 返回程序的当前路径 os.getlogin() # 获得当前系统登录用户名称 os.cpu_count() # 获得当前系统的CPU数量 os.urandom(n) # 获得n个字节长度的随机字符串，通常用于加解密运算 os.chmod() # 方法用于更改文件或目录的权限。 1. 文件操作 重命名 os.rename(src , dst) 用于重命名的目录或文件，还可以用于将文件从一个位置移动到另一个位置 如果不想文件直接移动的话，建议不要用这个，可以考虑使用shutil.copyfile() 连接 os.path.join(A,B) 注意：如果有一个路径很长的话将不会被拼接 分解文件名和后缀 os.path.split(file) # 分割路径和文件名，返回元组 os.path.splitext(result[1]) # 分割文件名和扩展名，返回元组 def test(): file = r\"D:\\Project\\Github.io\\222.md\" (path, filename) = os.path.split(file) # 带后缀 (filename,ext) = os.path.splitext(filename) # b带后缀 print(filename) if __name__ == '__main__': test() 3、subprocess模块subprocess 模块允许我们启动一个新进程，并连接到它们的输入/输出/错误管道，从而获取返回值。因此常用于调用命令行 import subprocess process = subprocess.Popen(\"ls\", shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) 这里通过将stdout重定向到subprocess.PIPE上来取得ls命令的输出，如果想将stderr也重定向到subprocess.PIPE上,stderr=subprocess.STDOUT改成stderr=subprocess.PIPE即可。 通过subprocess读取命令行的输出 我们使用 subprocess 执行命令行后，可以通过process.stdout.read()来读取命令行输出，不过process.stdout.read()返回的是bytes,要想取得str,可以直接调用process.stdout.read().decode('utf-8')。 import subprocess process = subprocess.Popen(\"ls\", shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) command_output = process.stdout.read().decode('utf-8') # 处理ls的返回值 参考资料 Python中调用命令行的几种方法 - 简书 (jianshu.com) 4、 time模块获取时间的模块 获取毫秒级时间戳 def get_time_stamp(): ct = time.time() local_time = time.localtime(ct) data_head = time.strftime(\"%Y-%m-%d %H:%M:%S\", local_time) data_secs = (ct - int(ct)) * 1000 time_stamp = \"%s.%03d\" % (data_head, data_secs) stamp = (\"\".join(time_stamp.split()[0].split(\"-\"))+\"\".join(time_stamp.split()[1].split(\":\"))).replace('.', '') return stamp D:\\Project\\Github.io\\记事本\\学习笔记\\Atlas200DK开发笔记\\[环境部署]Atlas200DK环境部署.md D:\\Project\\Github.io\\记事本\\学习笔记\\C++学习笔记\\[C++关键字]constexpr关键字.md D:\\Project\\Github.io\\记事本\\学习笔记\\C++学习笔记\\[C++关键字]explicit关键字.md D:\\Project\\Github.io\\记事本\\学习笔记\\C++学习笔记\\[C++基础知识]动态内存分配.md D:\\Project\\Github.io\\记事本\\学习笔记\\C++学习笔记\\[C++基础知识]基本数据类型.md D:\\Project\\Github.io\\记事本\\学习笔记\\C++学习笔记\\[C++基础知识]类的定义和使用.md D:\\Project\\Github.io\\记事本\\学习笔记\\C++学习笔记\\[C++基础知识]类的构造函数.md D:\\Project\\Github.io\\记事本\\学习笔记\\C++学习笔记\\[C++基础知识]：：和：的意义.md D:\\Project\\Github.io\\记事本\\学习笔记\\C++学习笔记\\[C++多线程编程]C++多线程.md D:\\Project\\Github.io\\记事本\\学习笔记\\C++学习笔记\\[C++进阶知识]C++中调用C语言.md D:\\Project\\Github.io\\记事本\\学习笔记\\C++学习笔记\\[error]C++编译错误笔记.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\#define和const的区别.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C库函数-signal().md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言中的#include.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言中的extern.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言中的goto语句.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言中的ioctl.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言中的static.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言中的位域结构体.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言中的联合体.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言中系统相关的函数.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言内存管理函数.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言宏定义中的##和#的作用.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言工程的链接.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言引用.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言文件操作函数.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言的优先级.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言的枚举类型.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言知识点.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\C语言预编译指令.md D:\\Project\\Github.io\\记事本\\学习笔记\\C语言学习笔记\\使用gcc编译的指令格式.md D:\\Project\\Github.io\\记事本\\学习笔记\\Git学习笔记\\Git分支开发.md D:\\Project\\Github.io\\记事本\\学习笔记\\Git学习笔记\\git安装及配置.md D:\\Project\\Github.io\\记事本\\学习笔记\\Git学习笔记\\git更新远程仓库代码.md D:\\Project\\Github.io\\记事本\\学习笔记\\Git学习笔记\\git远程仓库版本回退.md D:\\Project\\Github.io\\记事本\\学习笔记\\Git学习笔记\\git问题参考.md D:\\Project\\Github.io\\记事本\\学习笔记\\Git学习笔记\\Hello_git.md D:\\Project\\Github.io\\记事本\\学习笔记\\Git学习笔记\\规范git commit.md D:\\Project\\Github.io\\记事本\\学习笔记\\Hispark开发学习笔记\\HIMPP开发SDK-系统控制.md D:\\Project\\Github.io\\记事本\\学习笔记\\Hispark开发学习笔记\\HiMPP开发SDK-视频处理子系统.md D:\\Project\\Github.io\\记事本\\学习笔记\\Hispark开发学习笔记\\HiMPP开发SDK-视频输入.md D:\\Project\\Github.io\\记事本\\学习笔记\\Hispark开发学习笔记\\HiMPP开发SDK-视频输出.md D:\\Project\\Github.io\\记事本\\学习笔记\\Hispark开发学习笔记\\MIPI开发SDK.md D:\\Project\\Github.io\\记事本\\学习笔记\\Hispark开发学习笔记\\解决编译海思SDK引发的思考.md D:\\Project\\Github.io\\记事本\\学习笔记\\JAVA学习笔记\\JAVA1. 基础知识.md D:\\Project\\Github.io\\记事本\\学习笔记\\JAVA学习笔记\\JAVA2. 面向对象前沿知识.md D:\\Project\\Github.io\\记事本\\学习笔记\\JAVA学习笔记\\JAVA3. 初识面向对象.md D:\\Project\\Github.io\\记事本\\学习笔记\\JAVA学习笔记\\JAVA4. 面向对象深入.md D:\\Project\\Github.io\\记事本\\学习笔记\\JAVA学习笔记\\JAVA5. 数组的深入.md D:\\Project\\Github.io\\记事本\\学习笔记\\JAVA学习笔记\\JAVA6. 常用实用类.md D:\\Project\\Github.io\\记事本\\学习笔记\\JAVA学习笔记\\JAVA7. 容器.md D:\\Project\\Github.io\\记事本\\学习笔记\\JAVA学习笔记\\JAVA8. IO-1.md D:\\Project\\Github.io\\记事本\\学习笔记\\JAVA学习笔记\\JAVA8. IO-2.md D:\\Project\\Github.io\\记事本\\学习笔记\\JAVA学习笔记\\JAVA9. 多线程.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\Linux常用的软件的下载.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\Linux指令学习.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\Linux系统自带的Python切勿任意删除.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\Markfile的作用.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\MobaXterm远程连接ubuntu.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\Shell脚本.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\ubantu18.04换源.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\Ubantu更改用户名.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\Ubuntu Arm版换源.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\Ubuntu Server下配置wifi.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\Ubuntu替换python版本.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\vim指令学习.md D:\\Project\\Github.io\\记事本\\学习笔记\\Linux操作系统学习\\交叉编译的格式.md D:\\Project\\Github.io\\记事本\\学习笔记\\MindSpore框架学习笔记\\MindSpore安装配置.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python学习]import导入机制.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python学习]python学习.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python学习]python常用的函数和方法.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python学习]__init__.py的作用.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python学习]字符串占位符.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python学习]正则表达式.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python学习]装饰器.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python学习]面向对象.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python常用库]序列化pickle.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python常用库]数据处理相关.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python常用库]类型注解支持typing.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[Python常用库]系统相关.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[包管理] pip使用.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[包管理]Python包管理工具miniconda.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\[脚本]解析文件.md D:\\Project\\Github.io\\记事本\\学习笔记\\Python学习笔记\\代码报错情况及解决方法.md D:\\Project\\Github.io\\记事本\\学习笔记\\Pytorch框架学习笔记\\Pytorch安装配置.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[error]Qt编译错误.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt串口编程]Qt串口类QSerialPortInfo和QSerialPort.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt串口编程]串口多线程.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt信号与槽]信号和槽.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt多线程编程]Qt多线程类QThread.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt多线程编程]线程之间访问顺序化QMutex类.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt工具类]Qt常用的工具.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt组件]QComboBox组件.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt组件]QTabWidget组件.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt组件]QTextBrowser组件.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt组件]QTextEdit组件.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt组件]QTimer.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt配置]CLion配置Qt开发环境.md D:\\Project\\Github.io\\记事本\\学习笔记\\QT学习笔记（C++）\\[Qt配置]Qt安装教程.md D:\\Project\\Github.io\\记事本\\学习笔记\\ROS学习笔记\\树莓派上安装ROS.md D:\\Project\\Github.io\\记事本\\学习笔记\\socket网络编程学习笔记\\[socket网络编程]socket 编程及API简介.md D:\\Project\\Github.io\\记事本\\学习笔记\\socket网络编程学习笔记\\[socket网络编程]主机字节序和网络字节序.md D:\\Project\\Github.io\\记事本\\学习笔记\\Tensorflow框架学习笔记\\0. Tensorflow-gpu-2.5.0环境搭建.md D:\\Project\\Github.io\\记事本\\学习笔记\\Tensorflow框架学习笔记\\1. Tensorflow2.0基础.md D:\\Project\\Github.io\\记事本\\学习笔记\\Tensorflow框架学习笔记\\2. TensorFlow2.0进阶.md D:\\Project\\Github.io\\记事本\\学习笔记\\Tensorflow框架学习笔记\\3. TensorFlow2.0神经网络实现.md D:\\Project\\Github.io\\记事本\\学习笔记\\Tensorflow框架学习笔记\\4. TensorFlow2.0Keras高层接口.md D:\\Project\\Github.io\\记事本\\学习笔记\\Tensorflow框架学习笔记\\Tensorflow简介.md D:\\Project\\Github.io\\记事本\\学习笔记\\Tensorflow框架学习笔记\\Tensorflow计算图.md D:\\Project\\Github.io\\记事本\\学习笔记\\Tensorflow框架学习笔记\\Windows下多版本CUDA.md D:\\Project\\Github.io\\记事本\\学习笔记\\亮牛开发笔记\\LN882H开发笔记.md D:\\Project\\Github.io\\记事本\\学习笔记\\华为生态学习笔记\\华为云相关产品知识.md D:\\Project\\Github.io\\记事本\\学习笔记\\华为生态学习笔记\\对象存储服务OBS.md D:\\Project\\Github.io\\记事本\\学习笔记\\华为生态学习笔记\\小熊派折腾ing.md D:\\Project\\Github.io\\记事本\\学习笔记\\华为生态学习笔记\\昇腾AI处理器架构.md D:\\Project\\Github.io\\记事本\\学习笔记\\华为生态学习笔记\\昇腾CANN训练营第一期-应用营第一周作业.md D:\\Project\\Github.io\\记事本\\学习笔记\\华为生态学习笔记\\昇腾CANN训练营第一期-应用营第三周作业.md D:\\Project\\Github.io\\记事本\\学习笔记\\华为生态学习笔记\\昇腾CANN训练营第一期-应用营第二周作业.md D:\\Project\\Github.io\\记事本\\学习笔记\\华为生态学习笔记\\昇腾CANN训练营第二期-应用营第一周作业.md D:\\Project\\Github.io\\记事本\\学习笔记\\华为生态学习笔记\\昇腾CANN训练营第二期-模型营第一周作业.md D:\\Project\\Github.io\\记事本\\学习笔记\\华为生态学习笔记\\零基础体验华为云IOT平台的心得体会.md D:\\Project\\Github.io\\记事本\\学习笔记\\图像处理学习笔记\\WDR宽动态.md D:\\Project\\Github.io\\记事本\\学习笔记\\图像处理学习笔记\\为什么要进行图像编码.md D:\\Project\\Github.io\\记事本\\学习笔记\\图像处理学习笔记\\图像处理.md D:\\Project\\Github.io\\记事本\\学习笔记\\图像处理学习笔记\\图像滤波去噪.md D:\\Project\\Github.io\\记事本\\学习笔记\\图像处理学习笔记\\图像物体分类.md D:\\Project\\Github.io\\记事本\\学习笔记\\嵌入式单片机学习笔记\\Airkiss原理.md D:\\Project\\Github.io\\记事本\\学习笔记\\嵌入式单片机学习笔记\\[Jlink]错误合集.md D:\\Project\\Github.io\\记事本\\学习笔记\\嵌入式单片机学习笔记\\什么是MCU.md D:\\Project\\Github.io\\记事本\\学习笔记\\操作系统学习笔记\\win10重装系统.md D:\\Project\\Github.io\\记事本\\学习笔记\\操作系统学习笔记\\什么是句柄.md D:\\Project\\Github.io\\记事本\\学习笔记\\操作系统学习笔记\\内核态与用户态.md D:\\Project\\Github.io\\记事本\\学习笔记\\操作系统学习笔记\\动态链接和静态链接.md D:\\Project\\Github.io\\记事本\\学习笔记\\操作系统学习笔记\\虚拟内存.md D:\\Project\\Github.io\\记事本\\学习笔记\\操作系统学习笔记\\软链接和硬链接.md D:\\Project\\Github.io\\记事本\\学习笔记\\数字电路学习笔记\\数字电子技术基础大杂烩.md D:\\Project\\Github.io\\记事本\\学习笔记\\数学学习笔记\\高等数学习题.md D:\\Project\\Github.io\\记事本\\学习笔记\\数学建模学习笔记\\数学建模-TOPSIS法.md D:\\Project\\Github.io\\记事本\\学习笔记\\数学建模学习笔记\\数学建模-层次分析法.md D:\\Project\\Github.io\\记事本\\学习笔记\\数学建模学习笔记\\数学建模-插值算法.md D:\\Project\\Github.io\\记事本\\学习笔记\\数据库学习笔记\\数据库SQL语句.md D:\\Project\\Github.io\\记事本\\学习笔记\\数据结构学习笔记\\数据结构.md D:\\Project\\Github.io\\记事本\\学习笔记\\数据结构学习笔记\\数据结构—不相交集数据结构.md D:\\Project\\Github.io\\记事本\\学习笔记\\数据结构学习笔记\\数据结构—二叉树.md D:\\Project\\Github.io\\记事本\\学习笔记\\数据结构学习笔记\\数据结构—优先队列.md D:\\Project\\Github.io\\记事本\\学习笔记\\数据结构学习笔记\\数据结构—图论.md D:\\Project\\Github.io\\记事本\\学习笔记\\数据结构学习笔记\\数据结构—排序算法.md D:\\Project\\Github.io\\记事本\\学习笔记\\数据结构学习笔记\\数据结构—栈与队列.md D:\\Project\\Github.io\\记事本\\学习笔记\\数据结构学习笔记\\数据结构—高级字典结构.md D:\\Project\\Github.io\\记事本\\学习笔记\\机器学习笔记\\决策树.md D:\\Project\\Github.io\\记事本\\学习笔记\\机器学习笔记\\模型评估与选择.md D:\\Project\\Github.io\\记事本\\学习笔记\\机器学习笔记\\特征选择与稀疏学习.md D:\\Project\\Github.io\\记事本\\学习笔记\\机器学习笔记\\线性回归.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\img2col.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\LeNet_5.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\VOC数据集转COCO数据集.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\VOTT——数据集标注工具.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\YOLO-V1.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\YOLO-V2.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\YOLO-V3.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\什么是算子.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\卷积神经网络的结构和卷积原理.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\如何理解卷积神经网络.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\深层的神经网络.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\深度可分离卷积.md D:\\Project\\Github.io\\记事本\\学习笔记\\深度学习笔记\\深度学习_过拟合.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\分治算法.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\分治算法求解循环赛日程表问题.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\动态规划.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\动态规划求解多段图最短路径问题.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\动态规划求解最长公共子序列问题.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\动态规划求解矩阵连乘的最佳序列和最少次数.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\动态规划求解背包问题.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\回溯法.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\回溯法求解八皇后问题.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\排列的字典序.md D:\\Project\\Github.io\\记事本\\学习笔记\\算法学习笔记\\类快排寻找第k小元素.md D:\\Project\\Github.io\\记事本\\学习笔记\\计算机网络学习笔记\\HTTP协议.md D:\\Project\\Github.io\\记事本\\学习笔记\\计算机网络学习笔记\\什么叫数据帧.md D:\\Project\\Github.io\\记事本\\学习笔记\\计算机网络学习笔记\\端口映射.md D:\\Project\\Github.io\\记事本\\学习笔记\\论文阅读理解笔记\\《Deep Retinex Decomposition for Low-Light Enhancement》解读.md D:\\Project\\Github.io\\记事本\\学习笔记\\论文阅读理解笔记\\《EfficientNet》.md","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python常用库","slug":"Python常用库","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%B8%B8%E7%94%A8%E5%BA%93/"}]},{"title":"类型注解支持typing","slug":"[Python常用库]类型注解支持typing","date":"2022-09-09T07:13:36.765Z","updated":"2022-09-09T07:13:36.766Z","comments":true,"path":"2022/09/09/python-chang-yong-ku-lei-xing-zhu-jie-zhi-chi-typing/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-chang-yong-ku-lei-xing-zhu-jie-zhi-chi-typing/","excerpt":"","text":"类型注解支持typing模块Python不像C++和C所有函数、变量、参数的类型都需要严格指定，这样就会导致我们可能不清楚函数参数类型或者返回值类型，很有可能导致一些类型没有指定方法，在写完代码一段时间后回过头看代码，很可能忘记了自己写的函数需要传什么参数，返回什么类型的结果，就不得不去阅读代码的具体内容，降低了阅读的速度，typing模块可以很好的解决这个问题。 这个模块提供对类型提示的==运行时==支持 Python 运行时并不强制标注函数和变量类型。类型标注可被用于第三方工具，比如类型检查器、集成开发环境、静态检查器等。 typing的主要作用有： 类型检查，防止运行时出现参数、返回值类型不符。 作为开发文档附加说明，方便使用者调用时传入和返回参数类型。 模块加入不会影响程序的运行不会报正式的错误，pycharm支持typing检查错误时会出现黄色警告。 参考资料 typing —— 类型注解支持 — Python 3.10.6 文档 Python中typing模块详解 - 简书 (jianshu.com)","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python常用库","slug":"Python常用库","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%B8%B8%E7%94%A8%E5%BA%93/"}]},{"title":"数据处理相关","slug":"[Python常用库]数据处理相关","date":"2022-09-09T07:13:36.760Z","updated":"2022-09-09T07:13:36.760Z","comments":true,"path":"2022/09/09/python-chang-yong-ku-shu-ju-chu-li-xiang-guan/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-chang-yong-ku-shu-ju-chu-li-xiang-guan/","excerpt":"","text":"数据处理相关函数调用1、Numpy模块Numpy是一个科学计算的基础模块。不但能完成科学计算任务，也能被用作有效的多维数据容器，用于存储和处理大型矩阵 Numpy的数据容器能保存任意类型的数据，这是Numpy可以无并快速地整合各种数据。在性能上比python自身的前台列表结构要高效得多 Numpy tile函数Numpy array函数Numpy argsort函数Numpy sum函数Numpy zeros函数Numpy shape函数注：shape函数当矩阵二维时才有shape[1]返回列的值，当矩阵一维时shape[0]即是一维数组（矩阵）中元素的个数，即返回列数Numpy reshape函数Numpy 矩阵索引方式Numpy 矩阵行列索引方式注：三维矩阵索引时先是对第三维度索引然后是对第二维度索引，最后是对第一维度索引Numpy.c_和Numpy.r_的用法Numpy矩阵点积函数返回的两个数组的内积 1.创建数组Numpy有多种方法去创建数组，例如通过元组和列表。 eg：通过列表创建数组 import Numpy as np arr1 = np.arrgy([2,3,4]) print(arr1) [2,3,4] eg:通过元组创建数组 arr2 = np.arrgy((1.3,9,2.0),(7,6,1)) print(arr2) [[1.3 9. 2.] [7. 6. 1.]] eg:生成零矩阵 arr3 = np.zeros((2,3)) print(arr3) [[0. 0. 0.] [0. 0. 0.]] eg:生成三维的单元矩阵 arr4 = np.identity(3) print(arr4) [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] eg:生成每个元素都在[0,1]之间的随机矩阵 arr5 = np.random.random(size = (2,3)) print(arr5) [[0.31654004 0.87056975 0.29050563] [0.55267505 0.59191276 0.20174988]] 2. 访问数组创建数组后，Numpy有很多方法接口取访问数组的属性。通过Numpy索引，切片，迭代器方法能够快速灵活地访问数组 3. 数组的运算Numpy的运算是相当方便高效的，其运算符是针对整个数组，比起用for循环，Numpy的运算方法在速度上要优秀得多，如果数组还是一个矩阵，还支持矩阵的求逆，转置的操作 在Numpy中矩阵相乘有两种方式： 普通乘法 矩阵乘法：np.dot(矩阵1，矩阵2....) 返回逆矩阵：np.linalg.inv(矩阵)按行累计总和：矩阵.cumsum(axis = 1) 4. Numpy的通用函数许多数学函数在Numpy上都有实现，如sin，cos。 在Numpy中这些被称为通用函数。 通用函数是针对整个Numpy数组的，因此我们不需要对数组的每个元素都进行一次操作，他们都是以Numpy数组作为输出的eg: arr9 = [[2,1],[1,2]] print np.exp(arr9) [[7.3890561 2.71828183] [2.71828183 7.3890561]]#以数组arr9的每个元素作为函数的自变量输入，输出结果也由数组显示 print np.sin(arr9) [[0.90929743 0.84147098] [0.84147098 0.90929743]] print np.sqrt(arr9) [[1.41421356 1.] [1. 1.41421356]]'[''] 5. 数组的合并与分割arr9 = [[2 1] [1 2]] arr10 = [[1 2] [3 4]] eg:合并：np.vstack(arr9,arr10)、np.hstack(arr9,arr10) arr11 = np.vstack(arr9,arr10)#纵向合并数组，由于与堆栈类似，命名为vstack print(arr11) [[2 1] [1 2] [1 2] [3 4]] arr12 = np.hstack(arr9,arr10)#横向合并数组 print(arr12) [[2 1 1 2] [1 2 3 4]] eg:分割 print np.hsplit(arr12,2)#将数组横向分为两部分 [array([[2,1], [1,2]]), array([[1,2],[3,4]])] print np.vsplist(arr1,2)#将数组纵向分为两部分 [array([[2,1], [1,2]]), array([[1,2],[3,4]])] 2、pandas模块pandas模块是一个强大的数据分析和处理工具。它提供快速，灵活，富有表现力的数据结构，能为复杂情形下的数据提供坚实的基础分析功能。 所谓复杂情形可能有以下三种： 数据库表或Excel表，包含了多列不同数据类型的数据（如数字，文字） 时间序列类型的数据，包括有序和无序的情形，甚至是频率不固定的情形 任意的矩阵型/二维表/观测数据统计，允许独立的行或列带有标签 pandas有两种常用的工具数据结构：Series和DataFrame Series是一种一维的数组型对象，包含了一个值序列，并包含了数据标签，称为索引，在某种程度上可以看成是一个表格中的一列数据 DataFrame表示的是矩阵的数据表，每一列可以是不同是值类型，在某种程度上可以看作是包含一列列数据的表，一般从csv文件导入的就是这种格式的，因此要主要掌握这种数据结构的索引方式，可以利用分层索引的方式展示更高维的数据 1.创建数据框pd.DataFrame(data)import pandas as pd date = {'id':['Jack','Sarah','Mike']. 'age':[18,35,20], 'cash':[10.53,500.7,13.6]} df = pd.DataFrame(data) print(df) 序号 age cash id 0 18 10.53 Jack 1 35 500.70 Sarah 2 20 13.60 Mike df2 = pd.DataFrame(data,colims['id','age','cash'],index=['one','two','three']) print(df2) 序号 id age cash one Jack 18 10.53 two Sarah 35 500.70 three Mike 20 13.60 print df2['id'] 0 Jack 1 Sarah 2 Mike 2.创建系列pd.Series()s = pd.Series({'a':4,'b':9,'c':16},name = 'number') print s a 4 b 9 c 16 name:number,dtype:int64 3. 系列的访问 按下标访问 print s[0] 4 print s[:3]#切片 a 4 b 9 c 16 name:number,dtype:int64 按索引访问 类似于数组，系列支持按索引访问，更有趣的是，系列还支持雷士字典的访问方式————按键值（列名）访问 print s['a'] 4 s['d'] = 25#如果系列本身没有这个键值，则会新增一行 print s a 4 b 9 c 16 d 25 name:number,dtype:int64 系列同样支持向量化操作，也就是说我们能够同时对一个系列的所有值执行同样的操作，一致地应用某种方法 4. 数据框的基础数据操作数据框可被看作是一个字典，其中字典的键是系列对应的名字（列名），字典的取值是系列的所有观测值 pd.read_.csv()：将.csv文件中的数据读入内存，快速构建数据框 pd.concat()：按横向或纵向方向合并两个pandas数据结构 pd.get_dummies()：将类别变量转换为独热编码 Series.isnull()：判断某个系列中是否有空值 Series.is_unique：判断某个系列的所有值是否存在相等 Series.value_counts()：统计某个系列中所有取值出现的次数 DataFrame.mean()：按行或按列分别计算平均值 DataFrame.dropna()：删除所有缺失数据的行或列 DataFrame.drop_duplicates()删除所有重复的行 DataFrame.head()：默认返回数据框中的前5行，以验证数据样式 DataFrame.tail()：默认返回数据框中的最后5行 3、SciPy模块 Scipy库","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python常用库","slug":"Python常用库","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%B8%B8%E7%94%A8%E5%BA%93/"}]},{"title":"序列化pickle","slug":"[Python常用库]序列化pickle","date":"2022-09-09T07:13:36.744Z","updated":"2022-09-09T07:13:36.744Z","comments":true,"path":"2022/09/09/python-chang-yong-ku-xu-lie-hua-pickle/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-chang-yong-ku-xu-lie-hua-pickle/","excerpt":"","text":"序列化1、pickle序列化：把对象转换为字节序列的过程称为对象的序列化 反序列化：把字节序列恢复为对象的过程称为对象的反序列化 1.什么情况下需要序列化？ 当你想把的内存中的对象状态保存到一个文件中或者数据库中时候； 当你想用套接字在网络上传送对象的时候； 当你想通过RMI传输对象的时候； (最常用的可能就存数据库的) 2.使用方法pickle.dump(obj, file, [,protocol]) 将所需保存对象序列化 注释：序列化对象，将对象obj保存到文件file中去。 参数protocol是序列化模式，默认是0（ASCII协议，表示以文本的形式进行序列化），protocol的值还可以是1和2（1和2表示以二进制的形式进行序列化。其中，1是老式的二进制协议；2是新二进制协议）。 file表示保存到的类文件对象，file必须有write()接口，file可以是一个以’w’打开的文件或者是一个StringIO对象，也可以是任何可以实现write()接口的对象。 pickle.load(file) 从文件中读取，并返序列化调用保存对象，并反序列化让其变为原来的样子 注释：反序列化对象，将文件中的数据解析为一个python对象。file中有read()接口和readline()接口","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python常用库","slug":"Python常用库","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%B8%B8%E7%94%A8%E5%BA%93/"}]},{"title":"面向对象","slug":"[Python学习]面向对象","date":"2022-09-09T07:13:36.738Z","updated":"2022-09-09T07:13:36.738Z","comments":true,"path":"2022/09/09/python-xue-xi-mian-xiang-dui-xiang/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-xue-xi-mian-xiang-dui-xiang/","excerpt":"","text":"“在python中一切皆为对象” 面向对象是把构成问题的事务分解为各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为 面向对象与面向过程的区别以五子棋问题为例： 面向过程的设计思路是首先分析问题的步骤： 1.开始游戏 2.黑子先走 3.绘制画面 4.判断输赢 5.轮到白子 6.绘制画面 7.判断输赢 8.返回2步骤 9.输出结果 面向对象的设计思路整个五子棋可以分为： 1.黑白双方，两者的行为是一致的 2.棋盘系统，负责绘制画面 3.规则系统，负责判断诸如犯规输赢等第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到棋子的输入就要负责在棋盘上显示这种变化，同时利用第三类对象对棋盘进行判定。可以明显地看出面向对象是以功能来划分问题的 面向对象的优点 数据抽象的概念可以在保持外部接口不变的情况下改变内部实现，从而减少甚至避免对外界的干扰 通过继承可以大幅减少冗余代码，并方便的扩展现有代码，提高代码效率，也降低出错概率，降低了软件维护的难度 结合面向对象分析，面向对象设计，允许将问题域中的对象直接映射到程序中，减少软件开发过程中中间环节的转换过程 python的类 ==在python的面向对象实现中，类是非常重要的一个组成部分== python的类提供了一种组合数据和功能的方法，也提供了面向对象编程的所有特性：类继承机制允许多个基类，派生类可以覆盖它基类的任何方法，还具备了python动态语言的特性，可以在运行时创建，也可以在创建之后修改定义类的方式： class ClassName(): 类的数据成员和方法前面说到类能组合数据和功能，那么数据和功能以何种方式存在类里面的呢？ 类中有一种叫做数据成员的东西，数据一般就是由这些成员表达出来的（除了直接传入类的数据），就像C语言那样声明了一个变量，开辟出空间，来存储数据一样。成员引用的形式为：obj.xxx obj可以是类（类名），也可以是类的实例化对象 类中另一样东西可以表示功能，它被称为方法。类中的方法就是在类声明的空间内定义的函数，通过函数来实现功能，定义方式和函数的定义方式一样，但是在参数处，要加上关键词self作为形式参数，来接收类的实例化对象，这就是方法的特殊之处，在实例化对象调用类内方法时，实例化对象会作为第一个参数传入方法中，这就是self在任何形参之前的原因 注意： 在类内调用类内成员或者方法时，要在前面加上self，格式为self.xxx 类的实例化对象类的实例化使用函数表示法。可以把类对象视为返回该类的一个新实例的不带参数的函数。 class sample(): a = 1 def test(self): print(\"This is a test\") b = sample() 像上面sample是类对象的名称，将它当作函数来运行时，类对象将会返回一个新的实例，并将这个实例赋值给局部变量b，这样就完成了类的实例化实例对象可以引用类内的成员，也可以调用类内的方法 在实际使用时，为了简化代码量，希望类的实例能更符合需要，因此会创建带有特定初始状态的自定义实例，在类的定义中会包含一个名为__init__()的方法，当类中定义了__init__()方法时，在类的实例化操作会自动为新创建的类实例发起调用__init__()，当然__init__()方法还可以由额外参数以实现更高灵活性。在这种情况下，在类实例化时就需要将所需的参数传入才能创建新的类实例 根据上述可知，self表示实例化对象，因此在__init__()方法初始化时，可以将任何属性==绑定==到实例化对象中，在创建实例对象调用__init__()方法时，不需要将实例化对象作为参数传给形参self，这是因为python解释器自己会把实例对象传入self中 类变量和实例变量class sample(): alist = [] def __init__(self,name): self.name = name def add_list(self,name1): alist.append(name1) test = sample(\"LiHua\") test1 = sample(\"XiaoMing\") test.add_list(\"1\") test1.add_list(\"2\") print(test.alist) out:[\"1\",\"2\"] 上述例子中，alist是==定义在__init__()函数之外==的一个列表，这就是类变量，这是所有的类实例对象所共用的数据，就存储在类变量中，这样的变量不能被self修饰，但是在实际使用一般是使用实例变量 class sample(): def __init__(self,name): self.name = name self.alist = [] def add_list(self,name1): self.alist.append(name1) test = sample(\"LiHua\") test1 = sample(\"XiaoMing\") test.add_list(\"1\") test1.add_list(\"2\") print(test.alist) print(test1.alist) out: [\"1\"] [\"2\"] 类的继承定义继承的格式： 单继承： class DerivedClassName(BaseClassName): 多继承： class DerivedClassName(BaseClassName1,BaseClassName2,BaseClassName3....) 其中BaseClassName必须定义于包含派生类定义的作用域中注意： 多继承继承的基类中不能出现一个类与另一个类的父类相同，否则将报错 class A pass class B(A): pass class C(B,A): pass test=C() out: TypeError: Cannot create a consistent method resolution 类的继承的使用方法： class people(): def __init__(self,name,age,weight): self.name = name self.age = age self.weight = weight def speak(self): print(\"%s说：我%d岁。\"%(self.name,self.age)) class student(people): def __init__(self,name,age,weight,grade): \"调用父类的构造函数\" people.__init__(name,age,weight) self.grade = grade \"重写父类的方法\" def speak(self): print(\"%s说：我%d岁了，我在读%d年级\"%(self.name,self.age,self.grade)) s = student(\"LiHua\",10,60,1) s.speak() out: LiHua说：我10岁了，我在读1年级 要想知道了解类的继承，首先要知道类的继承机制：MRO继承机制 继承机制MROclass people(): def __init__(self): print(\"This is init function of people\") class students(people): def __init__(self): super().__init__() print(\"This is init function of students\") class teachers(people): def __init__(self): super().__init__() print(\"This is init function of teachers\") class all(students,teachers): def __init__(self): super().__init__() print(\"This is init function of all\") print(all.__mro__) out: (&lt;class '__main__.all'&gt;, &lt;class '__main__.students'&gt;, &lt;class '__main__.teachers'&gt;, &lt;class '__main__.people'&gt;, &lt;class 'object'&gt;) MRO主要用于在多继承时判断调用的数据成员来自哪个类，对于每个定义的类，python会计算出一个方法解析顺序（MRO）的列表，而MRO是以元组的结构来储存的，元组中的元素为当前类的所有父类，在元组中的顺序为当前类为子类，父类排列在其后，按这样的方式依次排列，就像上面的(&lt;class '__main__.all'&gt;, &lt;class '__main__.students'&gt;, &lt;class '__main__.teachers'&gt;, &lt;class '__main__.people'&gt;, &lt;class 'object'&gt;) 接下来，我们来了解一下super()函数在多继承类的执行过程： class people(): def __init__(self): \"第五步\" print(\"This is init function of people\") class students(people): def __init__(self): \"第三步\" super().__init__() \"第七步\" print(\"This is init function of students\") class teachers(people): def __init__(self): \"第四步\" super().__init__() \"第六步\" print(\"This is init function of teachers\") class all(students,teachers): def __init__(self): \"第二步\" super().__init__() \"第八步\" print(\"This is init function of all\") class test(all): def __init__(self): \"第一步\" super().__init__() \"第九步\" print(\"This is init function of test\") a = test() print(test.mro()) out: This is init function of people This is init function of teachers This is init function of students This is init function of all This is init function of test [&lt;class '__main__.test'&gt;, &lt;class '__main__.all'&gt;, &lt;class '__main__.students'&gt;, &lt;class '__main__.teachers'&gt;, &lt;class '__main__.people'&gt;, &lt;class 'object'&gt;] 看到上面的输出，感觉和递归有点相似，难道super()函数的执行是一个递归的过程吗？ 其实不然，首先要知道当使用super()函数时，它会从MRO当前类的下一个类开始搜索，根据上面输出的MRO列表，假如在类students中使用super()函数，它只会从[&lt;class '__main__.students'&gt;, &lt;class '__main__.teachers'&gt;, &lt;class '__main__.people'&gt;, &lt;class 'object'&gt;]这些类中依次搜索，直到搜索到要查找的数据成员或者方法时停止搜索并执行所搜索到的成员或者方法，具体步骤在上面已经标出来了","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"装饰器","slug":"[Python学习]装饰器","date":"2022-09-09T07:13:36.725Z","updated":"2022-09-09T07:13:36.725Z","comments":true,"path":"2022/09/09/python-xue-xi-zhuang-shi-qi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-xue-xi-zhuang-shi-qi/","excerpt":"","text":"###1. 闭包函数 在看装饰器之前，我们先来搞清楚什么是闭包函数。python是一种面向对象的编程语言，在python中一切皆对象，这样就使得变量所拥有的属性，函数也同样拥有。这样我们就可以理解在函数内创建一个函数的行为是完全合法的。这种函数被叫做内嵌函数，这种函数只可以在外部函数的作用域内被正常调用，在外部函数的作用域之外调用会报错。而如果内部函数里引用了外部函数里定义的对象（甚至是外层之外，但不是全局变量），那么此时内部函数就被称为闭包函数。闭包函数所引用的外部定义的变量被叫做自由变量。闭包从语法上看非常简单，但是却有强大的作用。闭包可以将其自己的代码和作用域以及外部函数的作用结合在一起。下面给出一个简单的闭包的例子： def count(): a = 1 b = 1 def sum(): c = 1 return a + c # a - 自由变量 return sum ###总结：什么函数可以被称为闭包函数呢？主要是满足两点：函数内部定义的函数；引用了外部变量但非全局变量。 ###2. python装饰器 有了闭包函数的概念，我们再去理解装饰器会相对容易一些。python装饰器本质上就是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外的功能，装饰器的返回值也是一个函数对象（函数的指针）。装饰器函数的外部函数传入我要装饰的函数名字，返回经过修饰后函数的名字；内层函数（闭包）负责修饰被修饰函数。从上面这段描述中我们需要记住装饰器的几点属性，以便后面能更好的理解： 实质： 是一个函数 参数：是你要装饰的函数名（并非函数调用） 返回：是装饰完的函数名（也非函数调用） 作用：为已经存在的对象添加额外的功能 特点：不需要对对象做任何的代码上的变动python装饰器有很多经典的应用场景，比如：插入日志、性能测试、事务处理、权限校验等。装饰器是解决这类问题的绝佳设计。并且从引入中的列子中我们也可以归纳出：装饰器最大的作用就是对于我们已经写好的程序，我们可以抽离出一些雷同的代码组建多个特定功能的装饰器，这样我们就可以针对不同的需求去使用特定的装饰器，这时因为源码去除了大量泛化的内容而使得源码具有更加清晰的逻辑。###函数装饰器函数的函数装饰器我们还是以为函数添加计时功能为例，讲述函数装饰器。 import time def decorator(func): def wrapper(*args, **kwargs): start_time = time.time() func() end_time = time.time() print(end_time - start_time) return wrapper @decorator def func(): time.sleep(0.8) func() # 函数调用 # 输出：0.800644397735595 在上面代码中 func是我要装饰器的函数，我想用装饰器显示func函数运行的时间。@decorator这个语法相当于 执行 func = decorator(func)，为func函数装饰并返回。在来看一下我们的装饰器函数 - decorator，该函数的传入参数是func （被装饰函数），返回参数是内层函数。这里的内层函数-wrapper，其实就相当于闭包函数，它起到装饰给定函数的作用，wrapper参数为*args, kwargs。*args表示的参数以列表的形式传入；kwargs表示的参数以字典的形式传入注意：为了不破坏原函数的逻辑，我们要保证内层函数wrapper和被装饰函数func的传入参数和返回值类型必须保持一致。**类方法的函数装饰器 import time def decorator(func): def wrapper(me_instance): start_time = time.time() func(me_instance) end_time = time.time() print(end_time - start_time) return wrapper class Method(object): @decorator def func(self): time.sleep(0.8) p1 = Method() p1.func() # 函数调用 菜鸟教程python装饰器","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"正则表达式","slug":"[Python学习]正则表达式","date":"2022-09-09T07:13:36.714Z","updated":"2022-09-09T07:13:36.715Z","comments":true,"path":"2022/09/09/python-xue-xi-zheng-ze-biao-da-shi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-xue-xi-zheng-ze-biao-da-shi/","excerpt":"","text":"正则表达式正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。 匹配的时候就算根据这个模式字符串（pattern）来找到相应的字符串中的子串，应该重点关注pattern的语法 1、正则表达式模式模式字符串使用特殊的语法来表示一个正则表达式： 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。 多数字母和数字前加一个反斜杠时会拥有不同的含义。 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。 反斜杠本身需要使用反斜杠转义。 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 ‘\\\\t’)匹配相应的特殊字符。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符 re* 匹配0个或多个的表达式 re+ 匹配1个或多个的表达式 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} ==精确匹配==n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。 re{ n,} 匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*” re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 对正则表达式分组并记住匹配的文本 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释 (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\S 匹配任意非空字符 \\s 匹配空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’ \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的内容 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式 1. 正则表达式的贪婪和非贪婪模式re?中说到非贪婪的方式来匹配0个或1个根据正则表达式re定义的片段，那么贪婪模式和非贪婪的模式是怎么样呢？ 正则表达式一般趋向于最大长度匹配，就是贪婪模式 匹配到结果就好，就少的匹配字符，就是非贪婪模式 默认情况下，正则用的都是贪婪模式，如果要使用非贪婪模式，需要在量词后面直接加上一个问号”?”，量词包括如下， {m,n}：m到n个 *：任意多个 +：一个到多个 ?：0或一个 贪婪匹配： import re result = re.findall(r'\"(.*)\"', str) out: ['../../技术学习图片\\\\xxx.jpg\" width = \"300\" height = \"200\" alt = \"检测前'] 非贪婪匹配 import re result = re.findall(r'\"(.*?)\"', str) out: ['../../技术学习图片\\\\xxx.jpg', '300', '200', '检测前'] 2. ?的使用匹配0个或1个由前面的正则表达式定义的，可以用于把少量的不希望出现的单个字符过滤掉 2、正则表达式修饰符 - 可选标志正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 3、re模块使用1. 匹配 re.match re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none。 函数语法： re.match(pattern, string, flags=0) pattern：正则表达式的模式 string：要匹配的字符串 flags：可选标志，正则表达式修饰符，用于控制正则表达式的匹配方式 eg: import re def main(): print(re.match('sb','Jf is sb')) #不在起始位置匹配 print(re.match('Jf','Jf is sb').span()) #在起始位置匹配 if __name__ == '__main__': main() out: None (0, 2) 注意： match是要求在起始位置就匹配成功的 re.search re.search 扫描整个字符串并返回第一个成功的匹配 函数语法： re.search(pattern, string, flags=0) pattern：正则表达式的模式 string：要匹配的字符串 flags：可选标志，正则表达式修饰符，用于控制正则表达式的匹配方式 eg： import re def main(): line = \"Jf is SB\" searchObj = re.search(r'(.*) is (.*)',line,re.M|re.I) if searchObj: print(\"searchObj.group( ) : \", searchObj.group()) print(\"searchObj.group(1) : \", searchObj.group(1)) print(\"searchObj.group(2) : \", searchObj.group(2)) else: print(\"Nothing found!!\") if __name__ == '__main__': main() out: searchObj.group( ) : Jf is SB searchObj.group(0) : Jf is SB searchObj.group(1) : Jf searchObj.group(2) : SB re.match与re.search的区别：re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 re.findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。 函数语法： findall(string[, pos[, endpos]]) string : 待匹配的字符串 pos : 可选参数，指定字符串的起始位置，默认为 0 endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度 import re result = re.findall(r'(\\w+)=(\\d+)', 'set width=20 and height=10') print(result) out: [('width', '20'), ('height', '10')] 通常还会搭配compile函数生成的模式来使用 import re pattern = re.compile(r'\\d+') # 查找数字 result1 = pattern.findall('JF 123 SB 456') result2 = pattern.findall('JF88sb123sb456', 0, 10) print(result1) print(result2) out: ['123', '456'] ['88', '123'] match 和 search 是匹配一次 findall 匹配所有。 re.finditer 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 函数语法： re.finditer(pattern, string, flags=0) pattern：匹配的正则表达式 string：要匹配的字符串 flags：可选标志，正则表达式修饰符，用于控制正则表达式的匹配方式 import re it = re.finditer(r\"\\d+\",\"12a32bc43jf3\") for match in it: print (match.group() ) out: 12 32 43 3 2. 获取匹配对象 group full match：group(0) group(n)：第n个分组的内容 groups 参考资料 Python 正则表达式 | 菜鸟教程 (runoob.com) 正则表达式的贪婪和非贪婪模式 - 腾讯云开发者社区-腾讯云 (tencent.com) 3. 替换分组替换 def test2(): line = \"\"\"&lt;img src=\\\"../../技术学习图片\\43.jpg\\\" width = \\\"300\\\" height = \\\"200\\\" alt = \\\"检测前\\\" align=top /&gt;\"\"\" result = re.sub(r'(img src\\s?=\\s?\")(.*?)(\")',r\"\\1%s\\3\"%\"替换\",line) print(result) searchObj = re.search(r'(img src\\s?=\\s?\")(.*?)(\")', line, re.M|re.I) print(searchObj.group(1)) print(searchObj.group(3)) if __name__ == '__main__': test2() out: img src=\" \" (img src\\s?=\\s?\")为匹配模式字符串的第一个分组，(\")为第三个分组，替换内容r\"\\1%s\\3\"%\"替换\"中的\\1表示在line匹配出的内容放在\\1的位置，在这个匹配出来的是img src=\"","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"字符串占位符","slug":"[Python学习]字符串占位符","date":"2022-09-09T07:13:36.703Z","updated":"2022-09-09T07:13:36.704Z","comments":true,"path":"2022/09/09/python-xue-xi-zi-fu-chuan-zhan-wei-fu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-xue-xi-zi-fu-chuan-zhan-wei-fu/","excerpt":"","text":"字符串占位符1、 使用%%s 字符串占位符 a = \"list\" command = \" conda %s\"%a 2、使用format函数&gt;&gt;&gt;\"{} {}\".format(\"hello\", \"world\") # 不设置指定位置，按默认顺序 'hello world' &gt;&gt;&gt; \"{0} {1}\".format(\"hello\", \"world\") # 设置指定位置 'hello world' &gt;&gt;&gt; \"{1} {0} {1}\".format(\"hello\", \"world\") # 设置指定位置 'world hello world' &gt;&gt;&gt;\"{name} {age}岁\".format(age = 7, name = '小花') # 设置参数 '小花 7岁' &gt;&gt;&gt;\"{name} {age}岁\".format( name = '小花',age = 7) # 设置参数 '小花 7岁' 参考资料 (105条消息) python字符串中占位符详解_Dream____Fly的博客-CSDN博客_python占位符","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"__init__.py的作用","slug":"[Python学习]__init__.py的作用","date":"2022-09-09T07:13:36.696Z","updated":"2022-09-09T07:13:36.696Z","comments":true,"path":"2022/09/09/python-xue-xi-init.py-de-zuo-yong/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-xue-xi-init.py-de-zuo-yong/","excerpt":"","text":"__init__.py的作用__init__.py 文件的作用是将文件夹变为一个Python模块，Python 中的每个模块的包中，都有__init__.py 文件 通常__init__.py 文件为空，但是我们还可以为它增加其他的功能。我们在导入一个包时，实际上是导入了它的__init__.py文件。这样我们可以在__init__.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入 参考资料 Python init.py 作用详解 - Data&amp;Truth - 博客园 (cnblogs.com)","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"python常用的函数和方法","slug":"[Python学习]python常用的函数和方法","date":"2022-09-09T07:13:36.690Z","updated":"2022-09-09T07:13:36.690Z","comments":true,"path":"2022/09/09/python-xue-xi-python-chang-yong-de-han-shu-he-fang-fa/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-xue-xi-python-chang-yong-de-han-shu-he-fang-fa/","excerpt":"","text":"Python常用标准库函数","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"python学习","slug":"[Python学习]python学习","date":"2022-09-09T07:13:36.683Z","updated":"2022-09-09T07:13:36.684Z","comments":true,"path":"2022/09/09/python-xue-xi-python-xue-xi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-xue-xi-python-xue-xi/","excerpt":"","text":"python中else语句不一定要与if条件搭配 for i in range(2,n+1): for item in range(2,int(sqrt(i)+1)): if i % item==0: break else: alist.append(i) 迭代器就是重复地做一些事情，可以简单的理解为循环，在python中实现了__iter__方法的对象是可迭代的，实现了next()方法的对象是迭代器，这样说起来有点拗口，实际上要想让一个迭代器工作，至少要实现__iter__方法和next方法。很多时候使用迭代器完成的工作使用列表也可以完成，但是如果有很多值列表就会占用太多的内存，而且使用迭代器也让我们的程序更加通用、优雅、pythonic。如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。使用 isgeneratorfunction 判断是否为生成器###Python bin() 函数####描述bin() 返回一个整数 int 或者长整数 long int 的二进制表示。###python序列：字典（1）内置函数dict（）通过已有数据快速创建字典，还可以根据给定的“键：值”来创建字典，还可以以给定内容为“键”，创建“值”为空的字典（2）当以指定“键”为下标为字典元素赋值时，有两个含义：一.若该键存在则表示修改该键所对应元素的值二.若该键不存在，则表示添加一个新的“键：值”，也就是添加一个元素####字典对象的函数方法update（）：将另一个字典的“键：值”一次性全部添加给当前字典对象，如果连个字典存在相同的“键”，则以另一个字典中的“值”为准对当前字典进行更新del命令可以删除整个字典也可以删除字典中指定的元素eg.del adict[‘age’]pop（）和popitem（）弹出并删除指定的元素eg.adict={‘age’:37,’sex’:’male’}adict.pop(‘age’)37adict={‘age’:37}get(，默认返回值）用来返回指定键的值clear()用于清空字典对象中的所有元素copy()返回字典对象的浅复制setdefault()用于返回指定键对应的值，如果字典中不存在该键就添加一个新元素并设置该键对应的值item()返回字典所有元素即所有“键：值”对key()返回所有键value()返回所有值globals()和locals()分别返回当前作用域内所有全局变量和局部变量的名称及值的字典###访问字典对象的数据根据提供的键作为下标就可以访问对应的值，如果字典中不存在这个键就会抛出异常，因此为了避免程序运行时引发异常而导致崩溃，最好配合条件判断（if条件等）或异常处理结构 try: print(adict['address']) except: print('Not exists') No exists) 字典对象可以实现switch的功能 def foo(var): return { 'a': 1， 'b': 2, 'c': 3, }.get(var,'error') #'error'为默认返回值，可自设置 文件操作有哪些模式？请简述各模式的作用r：只读w：只写a：追加r+：可读可写w+：可写可读a+：追加、读rb：读取字节wb：写入字节ab：追加字节rb+：字节的可读可写wb+：字节的可写可读ab+：字节的追加、读需要将None和不含任何值的空数据结构区分开0值的整型/浮点型，空字符串（‘ ’），空列表（[]）,空元组（{}），空集合（set()）都是等价于False,但是不等于Nonepython set()集合操作符号 python符号 含义 - 差集，相对补集 &amp; 交集 合集 ！= 不等于 == 等于 in 是成员关系 not in 不是成员 x^y 集合的异或，返回只被x包含或只被y包含的元素的集合 ###异常处理结构 常见异常处理结构形式 Python 提供了多种不同形式的异常处理结构,基本思路都是一致的: 先尝试运行代码,然后处理可能发生的错误 在实际使用时,可以根据需要来选择使用哪一种。 1. try-except… Python异常处理结构中最基本的结构是try.except.结构。其中try子句中的代码块包含可能会引发异常的语句,而except子句用来捕捉相应的异常。 如果try子句中的代码引发异常并被except子句捕捉,则执行except子句的代码块;如果 try 中的代码块没有出现异常则继续往下执行异常处理结构后面的代码;如果出现异常但没有被except 捕获, 则继续往外层抛出;如果所有层都没有捕获并处理该异常,则程序崩溃并将该异常呈现给最终用户,这是我们最不希望发生的事情。 该结构语法如下: try: #可能会引发异常的代码,先执行一下试试 except Exception[ as reason]: #如果try中的代码抛出异常并被except捕捉,就执行这里的代码 2.try.except.else…带有else子句的异常处理结构可以看作是一种特殊的选择结构,如果 try中的代码抛出了异常并且被某个except语句捕捉则执行相应的异常处理代码,这种情况下就不会执行else中的代码;如果try中的代码没有抛出异常, 则执行else块的代码。 该结构的语法如下: try: #可能会引发异常的代码 except Exception [ as reason]: #用来处理异常的代码 else: #如果try子句中的代码没有引发异常,就继续执行这里的代码 3.try.except.finally…在这种结构中 , 无论 try 中的代码是否发生异常,也不管抛出的异常有没有被 except语句捕获,finally子句中的代码总是会得到执行。 因此,finally中的代码常用来做一些清理工作以释放 try 子句中申请的资源。 该结构语法为 try: #可能会引发异常的代码 except Exception [ as reason]: #处理异常的代码 finally: #无论try子句中的代码是杏引发异常,都会执行这里的代码 4. 可以捕捉多种异常的异常处理结构在实际开发中,同一段代码可能会抛出多种异常,并且需要针对不同的异常类型进行相应的处理。 为了支持多种异常的捕捉和处理,Python提供了带有多个except的异常处理结构,一旦某个except捕捉到了异常,则其他的 except子句将不会再尝试捕捉异常。该结构类似于多分支选择结构,语法格式为 try: #可能会引发异常的代码 except Exception1: #处理异常类型1的代码 except Exception2: #处理异常类型2的代码 except Exception3: #处理异常类型3的代码 5.同时包含else子句、finally子句和多个except子句的异常处理结构Python异常处理结构中可以同时包含多个 except子句、else子句和 finally子句。python异常标准###python with的用法with是从Python2.5引入的一个新的语法，它是一种上下文管理协议，目的在于从流程图中把 try,except 和finally 关键字和资源分配释放相关代码统统去掉，简化try….except….finlally的处理流程。with通过__enter__方法初始化，然后在__exit__中做善后以及处理异常。所以使用with处理的对象必须有__enter__()和__exit__()这两个方法。其中__enter__()方法在语句体（with语句包裹起来的代码块）执行之前进入运行，exit()方法在语句体执行完毕退出后运行。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。With语句的基本语法格式:with expression [as target]:with_body参数说明：expression：是一个需要执行的表达式；target：是一个变量或者元组，存储的是expression表达式执行返回的结果，可选参数。with语句的工作原理：紧跟with后面的语句会被求值，返回对象的__enter__()方法被调用，这个方法的返回值将被赋值给as关键字后面的变量，当with后面的代码块全部被执行完之后，将调用前面返回对象的__exit__()方法。 with语句最关键的地方在于被求值对象必须有__enter__()和__exit__()这两个方法，那我们就可以通过自己实现这两方法来自定义with语句处理异常。 opened中的__enter__() 返回的是自身的引用，这个引用可以赋值给 as 子句中的fp变量；返回值的类型可以根据实际需要设置为不同的类型，不必是上下文管理器对象本身。exit() 方法中对变量exc_trackback进行检测，如果不为 None，表示发生了异常，返回 False 表示需要由外部代码逻辑对异常进行处理；如果没有发生异常，缺省的返回值为 None，在布尔环境中也是被看做 False，但是由于没有异常发生，exit() 的三个参数都为 None，上下文管理代码可以检测这种情况，做正常处理。exit()方法的3个参数，分别代表异常的类型、值、以及堆栈信息。 python各种转义符 转义字符|描述—|:–:|—\\（在行尾时）|续航符\\ \\ |反斜杠符号 \\ ‘|单引号 \\ “|双引号\\a|响铃\\b|退格\\e|转义\\000|空\\n|换行\\v|纵向制表\\t|横向制表\\f|换页\\oyy|八进制数yy代表的字符，例如：\\o12代表换行\\xyy|十进制数yy代表的字符，例如：\\x0a代表换行\\other|其它的字符以普通格式输出 python文件名解析——从文件名获得分类的类别python 文件名解析列表list.count函数python函数 return用法python return的用法","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"import导入机制","slug":"[Python学习]import导入机制","date":"2022-09-09T07:13:36.675Z","updated":"2022-09-09T07:13:36.676Z","comments":true,"path":"2022/09/09/python-xue-xi-import-dao-ru-ji-zhi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/python-xue-xi-import-dao-ru-ji-zhi/","excerpt":"","text":"import导入机制可以被import语句导入的对象是以下类型： 模块文件（.py文件） C或C++扩展（已编译为共享库或DLL文件） 包（包含多个模块） 内建模块（使用C编写并已链接到Python解释器中） 可以作为模块的文件类型有.py、.pyo、.pyc、.pyd、.so、.dll 在导入模块时，解释器做以下工作： 已导入模块的名称创建新的命名空间，通过该命名空间就可以访问导入模块的属性和方法。 在新创建的命名空间中执行源代码文件。 创建一个名为源代码文件的对象，该对象引用模块的名字空间，这样就可以通过这个对象访问模块中的函数及变量 参考资料 Python init.py 作用详解 - Data&amp;Truth - 博客园 (cnblogs.com)","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python学习","slug":"Python学习","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%AD%A6%E4%B9%A0/"}]},{"title":"MindSpore安装配置","slug":"MindSpore安装配置","date":"2022-09-09T07:13:36.670Z","updated":"2022-09-09T07:13:36.670Z","comments":true,"path":"2022/09/09/mindspore-an-zhuang-pei-zhi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/mindspore-an-zhuang-pei-zhi/","excerpt":"","text":"MindSpore安装配置 Anaconda或者miniconda这些环境管理软件、以及CUDA的配置在这里就不过多介绍了，环境管理软件不是必须要有但最好有，因为这不会让你的电脑环境变得一团糟，方便管理，所以还没安装的同学可以自行百度解决 首先使用 conda create -n env_name python =x.x 创建出MindSpore虚拟环境 接着激活所创建的环境 然后使用pip install https://ms-release.obs.cn-north-4.myhuaweicloud.com/1.2.0-rc1/MindSpore/cpu/ubuntu_x86/mindspore-1.2.0rc1-cp37-cp37m-linux_x86_64.whl","categories":[{"name":"MindSpore框架学习笔记","slug":"MindSpore框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/MindSpore%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"交叉编译的格式","slug":"交叉编译的格式","date":"2022-09-09T07:13:36.664Z","updated":"2022-09-09T07:13:36.664Z","comments":true,"path":"2022/09/09/jiao-cha-bian-yi-de-ge-shi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/jiao-cha-bian-yi-de-ge-shi/","excerpt":"","text":"交叉编译的格式我们已经知道源代码要成为可执行程序必须经过编译和链接的过程，开发板上的可执行程序同样需要经过编译和链接的过程，但是这个编译和链接的过程一般不会在开发板上面进行（当然，像树莓派等开发板是可以直接在开发板上面搭建编译环境的，因此树莓派可以看成是一个微型主机），因此需要准备一个主机，这个主机的操作系统一般选择的是Linux操作系统，交叉编译工具链一般搭建在Linux环境上面 1. 什么是交叉编译？交叉编译是在一个平台上生成另一个平台上的可执行代码。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。 平台（体系结构）： 举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称。 因为开发板一般为Arm结构，主机结构一般为x86的结构，而交叉编译做的事就是将在主机体系结构上开发的源代码编译出能在开发板体系结构上运行的可执行程序 2. 交叉编译工具的指令格式交叉编译工具可能会在名称上有点不一样的，具体名称看具体的交叉工具链，但是工具实现的功能基本上是相同的，甚至和gcc工具的用法也是相似的 以海思的arm-himix200-linux交叉编译工具来说，它的编译指令是arm-himix200-linux-gcc [filenames] [options] [outputfilename]（编译.c源代码的交叉编译器） options参数列表如下： 实际上主要用到的就是arm-himix200-linux-gcc 需要编译的.c源文件 -o 输出文件名 然后只需将输出的文件，通过之前介绍过的传送方式放到开发板中，在开发板中执行./输出文件名即可","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"vim指令学习","slug":"vim指令学习","date":"2022-09-09T07:13:36.657Z","updated":"2022-09-09T07:13:36.657Z","comments":true,"path":"2022/09/09/vim-zhi-ling-xue-xi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/vim-zhi-ling-xue-xi/","excerpt":"","text":"vim指令 指令格式 作用 复制多行 :x,xd 删除多行 /关键字或?关键字 查找关键字 shift+g 跳转到最后一行 :0或gg 跳转到第一行","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Ubuntu替换python版本","slug":"Ubuntu替换python版本","date":"2022-09-09T07:13:36.651Z","updated":"2022-09-09T07:13:36.652Z","comments":true,"path":"2022/09/09/ubuntu-ti-huan-python-ban-ben/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/ubuntu-ti-huan-python-ban-ben/","excerpt":"","text":"Ubuntu 安装python3及多版本切换 参考资料 Ubuntu 安装python3及多版本切换 - 慕尘 - 博客园 (cnblogs.com)","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Ubuntu Server下配置wifi","slug":"Ubuntu Server下配置wifi","date":"2022-09-09T07:13:36.647Z","updated":"2022-09-09T07:13:36.647Z","comments":true,"path":"2022/09/09/ubuntu-server-xia-pei-zhi-wifi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/ubuntu-server-xia-pei-zhi-wifi/","excerpt":"","text":"Ubuntu18.04 Server下配置wifi首先使用 ifconfig 查看网络设备，发现没有wlan的网卡 但是使用ip address查看发现是有wlan设备的（我也不懂为什么看ip能看出设备，先这样学着先） 然后启用无线网卡（假如是wlan0） sudo ifconfig wlan0 up 接着配置WiFi信息，通过修改/etc/netplan/下的YAML配置文件 sudo vim /etc/netplan/xxxxxxx.yaml 把下面的内容配置进去 network: version: 2 ethernets: eth0: dhcp4: true match: macaddress: b8:27:eb:c6:94:8f set-name: eth0 wifis: wlan0: dhcp4: true access-points: \"wifi的ssid\": password: \"wifi密码\" 配置好文件之后 需要执行下面这个命令，查看配置是否有错，如果有错它会自动回滚上次正确配置 sudo netplan try 按下Enter键确认使用配置，执行下面的命令来使配置生效 sudo netplan apply 参考资料 Ubuntu Server 18.04 连接 WIFI_elan-zhang的博客-CSDN博客_ubuntu18.04连接wifi","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Ubuntu Arm版换源","slug":"Ubuntu Arm版换源","date":"2022-09-09T07:13:36.640Z","updated":"2022-09-09T07:13:36.640Z","comments":true,"path":"2022/09/09/ubuntu-arm-ban-huan-yuan/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/ubuntu-arm-ban-huan-yuan/","excerpt":"","text":"Ubuntu Arm版换源（树莓派）[问题描述]apt-get update更新软件源之后时fail to fetch http:/ ..404 Not Found问题，通过搜索网上的资料，把各种版本的源换了一遍，还去修改了DNS，最后还是解决不了 [解决方案]查看本机架构 sudo dpkg --print-architecture 发现是arm64架构的，而之前我所在网上找的软件源都是在x86架构下的 因此把软件源更改为Arm架构下的，更换的软件源如下 18.04（阿里源） deb http://mirrors.aliyun.com/ubuntu-ports bionic main multiverse restricted universe deb http://mirrors.aliyun.com/ubuntu-ports bionic-updates main multiverse restricted universe deb http://mirrors.aliyun.com/ubuntu-ports bionic-security main multiverse restricted universe deb http://mirrors.aliyun.com/ubuntu-ports bionic-proposed main multiverse restricted universe deb http://mirrors.aliyun.com/ubuntu-ports bionic-backports main multiverse restricted universesu 20.04（阿里源） deb http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse # deb http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse 20.04（中科大源） deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-proposed main restricted universe multiverse （配置ros的时候还是中科大源能成功） 22.04（清华源） # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-proposed main restricted universe multiverse 其实就是将X86下的软件源中的ubuntu改成ubuntu-ports即可 如https://mirrors.ustc.edu.cn/*/ 上述url中的*表示占位，根据使用的架构选择（X86选择/ubuntu/，ARM等选/ubuntu-ports/） 参考资料 Ubuntu ARM版换源（树莓派） - 誠的个人站 (honestliu.com) x86/ARM架构下的Ubuntu系统换国内源_EthanYYYY的博客-CSDN博客_arm64 ubuntu 软件源","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Ubantu更改用户名","slug":"Ubantu更改用户名","date":"2022-09-09T07:13:36.632Z","updated":"2022-09-09T07:13:36.633Z","comments":true,"path":"2022/09/09/ubantu-geng-gai-yong-hu-ming/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/ubantu-geng-gai-yong-hu-ming/","excerpt":"","text":"Ubantu18.04更改用户名由于本人操作系统实验要求用户名为自己名字的拼音，而我又不想重新制作一个Ubantu镜像重新命名一遍，所以我打算在原有的虚拟机的基础上修改用户名 如果你只是在设置里修改了用户名，但是实际上/home文件下的user名字还是原来的名字，这样达不到我的要求 经过我上网查找资料，我找到了解决办法： 首先在设置里面新建一个管理员新用户B，接着注销当前用户A，登陆新建立的管理员用户B。 linux中使用 usermod 指令来修改用户的账号，修改用户账号名称的指令为 usermod -l newname oldname 可以将原来的用户名oldname 修改为新用户名newname 然后输入 gedit /etc/passwd 在最后一行找到newname对应的行，把这行用户名称全部修改成newname，改完之后保存退出 然后再输入： cd cd /home sudo mv -i oldname newname 最后注销当前用户B，选择原来的用户A登陆。并在设置里面将自己设置为管理员，删除之前建立的用户B即可 参考博客 Ubuntu 18.04更改用户名_Myliuxuwei的博客-CSDN博客](https://blog.csdn.net/weixin_43563233/article/details/112384478))","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"ubantu18.04换源","slug":"ubantu18.04换源","date":"2022-09-09T07:13:36.625Z","updated":"2022-09-09T07:13:36.626Z","comments":true,"path":"2022/09/09/ubantu18.04-huan-yuan/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/ubantu18.04-huan-yuan/","excerpt":"","text":"Ubantu18.04更换国内源更换源步骤如下： 备份源列表 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 命令行打开sources.list文件 sudo vim /etc/apt/sources.list 修改sources.list文件 sudo vim /etc/apt/sources.list 阿里云源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 网易云源 deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse 中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 官方源 #deb cdrom:[Ubuntu 18.04.4 LTS _Bionic Beaver_ - Release amd64 (20200203.1)]/ bionic main restricted # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://cn.archive.ubuntu.com/ubuntu/ bionic main restricted # deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates main restricted # deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team. Also, please note that software in universe WILL NOT receive any ## review or updates from the Ubuntu security team. deb http://cn.archive.ubuntu.com/ubuntu/ bionic universe # deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic universe deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates universe # deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-updates universe ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## multiverse WILL NOT receive any review or updates from the Ubuntu ## security team. deb http://cn.archive.ubuntu.com/ubuntu/ bionic multiverse # deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic multiverse deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates multiverse # deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-updates multiverse ## N.B. software from this repository may not have been tested as ## extensively as that contained in the main release, although it includes ## newer versions of some applications which may provide useful features. ## Also, please note that software in backports WILL NOT receive any review ## or updates from the Ubuntu security team. deb http://cn.archive.ubuntu.com/ubuntu/ bionic-backports main restricted universe multiverse # deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-backports main restricted universe multiverse ## Uncomment the following two lines to add software from Canonical's ## 'partner' repository. ## This software is not part of Ubuntu, but is offered by Canonical and the ## respective vendors as a service to Ubuntu users. # deb http://archive.canonical.com/ubuntu bionic partner # deb-src http://archive.canonical.com/ubuntu bionic partner deb http://security.ubuntu.com/ubuntu bionic-security main restricted # deb-src http://security.ubuntu.com/ubuntu bionic-security main restricted deb http://security.ubuntu.com/ubuntu bionic-security universe # deb-src http://security.ubuntu.com/ubuntu bionic-security universe deb http://security.ubuntu.com/ubuntu bionic-security multiverse # deb-src http://security.ubuntu.com/ubuntu bionic-security multiverse 保存：ESC+：wq！ 更新源 sudo apt-get update","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Shell脚本","slug":"Shell脚本","date":"2022-09-09T07:13:36.616Z","updated":"2022-09-09T07:13:36.617Z","comments":true,"path":"2022/09/09/shell-jiao-ben/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shell-jiao-ben/","excerpt":"","text":"Shell脚本文件 Shell脚本文件是指终端执行的指令放在文件中，然后使用Shell来调用该文件，其中Shell脚本文件就有以.sh为后缀的文件，==在Shell脚本中可以使用任何的终端指令== 1. .sh文件语法 #!符合#!后面的参数，告诉我们该Shell脚本用什么Shell来执行，例如：#!/bin/bash，表示该脚本文件以/bin/bash来执行（Shell有很多种，/bin/bash只是其中一种） 注释 #：注意与#!，#表示的是注释的意思 多行注释： :&lt;&lt;EOF 注释内容... 注释内容... 注释内容... EOF 变量在Shell脚本中，对变量赋值可以这样写：a = \"Hello World!\"，而对于变量的引用也和makefile的形式相似（也不知道是不是makefile学shell脚本的），输出变量a只需要echo $a，但是为了让变量引用更加准确，应该这样写：echo ${a}，也就是使用花括号括起来 流程控制 条件控制 if [……];then 如果条件为真则执行then后面的部分 elif [……];then 如果条件为真则执行then后面的部分 else 执行else部分内容 fi 条件判断结束 循环控制 for循环 格式： for var in item1 item2 ... itemN do command1 command2 ... commandN done 样例： #!/bin/bash for loop in 1 2 3 4 5 do echo \"The value is: $loop\" done while循环 格式： while condition do command done 样例： #!/bin/bash int=1 while(( $int&lt;=5 )) do echo $int let \"int++\" done until 循环 until 循环执行一系列命令直至条件为 true 时停止。 格式： until condition do command done case … esac 和C语言的switch … case 差不多，每个 case 分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记 格式： case 值 in 模式1) command1 command2 ... commandN ;; 模式2） command1 command2 ... commandN ;; esac break和continue break命令允许跳出所有循环 continue命令不会跳出所有循环，仅仅跳出当前循环 传递参数说明 $$：Shell本身的PID（ProcessID） $!：Shell最后运行的后台Process的PID $?：最后运行的命令的结束代码（返回值） $-：使用Set命令设定的Flag一览 $*：所有参数列表。如”$*“用「”」括起来的情况、以”$1 $2 … $n“的形式输出所有参数 $@：所有参数列表。如”$@“用「”」括起来的情况、以”$1“ “$2“ … “$n“ 的形式输出所有参数 $#：添加到Shell的参数个数 $0：Shell本身的文件名 $1~$n：添加到Shell的各参数值。$1是第1参数、$2是第2参数… 参考资料 运算符 关系运算符 运算符 说明 -eq 检测两个数是否相等，相等返回 true -ne 检测两个数是否不相等，不相等返回 true -gt 检测左边的数是否大于右边的，如果是，则返回 true -lt 检测左边的数是否小于右边的，如果是，则返回 true -ge 检测左边的数是否大于等于右边的，如果是，则返回 true -le 检测左边的数是否小于等于右边的，如果是，则返回 true 没有记完 参考资料 自定义函数格式： [ function ] funname [()] { action; [return int;] } 样例： funWithReturn(){ echo \"这个函数会对输入的两个数字进行相加运算...\" echo \"输入第一个数字: \" read aNum echo \"输入第二个数字: \" read anotherNum echo \"两个数字分别为 $aNum 和 $anotherNum !\" return $(($aNum+$anotherNum)) } funWithReturn echo \"输入的两个数字之和为 $? !\" 函数参数 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如： funWithParam(){ echo \"第一个参数为 $1 !\" echo \"第二个参数为 $2 !\" echo \"第十个参数为 $10 !\" echo \"第十个参数为 ${10} !\" echo \"第十一个参数为 ${11} !\" echo \"参数总数有 $# 个!\" echo \"作为一个字符串输出所有参数 $* !\" } funWithParam 1 2 3 4 5 6 7 8 9 34 73 参考资料","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"MobaXterm远程连接ubuntu","slug":"MobaXterm远程连接ubuntu","date":"2022-09-09T07:13:36.610Z","updated":"2022-09-09T07:13:36.611Z","comments":true,"path":"2022/09/09/mobaxterm-yuan-cheng-lian-jie-ubuntu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/mobaxterm-yuan-cheng-lian-jie-ubuntu/","excerpt":"","text":"MobaXterm远程连接Ubuntu问题描述在某一天，我通过MobaXterm远程连接树莓派上的Ubuntu的时候，发现无法连接上 解决方案经过多方查阅资料发现，需要远程连接的设备必须和连接设备位于同一个网段之下，不然就无法ping通，然后发现只是我连接的局域网和树莓派所连接的局域网不相同的原因，因此将wifi改为和树莓派同样的wifi就可以成功连接上树莓派","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Markfile的作用","slug":"Markfile的作用","date":"2022-09-09T07:13:36.605Z","updated":"2022-09-09T07:13:36.605Z","comments":true,"path":"2022/09/09/markfile-de-zuo-yong/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/markfile-de-zuo-yong/","excerpt":"","text":"Makefile的作用1. Makefile是什么？一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，也可以执行操作系统的命令 Makefile 文件描述了整个工程的编译、连接等规则。其中包括：工程中的哪些源文件需要编译以及如何编译、需要创建哪些库文件以及如何创建这些库文件、如何最后产生我们想要的可执行文件。尽管看起来可能是很复杂的事情，但是为工程编写Makefile 的好处是能够使用一行命令来完成“自动化编译”，一旦提供一个（通常对于一个工程来说会是多个）正确的 Makefile，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。 编译整个工程你所要做的事就是在shell提示符下输入make命令。整个工程完全自动编译，极大提高了效率。 2. Makefile文件的格式#这里写注释 目标：依赖项列表 [命令] 目标：依赖项列表 [命令] ... Makefile文件要放在与源文件相同的目录下； make程序执行Makefile的相关行的默认情况是将执行状态显示出来，如果在相关行前加“@”，就可以避免显示该行； 3. Makefile文件的生成方式Makefile文件有两种方式产生： 手动编写 自动生成 手动编写文件依赖关系： 如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作 自动生成文件依赖关系： 编译器可以自动的从源码文件中产生文件的相互依赖关系。当编译器编译每一个源码文件时，它知道应该包括什么样的头文件。当使用gcc时，用-M选项，它可以为每一个输入的C语言源文件输出一个依赖规则。 例如：main.c里面包含了#include &lt;stdio.h&gt;，依赖关系应该这样写main.o:main.c stdio.h，但是根据上面介绍，这个依赖关系还可以这样写：gcc -M main.c就可以得到main.o的所有依赖项， 上述方法gcc并不区分系统的头文件和程序自带的头文件。由于在一般情况下不会修改系统头文件，为了避免输出的依赖关系中包含系统头文件，可以用-MM参数来代替-M传递给gcc gcc -MM XXXXX只输出规则的依赖关系，不含有命令部分。用户可以自己写入需要的命令，或者什么也不写，make会使用隐含规则 3. Makefile文件的语法 变量 使用时展开表示，make可以递归找到尚未定义的变量，但是直接展开就是不能递归寻找尚未定义的变量，这就要求以第三种方式声明的变量一定要在定义的时候赋值 定义变量（使用时展开） variable=value 定义变量（使用时展开） define variable value value ... endef 定义变量（定义后直接展开） variable := value 追加变量 variable += value 定义变量（使用时展开） variable ?= value 使用时，把变量用括号括起来，并在前面加上“$”符号，就可以引用变量的值 $(variable) 变量一般放置文件名列表，或者保存编译器参数 例如： #原文件 exe:exe.o f.o gcc exe.o f.o -o exe exe.o: exe.c f.h gcc -c exe.c f.o:f.c f.h gcc -c f.c clean: rm -f exe *.o #新文件 OBJS=exe.o f.o C=-c exe:$(OBJS) gcc $(OBJS) -o exe exe.o: exe.c f.h gcc $(C) exe.c f.o:f.c f.h gcc $(C) f.c clean: rm -f exe *.o 通配符 % 通配符作用和数据库里面学的一样，在Makefile规则中，通配符会被自动展开。 %.h 表示当前目录下所有以.h结尾的文件 但在变量的定义和函数引用时，通配符将失效。这种情况下，只能使用一下方式来实现通配符的功能 * *.o 表示当前目录下的所有的.o文件 ~ 波浪号（ ~ ）字符在文件名中也有比较特殊的用途。如果是 ~/test ，这就表示当前用户的 $HOME 目录下的test目录。而 ~hchen/test 则表示用户hchen的宿主目录下的test 目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是 MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。 伪目标在Makefile中，并不是所有的目标都对应于磁盘上的文件，有的目标的存在只是为了形成一条规则，从而使make完成特定的工作，并不生成新的目标文件，这样的目标成为伪目标。由于make无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效，例如上面例子中的clean就是。常见的伪目标有all、clean等 为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显式地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标” 伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性 条件语句 条件语句包含三条指令：ifeq、else和endif。 例如在变量VAR=1时，把moudle模块编译输出文件为exe1，不等于时，把moudle模块编译输出文件为exe2： ifeq($(VAR),1) gcc -o exe1 module else gcc -o exe2 moudle endif #后跟Makefile文件中的正常内容 ifeq的格式与C语言的格式有点相似，可以结合C语言的if语句来理解 调试make 通过-d选项使make在执行命令时打印调试信息，这些信息包括以下的内容：1). make重新编译时需要检查的文件2). 那些文件被比较及比较的结果3). 需要重新生成的文件4). make将要使用的隐含规则5). make实际执行的隐含规则及命令 尚未理解，还待验证 include Makefile中也有和C语言中的#include一样用法的include，两者之间的区别就在于有没有#而已，这个用法多用于在一个项目中有多个Makefile，分别在不同的目录下，这样我 们可以写一个公共Makefile，这个Makefile中包含一些公共变量的定义，例如： include ../Makefile.param 这个../Makefile.param文件里面放置了Makefile所需要的变量，也就是参数 如果make执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目录下去寻找 如果目录 &lt;prefix&gt;/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找 引用替换规则例如： OBJ := $(SRC:%.c=%.o) 这里使用了Makefile中的引用替换规则，即将SRC变量下以.c为后缀的文件全部替换成.o，然后赋值给OBJ变量 文件搜寻在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。Makefile文件中的特殊变量 VPATH 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。 4. Makefile选项 CFLAGS指定头文件（.h文件）的路径 LDFLAGSgcc等编译器会用到的一些优化参数，也可以在里面指定库文件的位置 LIBS告诉链接器要链接哪些库文件 5. Makefile自动化变量自动化变量可以理解为由 Makefile 自动产生的变量，自动化变量的取值根据执行的规则来决定，取决于执行规则的目标文件和依赖文件 自动化变量 说明 $@ 表示规则的目标文件名 $% 当目标文件是一个静态库文件时，代表静态库的一个成员名 $&lt; 规则的第一个依赖的文件名，如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件 $? 所有比目标文件更新的依赖文件列表，用空格分隔 $^ 代表的是所有依赖文件列表，使用空格分隔。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件。 $+ 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合 $* 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时，“茎”也包含目录部分） 6. make命令make工具最主要也是最基本的功能就是通过makefile文件来描述源程序之间的相互关系来自动维护编译工作 例如有如下Makefile： exe:exe.o f.o gcc exe.o f.o -o exe exe.o: exe.c f.h gcc -c exe.c f.o:f.c f.h gcc -c f.c clean: rm -f exe *.o make 只输入make的话，make将对Makefile的第一行目标作为最终目标文件进行维护（意思就是只对第一行的目标所层层依赖的关系进行搜索更新）。 指定要维护的目标：make exe.o，则只关心exe.o所依赖的文件的更新 make会比较依赖项和目标文件的修改时间，假如依赖文件的修改时间新于目标文件或者目标文件不存在的话，make会执行后续定义的命令 make -f filename指定要维护的Makefile文件，make就在当前目录下寻找文件名为filename的Makefile文件，并读入该文件的相关行，这个文件的后缀可能不一样 make clean删除所有可执行文件和目标文件 -C将当前的工作目录切换到指定目录 @通常makefile会将其执行的命令行在执行前输出到屏幕上，如果这个符号在执行命令行之前，则这条命令将不被make输出到屏幕中 addsuffix 这是加后缀函数，格式如下： $(addsuffix &lt;suffix&gt;,&lt;names...&gt;) 把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面，例如： $(addsuffix .c,foo bar) 返回值是： foo.c bar.c patsubst这是替换通配符函数，例如： obj=$(patsubst %.c,%.o,foo.c bar.c) 返回值是： foo.o bar.o wildcard在定义变量或者引用变量时，如果想使用通配符来匹配文件，就需要使用wildcard关键字，如： src = $(wildcard *.c ./sub/*.c) 即可获得当前目录下所有的.c和./sub/下所有后缀为c的文件 notdir这是去除路径函数，作用是把目标的前缀路径去除 参考资料 7. Make依赖性 make会在当前目录下找名字叫“Makefile”或“makefile”的文件，如果找到，它会找文件中的第一个目标文件（一般为可执行文件），并把这个文件作为最终的目标文件 如果这个目标文件（target）不存在，或者目标文件（target）所依赖的后面的.o文件的文件修改时间要比目标文件（target）的更新，那么，make就会执行后面所定义的命令来生成这个目标文件（target） 如果目标文件（target）所依赖的后面的.o文件也不存在，那么make会去寻找这个.o文件的依赖项列表，也就是将目标暂时转化为.o文件（有点像一个堆栈的过程），找到依赖项列表之后，根据那一个规则生成.o文件 然后再用.o文件生成原来那个目标文件（target）（出栈） 这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理 因此像上面例子中的clean这种伪目标，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令make clean，以此来清除所有的目标文件，以便重编译 参考资料 8. make的自动推导make很强大，它可以自动推导文件以及文件依赖关系后面的命令，只要make看到一个.o文件，它就会自动的把.c文件加在依赖关系中，例如：make找到一个 whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件，因此上面的makefile可以这样写： exe:exe.o f.o gcc exe.o f.o -o exe exe.o: f.h f.o: f.h clean: rm -f exe *.o 9. 嵌套执行make在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处 export由于Makefile分层的原因，想让上一层Makefile的变量传递到下一层Makefile，这就需要使用export来实现 如果要传递所有的变量，那么，只要一个export就行了 注意：有两个变量，一个是 SHELL ，一个是 MAKEFLAGS ，这两个变量不管你是否export，其总是要传递到下层 Makefile中，特别是 MAKEFLAGS 变量，其中包含了make的参数信息，如果在上层Makefile中定义了这个变量，且这些变量的值就是make参数，那么这些make参数一定会传递到下层Makefile中，这是一个系统级的环境变量 大概是这个意思吧？尚未理解","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Linux系统自带的Python切勿任意删除","slug":"Linux系统自带的Python切勿任意删除","date":"2022-09-09T07:13:36.597Z","updated":"2022-09-09T07:13:36.597Z","comments":true,"path":"2022/09/09/linux-xi-tong-zi-dai-de-python-qie-wu-ren-yi-shan-chu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/linux-xi-tong-zi-dai-de-python-qie-wu-ren-yi-shan-chu/","excerpt":"","text":"Ubantu中自带的python2的版本切勿任意删除Ubantu桌面环境是依赖于python的，因此在安装Ubantu系统的时候会自带python2的版本，但是python版本已经到了3.X了，显然2.X的python版本已经不能满足日常开发 因此在自己进行开发的时候还需要额外安装python3的版本，因此在一个操作系统中多个python版本是可以相互兼容的，只需要调整好优先顺序 事故起因因为之前还不知道ubantu系统自带的python版本不能卸载，然后看到系统中那么多的python版本的时候，强迫症犯了就是开始在CSDN上面搜索如何卸载多余的python版本，但是这种没有经过思考就乱卸载东西的坏习惯正是多年的面向CSDN编程养出来的，接下来可不能在被这种驳杂的网路信息蒙蔽了双眼，好了继续说我的悲惨经历：接着我就使用了whereis python|xargs rm -frv这条万恶的指令将系统上的python版本全部删除干净了 如何修复事情已经发生了，不能说每次出错都要重新安装一下系统，确实重装系统能解决大部分的问题，但是这样做不利于我们提高自己的能力，因此我想要在当前情况下寻找如何破局的方法 最后我重装系统了。。。","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Linux指令学习","slug":"Linux指令学习","date":"2022-09-09T07:13:36.592Z","updated":"2022-09-09T07:13:36.592Z","comments":true,"path":"2022/09/09/linux-zhi-ling-xue-xi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/linux-zhi-ling-xue-xi/","excerpt":"","text":"Linux指令1. pushd 功能：常用于将目录加入到栈中，加入记录到目录栈顶部，并切换到该目录；若pushd命令不加任何参数，则会将位于记录栈最上面的2个目录对换位置，即实现cd -的逻辑 每次pushd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容 什么是目录栈？我理解是以栈的形式记录你走过的的目录，从当前目录栈出栈就能找到你上一次所在的目录 格式：pushd [参数] 常用参数 解释 +N 把正数第N个放到栈顶（切换当前目录） -N 把倒数第N个放到栈顶（切换当前目录） -n 不切换，只压栈（不切换目录） dirname 要入栈的目录 2. popd 功能：常用于将目录栈顶目录出栈 每次popd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容 格式：popd [参数] 常用参数 解释 +N 把正数第N个出栈（不一定切换当前目录） -N 把倒数第N个出栈（不一定切换当前目录） -n 不切换，只压栈（不切换目录） dirname 要出栈的目录 3. echo 功能 字符串的输出 文件重定向 可以使用&gt;、&gt;&gt;运算符将输出重定向到文件，而不是在屏幕上显示输出 如果文件不存在，将创建它。使用&gt;时，文件将被覆盖；使用&gt;&gt;时，会将输出附加到文件中 显示变量 echo $USER 显示命令输出，$（command）为表达式 echo \"The date is: $(date +%D)\" 格式：echo [-neE] [ARGUMENTS] -n：当指定-n选项时，其后的换行符被抑制；即不会在最后自动换行 -e：当指定-e选项时，则将解释以下反斜杠转义字符： \\\\ - 插入反斜杠（\\）字符 \\a - 警报（BEL） \\b - 显示退格字符 \\c - 抑制任何进一步的输出 \\e - 显示转义字符 \\f - 显示换页符 \\n - 显示新行 \\r - 显示回车 \\t - 显示水平选项卡 \\v - 显示垂直选项卡 -E：当指定-E选项时，禁用转义字符的解释，这是默认值","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Linux常用的软件的下载","slug":"Linux常用的软件的下载","date":"2022-09-09T07:13:36.585Z","updated":"2022-09-09T07:13:36.585Z","comments":true,"path":"2022/09/09/linux-chang-yong-de-ruan-jian-de-xia-zai/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/linux-chang-yong-de-ruan-jian-de-xia-zai/","excerpt":"","text":"","categories":[{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"JAVA9. 多线程","slug":"JAVA9. 多线程","date":"2022-09-09T07:13:36.577Z","updated":"2022-09-09T07:13:36.577Z","comments":true,"path":"2022/09/09/java9.duo-xian-cheng/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/java9.duo-xian-cheng/","excerpt":"","text":"","categories":[{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JAVA8. IO-2","slug":"JAVA8. IO-2","date":"2022-09-09T07:13:36.571Z","updated":"2022-09-09T07:13:36.571Z","comments":true,"path":"2022/09/09/java8.io-2/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/java8.io-2/","excerpt":"","text":"装饰器设计模式还记得之前讲过的处理流吗？在介绍处理流之前先介绍处理流的设计模式：装饰器设计模式 /** * 实现放大器对声音的放大功能 */ public class DecorateTest01 { public static void main(String[] args) { Person p = new Person(); p.say(); Amplifier am = new Amplifier(p); //Amplifier装饰Person p，实际上就是传入另一个对象在当前类对传入的类对象的一些方法或者属性进行装饰 am.say(); } } interface say{//必须要有一个抽象接口是的装饰器和被装饰的对象都重写了这个接口的方法 void say(); } class Person implements say { private int voice = 10; @Override public void say() { System.out.println(\"人的声音为：\"+this.getVoice()); } public int getVoice() { return voice; } public void setVoice(int voice) { this.voice = voice; } } class Amplifier implements say { private Person p; Amplifier(Person p) { this.p = p; } @Override public void say() { System.out.println(\"人的声音为：\"+p.getVoice()*100); } } 装饰设计模式有四个组成部分： 抽象组件：需要装饰的抽象对象（接口或抽象父类） 具体组件：需要装饰的对象 抽象装饰类：包含了对抽象组件的引用以及装饰着共有的方法 具体装饰类：被装饰的对象 本质上就是引用对象参数，以及对象方法的重写 /** * 模拟咖啡 * 1. 抽象组件：需要装饰的抽象对象（接口或抽象父类） * 2. 具体组件：需要装饰的对象 * 3. 抽象装饰类：包含了对抽象组件的引用以及装饰着共有的方法 * 4. 具体装饰类：被装饰的对象 */ public class DecorateTest02 { public static void main(String[] args) { Drink coffee = new Coffee(); Drink suger = new Suger(coffee); Drink milk = new Milk(coffee); System.out.println(suger.info()+\"---&gt;\"+suger.cost()); System.out.println(milk.info()+\"---&gt;\"+milk.cost()); milk = new Milk(suger); System.out.println(milk.info()+\"---&gt;\"+milk.cost()); } } //抽象组件 interface Drink { double cost();//费用 String info();//说明 } //具体组件 class Coffee implements Drink { private String name = \"原味咖啡\"; @Override public double cost() { return 10; } @Override public String info() { return name; } } //抽象装饰类 abstract class Decorate implements Drink { //对抽象组件的引用 private Drink drink; public Decorate(Drink drink){ this.drink = drink; } @Override public double cost() { return this.drink.cost(); } @Override public String info() { return this.drink.info(); } } //具体装饰类 class Milk extends Decorate { public Milk(Drink drink) { super(drink); } @Override public double cost() { return super.cost()*4; } @Override public String info() { return super.info()+\"加入了牛奶\"; } } class Suger extends Decorate { public Suger(Drink drink) { super(drink); } @Override public double cost() { return super.cost()*2; } @Override public String info() { return super.info()+\"加入了糖\"; } } 字节缓冲流 BufferedInputStream BufferedOutPutStream 字节缓冲流就是其中一个处理流，这个处理流的功能就是做一个缓冲的作用，当节点流获取的数据达到8k（默认）的字节的时候才进行读写的操作，这样减少了读写磁盘的操作 它是在节点流（文件字节流）的基础上进行装饰的，所有的处理流都必须在节点流的基础上进行装饰 在释放IO流的时候只需要释放处理流，处理流会自动找到节点流并将其释放 不使用字节缓冲流，直接使用节点流拷贝一个mp4文件的时间 import java.io.*; public class FileCopy { public static void main(String[] args) { long t1 = System.currentTimeMillis(); Copy(\"C:/Users/86191/Desktop/作品11.mp4\",\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\"+\"/Copy.mp4\"); long t2 = System.currentTimeMillis(); System.out.println(t2-t1); } public static void Copy(String srcPath,String destPath) { //1. 创建源 File src = new File(srcPath); File dest = new File(destPath); //2. 选择流 InputStream is = null; OutputStream os = null; //操作 try{ is = new FileInputStream(src); os = new FileOutputStream(dest,true); byte flush[] = new byte[1024]; int len = -1; while((len = is.read(flush))!=-1) { os.write(flush,0,len); } os.flush(); } catch (IOException e) { e.printStackTrace(); }finally { try { if(os != null) { os.close(); } } catch (IOException e) { e.printStackTrace(); } //先打开的后关闭 try{ if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } OUT: 2641 使用字节缓冲流之后： import java.io.*; public class FileCopy { public static void main(String[] args) { long t1 = System.currentTimeMillis(); Copy(\"C:/Users/86191/Desktop/作品11.mp4\",\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\"+\"/Copy.mp4\"); long t2 = System.currentTimeMillis(); System.out.println(t2-t1); } public static void Copy(String srcPath,String destPath) { //1. 创建源 File src = new File(srcPath); File dest = new File(destPath); //2. 选择流 InputStream is = null; OutputStream os = null; //操作 try{ is = new BufferedInputStream(new FileInputStream(src)); os = new BufferedOutputStream(new FileOutputStream(dest)); byte flush[] = new byte[1024]; int len = -1; while((len = is.read(flush))!=-1) { os.write(flush,0,len); } os.flush(); } catch (IOException e) { e.printStackTrace(); }finally { try { if(os != null) { os.close(); } } catch (IOException e) { e.printStackTrace(); } try{ if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } OUT: 675 可以看出使用了字节缓冲流之后对IO的性能进行了优化，在以后的开发过程中要尽可能减小IO瓶颈 字符缓冲流 BufferedReader BufferedWriter 这两个IO流有其特有的方法，使用这些方法的时候不能多态，主要是两个方法：readLine读一行文字；newLine换行 import java.io.*; /** * 文件字符输入流 加入字符缓冲流 */ public class BufferedTest03 { public static void main(String[] args){ //1. 创建源 File src = new File(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\"+\"/abc.txt\");//构建文件名 //2. 选择流，不要发生多态 BufferedReader reader = null; try { //直接将处理流套上节点流 reader = new BufferedReader(new FileReader(src)); //3. 操作 使用readLine，用一个字符串接收 String line = null; while((line = reader.readLine())!=null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } finally { //4. 释放资源 try { if(reader!=null) { reader.close(); } } catch (IOException e) { e.printStackTrace(); } } } } import java.io.*; /** * 文件字符输出流 加入字符缓冲流 */ public class BufferedTest04 { public static void main(String[] args) { //1. 创建源 File dest = new File(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\" + \"/dest.txt\");//构建文件名 //2. 选择流，异常处理 BufferedWriter writer = null; //3. 操作（写出） try { writer = new BufferedWriter(new FileWriter(dest)); writer.append(\"Hello World!\"); writer.newLine();//其特有方法：换行 writer.append(\"你好啊兄弟\"); writer.flush();//刷新一下缓冲区，尽管在释放资源之后还会再刷新一下 } catch (IOException e) { e.printStackTrace(); } finally { try { if(writer != null) { writer.close(); } }catch (IOException e) { e.printStackTrace(); } } } } import java.io.*; /** * 使用字符缓冲流实现纯文本的拷贝 */ public class TxtCopy { public static void main(String[] args) { Copy(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\"+\"/abc.txt\",\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\" + \"/dest.txt\"); } public static void Copy(String srcPath,String destPath) { //1. 创建源 File src = new File(srcPath); File dest = new File(destPath); //2. 选择流 BufferedReader reader = null; BufferedWriter writer = null; //操作 try{ reader = new BufferedReader(new FileReader(src)); writer = new BufferedWriter(new FileWriter(dest)); String line = null; while((line = reader.readLine())!= null) { writer.write(line); writer.newLine(); } writer.flush(); } catch (IOException e) { e.printStackTrace(); }finally { try { if(writer != null) { writer.close(); } } catch (IOException e) { e.printStackTrace(); } try{ if (reader != null){ reader.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 转换流 InputStreamReader InputStreamWriter 这是字节流与字符流之间的桥梁，能将字节流转换成字符流，而且还能为字节流指定字符集，以便用于处理一个个的字符 因为很多数据的传输是以字节流的方式传递，但是对于纯文本字节流我们能看懂的是字符，因此要将字节流转化为字符流 数据流对象流打印流文件分割","categories":[{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JAVA8. IO-1","slug":"JAVA8. IO-1","date":"2022-09-09T07:13:36.564Z","updated":"2022-09-09T07:13:36.564Z","comments":true,"path":"2022/09/09/java8.io-1/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/java8.io-1/","excerpt":"","text":"IO四个抽象类1. 字节流： InputStream：字节输入流的父类，数据单位为字节 int read() void close() OutputStream：字节输出流的父类，数据单位为字节 void write() void flush() void close() 2. 字符流： Reader：字符输入流的父类，数据单位为字符 int read() void close() Writer:字符输出流的父类，数据单位为字符 void write(String) void flush() void close() 按照数据处理来划分可以分为：字节流和字符流 字节流能处理字符数据，但是字符流不能用来处理字节的数据，例如字符流只能用来处理文本文件，字节流却能用来处理音频、视频等字节数据 还可以根据功能的不同划分为：节点流（工作在数据源的位置的IO流）、处理流（将节点流获取的数据进行加工之后传给程序的IO流） ==输入输出流都是以程序为中心去定义的== IO处理步骤标准步骤都是： 创建数据源 选择IO流 操作 释放资源 文件字节流 FileInputStream FileOutputStream 从文件读取，使用文件字节IO流FileInputStream import java.io.*; /** * 第一个程序：理解操作步骤 标准操作 * 1. 创建数据源 * 2. 选择IO流 * 3. 操作 * 4. 释放资源 */ public class TestIO02 { public static void main(String[] args){ //1. 创建源 File src = new File(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\"+\"/abc.txt\");//构建文件名 //2. 选择流，异常处理 InputStream is = null; try { is = new FileInputStream(src); //3. 操作 int temp; while((temp=is.read())!=-1)//读取到文件末尾返回-1 { System.out.println((char)temp); } }catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { //4. 释放资源 try { if(is!=null) { is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 将文件内容装入缓冲数组，分块读取文件内容，使用文件字节IO流FileInputStream /** * 分段读取 * 1. 创建数据源 * 2. 选择IO流 * 3. 操作 * 4. 释放资源 */ public class TestIO03 { public static void main(String[] args){ //1. 创建源 File src = new File(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\"+\"/abc.txt\");//构建文件名 //2. 选择流，异常处理 InputStream is = null; try { is = new FileInputStream(src); //3. 操作：分段读取 byte car[] = new byte[3];//缓冲容器 int len = -1;//接收长度 while((len=is.read(car))!=-1)//这时read返回的是缓冲数组的大小，当缓冲数组读取不到数据的时候返回-1 { //字节数组转化成字符串叫做解码 String str = new String(car,0,len); System.out.println(str); } }catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { //4. 释放资源 try { if(is!=null) { is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 写入文件中，使用文件字节IO流FileInputStream import java.io.*; /** * 写入文件 * 1. 创建数据源 * 2. 选择IO流 * 3. 操作 * 4. 释放资源 */ public class TestIO04 { public static void main(String[] args) { //1. 创建源 File dest = new File(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\" + \"/dest.txt\");//构建文件名 //2. 选择流，异常处理 FileOutputStream os = null; //3. 操作（写出） try { os = new FileOutputStream(dest,true);//append表示在文件末尾追加 String msg = \"Hello World!\"; byte datas[] = msg.getBytes();//字符串转化为字节数组叫做编码 os.write(datas,0,datas.length); os.flush();//刷新一下缓冲区，尽管在释放资源之后还会再刷新一下 } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if(os != null) { os.close(); } }catch (IOException e) { e.printStackTrace(); } } } } 1. 文件的拷贝文件的拷贝是使用程序作为中转，只要将上面样例代码写在一起就能实现 import java.io.*; /** * 文件拷贝 * 思考：文件夹的拷贝，需要用到递归访问文件 */ public class FileCopy { public static void main(String[] args) { Copy(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\"+\"/dest.txt\",\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\"+\"/dest1.txt\"); } public static void Copy(String srcPath,String destPath) { //1. 创建源 File src = new File(srcPath); File dest = new File(destPath); //2. 选择流 FileInputStream is = null; FileOutputStream os = null; //操作 try{ is = new FileInputStream(src); os = new FileOutputStream(dest,true); byte flush[] = new byte[1024];//创建1k的缓存数组 int len = -1; while((len = is.read(flush))!=-1)//read的参数为字符数组的时候，返回的是数组的长度 { os.write(flush,0,len);//len为当前读取到的数组的长度 } os.flush(); } catch (IOException e) { e.printStackTrace(); }finally { try { if(os != null) { os.close(); } } catch (IOException e) { e.printStackTrace(); } //先打开的后关闭 try{ if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 文件字符流 FileReader FileWriter 文件根据编码集不同，一般我们中国采用的是UTF-8的编码，它里面的不同的字符可能占有的字节个数是不一样的，可以使用文件字节流将文本文件的全部字节读取出来，再以字节的方式存储，这就是上面介绍的做法，但是==对于FileInputStream读取一个字符的时候，如果只读取一个字节，可能存在读取字节不够而导致的乱码== 之前FileInputStream处理的是字节数组，就是要将字符串转化为字节才能处理，而文件字符流可以直接处理字符串 将文件中的字符串读取出来，操作的是char数组 import java.io.*; /** * 文件字符输入流 * 1. 创建数据源 * 2. 选择IO流 * 3. 操作 * 4. 释放资源 */ public class TestIO05 { public static void main(String[] args){ //1. 创建源 File src = new File(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\"+\"/abc.txt\");//构建文件名 //2. 选择流，异常处理 Reader reader = null; try { reader = new FileReader(src); //3. 操作 //reader操作的是字符数组 char flush[] = new char[1024];//缓冲容器 int len = -1;//接收长度 while((len=reader.read(flush))!=-1)//这时read返回的是缓冲数组的大小，当缓冲数组读取不到数据的时候返回-1 { //字符数组转化成字符串叫做解码 String str = new String(flush,0,len); System.out.println(str); } } catch (IOException e) { e.printStackTrace(); } finally { //4. 释放资源 try { if(reader!=null) { reader.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 将字符串写入文件 import java.io.*; /** * 文件字符输出流 * 1. 创建数据源 * 2. 选择IO流 * 3. 操作 * 4. 释放资源 */ public class TestIO06 { public static void main(String[] args) { //1. 创建源 File dest = new File(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO\" + \"/dest.txt\");//构建文件名 //2. 选择流，异常处理 Writer writer = null; //3. 操作（写出） try { writer = new FileWriter(dest,true);//append表示在文件末尾追加 //写法一 //writer = new FileWriter(dest,true);//append表示在文件末尾追加 //String msg = \"Hello World!\\r\\n你好啊兄弟\"; //char datas[] = msg.toCharArray();//字符串转化为字符数组 //writer.write(datas,0,datas.length); //写法二 //String msg = \"Hello World!\\r\\n你好啊兄弟\"; //writer.write(msg); //写法三 writer.append(\"Hello World!\\r\\n\").append(\"你好啊兄弟\"); writer.flush();//刷新一下缓冲区，尽管在释放资源之后还会再刷新一下 } catch (IOException e) { e.printStackTrace(); } finally { try { if(writer != null) { writer.close(); } }catch (IOException e) { e.printStackTrace(); } } } } 字节数组流 ByteArrayInputStream ByteArrayOutputStream 任何数据都能转化为字节也就是二进制数据，转化为字节的好处在于网络的传输数据 ==字符数组属于内存的部分JVM可以直接访问不需要再像字节流那样最后还需要通知操作系统释放资源，但是字节数组不能太大== 主要用途：处理不是存储在硬盘上的数据，不再是文件，可以是自身电脑上的一块内存，或者是网络上的一块内存，或是服务器上的一块内存 字节数组流输入是将字节数组转化为字符串 import java.io.*; /** * 字节数组输入流 * 1. 创建数据源 * 2. 选择IO流 * 3. 操作 * 4. 释放资源 */ public class TestIO07 { public static void main(String[] args){ //1. 创建源 byte[] src = \"talk is cheap show me the code\".getBytes();//获取字节数组 //2. 选择流，异常处理 InputStream is = null; try { is = new ByteArrayInputStream(src); //3. 操作 byte flush[] = new byte[1024];//缓冲容器 int len = -1;//接收长度 while((len=is.read(flush))!=-1)//这时read返回的是缓冲数组的大小，当缓冲数组读取不到数据的时候返回-1 { //字节数组转化为字符串 String str = new String(flush,0,len); System.out.println(str); } } catch (IOException e) { e.printStackTrace(); } finally { //4. 释放资源 try { if(is!=null) { is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 字节数组输出流不用指定目标源，它会根据字节数组的大小开辟一个缓存空间，只需要使用toByteArray()获取一下字节数组流的输出就可以了 字节数组输出流是将字节数组写出到另一个字节数组中，这两个字节数组有什么区别呢？我认为是读取的字节数组是部分内容的字节数组，就是搬运字节的卡车，而输出的另一个字节数组就是全部内容的字节数组，两者在字节数上面有所不同 import java.io.*; /** * 字节数组输出流ByteArrayOutStream * 1. 创建数据源 * 2. 选择IO流 * 3. 操作 * 4. 释放资源 */ public class TestIO08 { public static void main(String[] args) { //1. 创建源 byte dest[]; //2. 选择流，因为要使用ByteArrayOutputStream的特有方法所以不能再使用OutputStream作为流的类型 ByteArrayOutputStream baos = null; //3. 操作（写出） try { baos = new ByteArrayOutputStream(); String msg = \"Hello World!\"; byte datas[] = msg.getBytes();//字符串转化为字节数组叫做编码 baos.write(datas,0,datas.length); baos.flush();//刷新一下缓冲区，尽管在释放资源之后还会再刷新一下 //获取数据 dest = baos.toByteArray(); System.out.println(new String(dest,0, baos.size()));//baos.size表示dest中存在的字节 } catch (IOException e) { e.printStackTrace(); }finally { try { if(baos != null) { baos.close(); } }catch (IOException e) { e.printStackTrace(); } } } } 对接流实现从文件内容到字节数组的转换，再从字节数组转换成文件内容 import java.io.*; /** * 对接流 * 1.图片读取到字节数组中 * 2. 字节数组写出到文件中 */ public class TestIO09 { public static void main(String[] args) { //图片转成字节数组 byte[] datas = filetoByteArray(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO/dest.txt\"); System.out.println(datas.length); byteArrayToFile(datas,\"C:/Users/86191/IdeaProjects/LearnJava/src/IO/dest1.txt\"); } /** * 将图片读取到字节数组中 * 1.图片到程序 FileInputStream * 2.程序到字节数组 ByteOutputStream * */ public static byte[] filetoByteArray(String filepath) { //1. 创建源与字节数组输出 File src = new File(filepath);//构建文件名 byte dest[] = null; //2. 选择流 InputStream is = null; ByteArrayOutputStream baos = null; try { baos = new ByteArrayOutputStream(); is = new FileInputStream(src); //3. 操作：分段读取 byte flush[] = new byte[1024]; //缓冲容器 int len = -1; //接收长度 while((len=is.read(flush))!=-1) //这时read返回的是缓冲数组的大小，当缓冲数组读取不到数据的时候返回-1 { baos.write(flush,0,len); //写出到字节数组 } baos.flush(); return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } finally { //4. 释放资源 try { if(is!=null) { is.close(); } } catch (IOException e) { e.printStackTrace(); } } return null; } /** * 将字节数组写出到图片中 * 1.字节数组到程序 ByteArrayInputStream * 2.程序到文件 FileOutputStream */ public static void byteArrayToFile(byte src[],String filePath) { //1.创建源 File dest = new File(filePath);//构建文件名 //2.选择流 InputStream is=null; OutputStream os=null; try { is = new ByteArrayInputStream(src); os = new FileOutputStream(dest); byte[] flush = new byte[5]; int len = -1; while((len=is.read(flush))!=-1) { os.write(flush,0,len); } os.flush(); } catch (IOException e) { e.printStackTrace(); }finally { try { if(os != null) { os.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 工具类import java.io.*; public class FileUtils { public static void main(String[] args) { byte[] datas = null; //文件到文件 try{ InputStream is = new FileInputStream(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO/dest.txt\"); OutputStream os = new FileOutputStream(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO/dest.txt\"); Copy(is,os); } catch (FileNotFoundException e) { e.printStackTrace(); } //文件到字节数组 try{ InputStream is = new FileInputStream(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO/OIP.jpg\"); ByteArrayOutputStream os = new ByteArrayOutputStream(); Copy(is,os); datas = os.toByteArray();//获取输出的字节数组 System.out.println(datas.length); } catch (FileNotFoundException e) { e.printStackTrace(); } //字节数组到文件 try { InputStream is = new ByteArrayInputStream(datas); OutputStream os = new FileOutputStream(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO/Copy.jpg\"); Copy(is,os); } catch (FileNotFoundException e) { e.printStackTrace(); } } /** * 对接输入输出流 * @param is * @param os */ public static void Copy(InputStream is,OutputStream os) { try { byte flush[] = new byte[1024];//创建1k的缓存数组 int len = -1; while ((len = is.read(flush)) != -1)//read的参数为字符数组的时候，返回的是数组的长度 { os.write(flush, 0, len);//len为当前读取到的数组的长度 } os.flush(); } catch (IOException e) { e.printStackTrace(); } finally { close(is,os); } } public static void close(Closeable ...ios) //所有流都继承了Closeable这个接口，可以以这个接口作为对象类型当参数传入 //传入可变参数，实现无论多少个IO流都可以关闭 { for(Closeable io:ios) { try{ io.close(); } catch (IOException e) { e.printStackTrace(); } } } } java8新特性：try…with…resource自动释放资源 import java.io.*; public class FileUtils2 { public static void main(String[] args) { byte[] datas = null; //文件到文件 try{ InputStream is = new FileInputStream(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO/dest.txt\"); OutputStream os = new FileOutputStream(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO/dest.txt\"); Copy(is,os); } catch (FileNotFoundException e) { e.printStackTrace(); } //文件到字节数组 try{ InputStream is = new FileInputStream(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO/OIP.jpg\"); ByteArrayOutputStream os = new ByteArrayOutputStream(); Copy(is,os); datas = os.toByteArray();//获取输出的字节数组 System.out.println(datas.length); } catch (FileNotFoundException e) { e.printStackTrace(); } //字节数组到文件 try { InputStream is = new ByteArrayInputStream(datas); OutputStream os = new FileOutputStream(\"C:/Users/86191/IdeaProjects/LearnJava/src/IO/Copy.jpg\"); Copy(is,os); } catch (FileNotFoundException e) { e.printStackTrace(); } } /** * 对接输入输出流 * 释放资源：try...with...resource * * @param is * @param os */ public static void Copy(InputStream is,OutputStream os) { try(is;os){ byte flush[] = new byte[1024];//创建1k的缓存数组 int len = -1; while ((len = is.read(flush)) != -1)//read的参数为字符数组的时候，返回的是数组的长度 { os.write(flush, 0, len);//len为当前读取到的数组的长度 } os.flush(); } catch (IOException e) { e.printStackTrace(); } } }","categories":[{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JAVA7. 容器","slug":"JAVA7. 容器","date":"2022-09-09T07:13:36.553Z","updated":"2022-09-09T07:13:36.553Z","comments":true,"path":"2022/09/09/java7.rong-qi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/java7.rong-qi/","excerpt":"","text":"容器容器相当于一个大的箱子，容器用来存储数据，这就涉及到容器的存和取的问题 数组也是一种容器，但是数组不能随着需求的变化而扩容，因此容器产生了 泛型其本质是：==数据类型的参数化==。它与形式参数的区别在于：形式参数需要指明传入参数的类型，但是泛型却不需要指明传入参数的类型，这就体现了它的“泛”，但是要注意泛型只能传入引用对象类型 泛型相当于给容器贴上一个标签，方便更好的管理容器，帮助我们建立类型安全的容器，且编译器会检查定义了泛型的容器，在声明时是否符合泛型，大大提高了代码的可读性和安全性 /** * 测试泛型 */ public class TestGenerics { public static void main(String[] args) { MyCollection&lt;String&gt; mc = new MyCollection&lt;String&gt;(); mc.set(\"aaa\",0); mc.set(\"bbb\",1); String str = mc.get(1); //返回泛型类型，编译器自动帮助检测是否为相应的泛型，假如不是则不能通过编译 System.out.println(str); } } class MyCollection&lt;E&gt;//E是一个f { Object[] objs = new Object[5]; public E get(int index) { return (E)objs[index]; } public void set(E e,int index) { objs[index] = e; } } 1. 容器中的泛型泛型在容器中使用广泛，有了泛型使得容器的存和取更便于管理，在容器中很多接口类都使用了泛型，推荐使用泛型，但实际上不使用编译器也不会报错 Collection接口 以List的实现类ArrayList来说明Collection接口中的方法 /** * 测试Collection接口中的方法 */ public class TestList { public static void main(String[] args) { Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); System.out.println(c.size()); System.out.println(c.isEmpty()); //向容器中添加数据 c.add(\"高老大\"); c.add(\"高老二\"); System.out.println(c); System.out.println(c.size()); //容器中toArray方法返回的是一个object数组 Object[] objs = c.toArray(); System.out.println(objs); //判断容器中是否包含某个元素，返回的是布尔类型的值 System.out.println(c.contains(\"高老五\")); //移除容器中的数据 c.remove(\"高老二\"); System.out.println(c); //清空容器 c.clear(); System.out.println(c); } } 在容器中存储的是数据的地址，尽管通过remove函数将其删除了，但是它的内容实际上还是存在的，只是将容器中的地址删除了 /** * 测试Collection接口中的方法 */ public class TestList { public static void main(String[] args) { List&lt;String&gt; list01 = new ArrayList&lt;&gt;(); list01.add(\"aa\"); list01.add(\"bb\"); list01.add(\"cc\"); List&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"aa\"); list02.add(\"bb\"); list02.add(\"cc\"); //将list02中的所有元素增加到本容器中，取并集但不会去重 //list01.addAll(list02); //移除list01和list02中都有的元素，也就是取差集 //list01.removeAll(list02); //取交集 //list01.retainAll(list02); //判断list02是否包含在list01中，返回的一个布尔值 System.out.println(list01.containsAll(list02)); System.out.println(\"list01\"+list01); } } ListList是一个有序、可重复的容器 有序：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素 可重复：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器，这和集合的定义就有点不符合 public class TestList { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); list.add(\"D\"); //List中可通过索引位置插入元素，因为List是有序的即有下标，不加索引的话是在末尾添加元素 list.add(2,\"wo\"); System.out.println(list); //同样也可以通过下标删除元素 list.remove(2); System.out.println(list); //直接设置索引位置的元素 list.set(2,\"wo\"); System.out.println(list); //获取索引位置上的元素 System.out.println(list.get(2)); //返回查找元素第一次出现的索引（找到的话，否则返回-1） list.add(\"B\"); System.out.println(list); System.out.println(list.indexOf(\"B\")); //从右往回找 System.out.println(list.lastIndexOf(\"B\")); } } 1. ArrayListArrayList是继承自List接口的类，一般使用容器的时候都是声明ArrayList类，它里面重写了List接口和Collection接口的方法，下面我们来实现一下ArrayList的一些功能，其中主要是它如何实现数组的动态扩容的操作 特点：==查询效率高==，增删效率低，线程不安全 动态扩容数组 /** * 自定义实现一个ArrayList体会底层原理 * 增加数组扩容 */ public class TestArrayList02&lt;E&gt;{ private Object[] elementData;//ArrayList底层是由数组实现的，这个是一个默认数组 private int size; public static final int DEFAULT_CAPACITY=10; public TestArrayList02() { elementData = new Object[DEFAULT_CAPACITY];//开辟默认数组的空间 } public TestArrayList02(int capacity) { elementData = new Object[capacity];//扩容时开辟空间 } public void add(E obj) { if(size == elementData.length) { Object[] newArray = new Object[elementData.length+(elementData.length&gt;&gt;1)];//原数组加上数组的一半实现数组的动态扩容，注意优先级的问题 System.arraycopy(elementData,0,newArray,0,elementData.length);//将原数组拷贝到新数组 elementData = newArray;//将新数组对象的地址赋给elementData这个变量，老数组会被垃圾回收 } else{ elementData[size++] = obj; } } @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for(int i=0;i&lt;size;i++) { sb.append(elementData[i]+\" \"); } sb.setCharAt(sb.length()-1,']');//替换最后一个字符 return sb.toString(); } public static void main(String[] args) { TestArrayList02 t = new TestArrayList02(20); for(int i=0;i&lt;100;i++) { t.add(i); } System.out.println(t); } } remove移除数组元素，这里写了两个remove第一个是找到第一个相等的元素的下标，传递给另一个remove来删除，实际上就是数组的拷贝 /** * 自定义实现一个ArrayList体会底层原理 * 增减remove方法 */ public class TestArrayList04&lt;E&gt;{ private Object[] elementData;//ArrayList底层是由数组实现的，这个是一个默认数组 private int size; public static final int DEFAULT_CAPACITY=10; public TestArrayList04() { elementData = new Object[DEFAULT_CAPACITY];//开辟默认数组的空间 } public TestArrayList04(int capacity) { if(capacity&lt;0) { throw new RuntimeException(\"容器容量不能为负数\"); } else if(capacity==0) { elementData = new Object[DEFAULT_CAPACITY];//创建默认容量的数组 } else{ elementData = new Object[capacity]; } } public void add(E obj) { if(size == elementData.length) { Object[] newArray = new Object[elementData.length+(elementData.length&gt;&gt;1)];//原数组加上数组的一半实现数组的动态扩容，注意优先级的问题 System.arraycopy(elementData,0,newArray,0,elementData.length);//将原数组拷贝到新数组 elementData = newArray;//将新数组对象的地址赋给elementData这个变量，老数组会被垃圾回收 } else{ elementData[size++] = obj; } } public E get(int index) { CheckRange(index); return (E)elementData[index]; } public void set(E element,int index) { //判断索引范围，判断是否在[0,size)之间 CheckRange(index); elementData[index] = element; } public void CheckRange(int index) { if(index&lt;0||index&gt;size-1) { //不合法，手动抛出异常 throw new RuntimeException(\"索引不合法！\"+index); } } public void remove(E element) { //element将它和所有元素意义比较，获得第一个比较为true的 for(int i=0;i&lt;size;i++) { if(element.equals(get(i))) { //将该元素从此处移除 remove(i); } } } public void remove(int index)//带参数的remove移除元素，实际上也是数组拷贝 { int numMoved = elementData.length-index-1; if(numMoved&gt;0) { System.arraycopy(elementData,index+1,elementData ,index,numMoved); } elementData[--size] = null; } @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for(int i=0;i&lt;size;i++) { sb.append(elementData[i]+\" \"); } sb.setCharAt(sb.length()-1,']');//替换最后一个字符 return sb.toString(); } public static void main(String[] args) { TestArrayList04&lt;String&gt; t = new TestArrayList04&lt;&gt;(20); for(int i=0;i&lt;10;i++) { t.add(String.valueOf(i)); } System.out.println(t); System.out.println(t.get(5)); t.set(\"dddd\",1); System.out.println(t); System.out.println(t.get(1)); t.remove(3); System.out.println(t); t.remove(9); System.out.println(t); } } 2. LinkListLinkList底层是由双向链表实现的，它的每个数据节点都有两个指针，分别指向前一个结点和后一个结点每个节点的格式： class Node { Node previous; //前一个节点 Object element; //本节点保存的数据 Node next; //后一个节点 } 特点：查询效率低，==增删效率高==，线程不安全 Vector向量Vector底层是用数组实现List，相关方法都加了同步检查，需要线程安全时使用Vector，不存在线程安全问题时，并且查找较多用ArrayList（一般使用它），不存在线程安全问题时，增加或删除元素较多用LinkedList，这个只需要知道就可以 Map接口1. 常用方法 /*** * 测试hashMap的使用 */ public class TestMap01 { public static void main(String[] args) { Map&lt;Integer,String&gt;m1 = new HashMap&lt;&gt;(); m1.put(1,\"one\");//存放键值对使用的是put m1.put(2,\"two\"); m1.put(3,\"three\"); System.out.println(m1.get(1));//获取相应键的值 System.out.println(m1.isEmpty());//判断map对象是否为空 System.out.println(m1.containsKey(2));//判断map对象是否包含键2 System.out.println(m1.containsValue(\"four\"));//判断map对象是否包含值为”four“ Map&lt;Integer,String&gt; m2 = new HashMap&lt;&gt;(); m2.put(4,\"四\"); m2.put(5,\"五\"); m1.putAll(m2);//将m2对象的键值对合并到m1 System.out.println(m1); m1.put(3,\"三\");//map中的键不能重复，如果键重复的话，则新的覆盖旧的 System.out.println(m1); } } import java.util.HashMap; import java.util.Map; /** * 测试Map常用的方法 */ public class TestMap02 { public static void main(String[] args) { Employee e1 = new Employee(1001,\"小明\",50000); Employee e2 = new Employee(1002,\"小红\",5000); Employee e3 = new Employee(1003,\"小亮\",6000); Employee e4 = new Employee(1001,\"小李\",6000); Map&lt;Integer,Employee&gt; map = new HashMap&lt;&gt;(); map.put(1001,e1); map.put(1002,e2); map.put(1003,e3); map.put(1001,e4); Employee emp = map.get(1001); System.out.println(emp.getEname()); System.out.println(map); } } class Employee { private int id; private String ename; private double salary; public Employee(int id, String ename, double salary) { this.id = id; this.ename = ename; this.salary = salary; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } } 2. HashMap底层实现HashMap底层实现采用的是哈希表，什么是哈希表呢？哈希表是一种结合了数组和链表优点的一种数据结构，可以结合数据结构中学会的拉链式散列表来记忆，实际上我觉得这两者就是一样的东西，只是叫法不同罢了，当然根据不同的语言，哈希表会有不同的定义 在哈希表中数组称为“位桶数组”，数组每个空间都有特定的键，数组内对应键内存放相应的链表对象 可以看到它是这个样子： 哈希表是如何存储数据的呢？ 在java中每个对象都有一个叫hashcode的编码，在调用HashMap的时候，会利用这个hashcode来计算出相应于位桶数组范围的hash键值，根据hash键值存放这个对象 为了能快速找到存储的元素，以及利用更少的空间，现在很多算法研究就是在研究这个，目的就是为了数据存储更加分散。我们知道数组具有查询快捷的特点，链表具有便于修改的特点，不能所有的数据都存储在一个链表里，那样不方便查询。也不能全部数据都存储在位桶数组里，那样会占用很大的空间，因此让数据的存储尽可能分散是一个好的解决方案 JDK8中，HashMap在存储一个元素时，当对应链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率 HashMap的位桶数组，初始大小为16。实际使用时，显然大小是可变的。如果位桶数组中的元素达到(0.75*数组 length)， 就重新调整数组大小变为原来2倍大小 扩容很耗时。扩容的本质是定义新的更大的数组，并将旧数组内容挨个拷贝到新数组中 3. TreeMapTreeMap的底层实现是使用红黑二叉树 TreeMap和HashMap实现了同样的接口Map，用法对于使用者来说没什么大的区别，只是在需要排序的Map时才选用TreeMap，经过查看源码发现TreeMap重写了Comparable接口的compareTo的方法 import java.util.Map; import java.util.TreeMap; /** * 测试TreeMap的使用 */ public class TestTreeMap { public static void main(String[] args) { Map&lt;Integer,String&gt; treemap1 = new TreeMap&lt;&gt;(); treemap1.put(20,\"aa\"); treemap1.put(6,\"bb\"); treemap1.put(10,\"cc\"); //按照key递增的方式排序 for(Integer key:treemap1.keySet()) { System.out.println(key+\"---\"+treemap1.get(key)); } Map&lt;Emp,String&gt; treemap2 = new TreeMap&lt;&gt;();//自定义键值来排序 treemap2.put(new Emp(100,\"小明\",50000),\"小明是一个好小伙\"); treemap2.put(new Emp(101,\"小红\",5000),\"小红工作不积极\"); treemap2.put(new Emp(102,\"小李\",10000),\"小李工作还可以\"); for(Emp key:treemap2.keySet())//以递增的次序排序 { System.out.println(key+\"---\"+treemap2.get(key)); } } } class Emp implements Comparable&lt;Emp&gt;{ //继承comparable接口 int id; String name; double salary; public Emp(int id, String name, double salary) { this.id = id; this.name = name; this.salary = salary; } @Override public String toString() { return \"Emp{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", salary=\" + salary + '}'; } @Override public int compareTo(Emp o) {//负数：小于，0：等于，正数：大于 if (this.salary&gt;o.salary) { return 1; } else if(this.salary&lt;o.salary) { return -1; } else{ if(this.id&gt;o.id) { return 1; } else if(this.id&lt;o.id) { return -1; } else{ return 0; } } } } 4. Comparable接口实现Comparable接口要重写它的CompareTo函数，在排序自定义对象的时候，就要重写这个函数。在我看来，就是在创建一类对象的时候，这些对象如果重写了实现了Comparable接口，那么这些对象就会自动拥有排序的特性 SetSet容器特点：无序、不可重复 无序指Set中的元素没有索引，我们只能遍历查找 不可重复指不允许加入重复的元素 1. HashSetHashSet的底层实现是由HashMap实现的，键对象就是加入的元素，值对象是一个固定的Object对象 HashSet所包含的方法和HashMap里的是一样的，因为HashSet本质上就是一个HasnMap但是只是存储键对象，值对象是默认的 2. TreeSetTreeSet底层是由TreeMap实现的，使用方法也和TreeMap是一样的，这两个类就不详细介绍了 迭代器迭代器是Collection类实现的一个接口类，就是说无论Map还是List等，都有个迭代器，使用容器.iterator()来返回一个迭代器，这个迭代器有两个方法：hasnext()、next()方法，hasnext()表示判断是否存在下一个元素，next()表示遍历下一个元素 import java.util.*; /** * 测试迭代器遍历List、Set、Map */ public class TestIterator { public static void main(String[] args) { testIteratorList(); testIteratorSet(); testIteratorMap(); testIteratorMap2(); } public static void testIteratorList() { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aa\"); list.add(\"bb\"); list.add(\"cc\"); //使用迭代器遍历List for (Iterator&lt;String&gt; iter = list.iterator();iter.hasNext();) { String temp = iter.next(); System.out.println(temp); } } public static void testIteratorSet() { Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(\"aa\"); set.add(\"bb\"); set.add(\"cc\"); //使用迭代器遍历Set for(Iterator&lt;String&gt; iter = set.iterator();iter.hasNext();) { String temp = iter.next(); System.out.println(temp); } } public static void testIteratorMap() { Map&lt;Integer,String&gt; map1 = new HashMap&lt;&gt;(); map1.put(100,\"aa\"); map1.put(200,\"bb\"); map1.put(300,\"cc\"); Set&lt;Map.Entry&lt;Integer,String&gt;&gt; ss = map1.entrySet();//首先获得一个Set //使用迭代器遍历Map for(Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter = ss.iterator();iter.hasNext();){ Map.Entry&lt;Integer,String&gt; temp = iter.next(); System.out.println(temp.getKey()+\"--\"+temp.getValue()); } } public static void testIteratorMap2() { //第二种遍历Map的方式 Map&lt;Integer,String&gt; map2 = new HashMap&lt;&gt;(); map2.put(100,\"aa\"); map2.put(200,\"bb\"); map2.put(300,\"cc\"); Set&lt;Integer&gt; keyset = map2.keySet();//首先获得一个Set for(Iterator&lt;Integer&gt; iter = keyset.iterator();iter.hasNext();) { Integer key = iter.next(); System.out.println(key+\"---\"+map2.get(key)); } } } Collections工具类这和Collection接口不是一个东西，它提供了对Set、List、Map进行排序、填充、查找元素的辅助方法 void sort(List) 对List容器内的元素排序，排序的规则是按照升序进行排序 void shuffle(List) 对List容器内的元素进行随机排列 void reverse(List) 对List容器内的元素进行逆续排列 void fill(List, Object) 用一个特定的对象重写整个List容器 int binarySearch(List, Object) 对于顺序的List容器，采用折半查找的方法查找特定对象","categories":[{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JAVA6. 常用实用类","slug":"JAVA6. 常用实用类","date":"2022-09-09T07:13:36.540Z","updated":"2022-09-09T07:13:36.541Z","comments":true,"path":"2022/09/09/java6.chang-yong-shi-yong-lei/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/java6.chang-yong-shi-yong-lei/","excerpt":"","text":"包装类Java中的基本数据类型不是对象，但有时却要将这些基本数据类型转化为对象，因此Java中也提供了一些包装类来将基本数据类型转化为对象 基本数据类型 包装类 byte Byte boolean Boolean short Shout char Character int Integer long Long float Float double Double /** * 测试包装类 */ public class TestWrappedClass { public static void main(String[] args) { //基本数据类型转成包装类对象 Integer a = new Integer(3); Integer b = Integer.valueOf(30); //包装类对象转成基本数据类型 int c = b.intValue(); double d = b.doubleValue(); //把字符串转成包装类对象 Integer e = new Integer(\"9999\"); Integer f = Integer.parseInt(\"9999\"); //把包装类对象转成字符串 String str = f.toString(); //常见常量 System.out.println(\"int类型最大的整数：\"+Integer.MAX_VALUE); System.out.println(\"int类型最小的整数\" +Integer.MIN_VALUE); } } 包装类所做的就是实现基本数据类型、包装类、字符串之间的转化，基本数据类型想转化成字符串，首先将其转化为包装类，然后通过包装类的方法转化成字符串 1. 自动装箱和拆箱/** * * 测试自动装箱、自动拆箱 */ public class TestAutoBox { public static void main(String[] args) { //自动装箱 Integer a = 111;//编译器自动帮助修改成Interger a=Integer.valueOf(111); //自动拆箱 int b=a; //编译器会自动修改成int b = a.intValue(); } } 2. 包装类的缓存问题创建Integer对象自动装箱的时候，会先静态初始化Integer类将-128到127的数字存储在一个cache数组里面，如果创建的数字是在-128到127之间就直接从cache数组里面取，如果不在这个范围之内就new一个新的对象出来 public class TestAutoBox { public static void main(String[] args) { //自动装箱 Integer a = 111;//编译器自动帮助修改成Interger a=Integer.valueOf(111); //自动拆箱 int b=a; //编译器会自动修改成int b = a.intValue(); Integer in1 = -128; Integer in2 = -128; System.out.println(in1 == in2);//true 因为123在缓存范围内 System.out.println(in1.equals(in2));//true System.out.println(\"*******************\"); Integer in3 = 1234; Integer in4 = 1234; System.out.println(in3 == in4);//false 因为1234不在缓存范围内 System.out.println(in3.equals(in4));//true } } String类String 类对象代表不可变的Unicode字符序列，指的是对象内部的成员变量的值无法再改变。字符串的内容全部存储到String类的Value数组中，这个数组是final类型 1. StringBuilder和StringBufferStringBuilder和StringBuffer称为可变字符序列，它们之间的区别在于：StringBuilder线程不安全，效率高（一般使用它）;StringBuffer线程安全效率低 常用方法： 重载的public StringBuilder append(…)方法 可以为该StringBuilder 对象添加字符序列，仍然返回自身对象。 方法 public StringBuilder delete(int start,int end) 可以删除从start开始到end-1为止的一段字符序列，仍然返回自身对象。 方法 public StringBuilder deleteCharAt(int index) 移除此序列指定位置上的 char，仍然返回自身对象。 重载的public StringBuilder insert(…)方法 可以为该StringBuilder 对象在指定位置插入字符序列，仍然返回自身对象。 方法 public StringBuilder reverse() 用于将字符序列逆序，仍然返回自身对象。 方法 public String toString() 返回此序列中数据的字符串表示形式。 2. 不可变和可变序列的使用陷阱String类对象一经初始化之后，就不会改变其内容。对String字符串的操作实际上是对其拷贝出来的副本进行操作，相当于再次创建了一个新的字符串对象，原本的字符串一点都没有改变。 如果多次对不可变字符串序列进行操作，即不可变字符串序列操作放在循环中的时候，会造成字符串对象留在内存中，占用资源，极大影响程序的时间和空间性能，造成服务器崩溃 而StringBuilder和StringBuffer类是对原字符串本身操作的，可以对字符串进行修改而不产生副本拷贝或者产生少量的副本，可以在循环中使用 如下测试可以看出： public class TestStringBuild { public static void main(String[] args) { /**使用String进行字符串的拼接*/ String str8 = \"\"; //本质上使用StringBuilder拼接, 但是每次循环都会生成一个StringBuilder对象 long num1 = Runtime.getRuntime().freeMemory();//获取系统剩余内存空间 long time1 = System.currentTimeMillis();//获取系统的当前时间 for (int i = 0; i &lt; 5000; i++) { str8 = str8 + i;//相当于产生了10000个对象 } long num2 = Runtime.getRuntime().freeMemory(); long time2 = System.currentTimeMillis(); System.out.println(\"String占用内存 : \" + (num1 - num2)); System.out.println(\"String占用时间 : \" + (time2 - time1)); /**使用StringBuilder进行字符串的拼接*/ StringBuilder sb1 = new StringBuilder(\"\"); long num3 = Runtime.getRuntime().freeMemory(); long time3 = System.currentTimeMillis(); for (int i = 0; i &lt; 5000; i++) { sb1.append(i); } long num4 = Runtime.getRuntime().freeMemory(); long time4 = System.currentTimeMillis(); System.out.println(\"StringBuilder占用内存 : \" + (num3 - num4)); System.out.println(\"StringBuilder占用时间 : \" + (time4 - time3)); } } OUT： String占用内存 : 22598216 String占用时间 : 51 StringBuilder占用内存 : 0 StringBuilder占用时间 : 1 File类用于开发中的，读取文件、生成文件、删除文件、修改文件的属性 /** * 测试File类 */ public class TestFile { public static void main(String[] args) throws IOException { //创建文件 System.out.println(System.getProperty(\"user.dir\"));//user.dir表示本项目的目录 File f = new File(\"a.txt\");//相对路径，默认放到user.dir f.createNewFile(); //要求抛出IO异常 File f2 = new File(\"/home/soleman/IdeaProjects/Javaproject/b.txt\"); f2.createNewFile(); } } 1. 通过File对象可以访问文件的属性： import java.io.File; import java.util.Date; public class TestFile2 { public static void main(String[] args) throws Exception { File f = new File(\"d:/b.txt\"); System.out.println(\"File是否存在：\"+f.exists()); System.out.println(\"File是否是目录：\"+f.isDirectory()); System.out.println(\"File是否是文件：\"+f.isFile()); System.out.println(\"File最后修改时间：\"+new Date(f.lastModified()));//lastModified返回的是一个long类型 System.out.println(\"File的大小：\"+f.length()); System.out.println(\"File的文件名：\"+f.getName()); System.out.println(\"File的目录路径：\"+f.getPath()); } } 2. 通过File对象创建空文件或目录（在该对象所指的文件或目录不存在的情况下） mkdir和mkdirs的不同 mkdir：目录结构中有一个不存在，则不会创建整个目录树 mkdirs：目录结构中有一个不存在也没关系；创建整个目录树 枚举类1. 定义格式enum 枚举名 { 枚举体（常量列表） } 枚举实质上还是类!而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final修饰的。可以直接通过枚举类型名使用它们。 尽量不要使用枚举的高级特性，事实上高级特性都可以使用普通类来实现，没有必要引入枚举，增加程序的复杂性! 异常类在Java的异常处理机制中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中包含了该类异常的信息和对异常进行处理的方法。 异常处理，就是指程序在出现问题时依然可以正确的执行完。 Java是采用面向对象的方式来处理异常的。处理过程： 抛出异常：在执行一个方法时，如果发生异常，则这个方法==生成代表该异常的一个对象==，停止当前执行路径，并把异常对象提交给JRE（java运行时环境）。 捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。 1. 异常分类 Exception是我们程序员需要管理的，它分为 RuntimeException 运行时异常，程序在运行过程中可能产生各种异常 CheckedException 已检查异常，编译时检测出的异常，出现该异常会造成编译失败，程序无法运行 2. 捕获异常（try-catch）定义格式： try{ 语句1; 语句2; .... }catch（Exception1 e）{ }catch（Exception2 e）{ }finally{ } 捕获异常是通过3个关键词来实现的：try-catch-finally。用try来执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕捉(catch)并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，==finally所指定的代码都要被执行==(catch语句可有多条;finally语句最多只能有一条，根据自己的需要可有可无)。 程序先执行try中的语句，如果try的语句执行过程中没有出现异常则不需要使用异常处理机制catch，否则抛出异常，使用catch异常处理机制来捕获异常。当异常处理的代码执行结束以后，不会回到try语句去执行尚未执行的代码。 3. 声明异常（throw子句）捕获异常是使用try-catch方法来处理异常，但对于CheckedException产生的时候，不一定要立刻处理它，可以把异常再throw出去，传递给调用它的方法处理，还可以一层层往上抛，假如在程序中没有得到处理，则由编译器进行异常处理 如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。 如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。 方法重写中声明异常原则：子类重写父类方法时，如果父类方法有声明异常，那么子类声明的异常范围不能超过父类声明的范围。 4. 自定义异常 在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。 自定义异常类只需从Exception类或者它的子类派生一个子类即可。 自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。 习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。 class IllegalAgeException extends Exception { //默认构造器 public IllegalAgeException() { } //带有详细信息的构造器，信息存储在message中 public IllegalAgeException(String message) { super(message); } } class Person { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) throws IllegalAgeException { if (age &lt; 0) { throw new IllegalAgeException(\"人的年龄不应该为负数\"); } this.age = age; } public String toString() { return \"name is \" + name + \" and age is \" + age; } } public class TestMyException { public static void main(String[] args) { Person p = new Person(); try { p.setName(\"Lincoln\"); p.setAge(-1); } catch (IllegalAgeException e) { e.printStackTrace(); System.exit(-1); } System.out.println(p); } }","categories":[{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JAVA5. 数组的深入","slug":"JAVA5. 数组的深入","date":"2022-09-09T07:13:36.533Z","updated":"2022-09-09T07:13:36.533Z","comments":true,"path":"2022/09/09/java5.shu-zu-de-shen-ru/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/java5.shu-zu-de-shen-ru/","excerpt":"","text":"数组的拷贝java中提供了一个函数叫作Systerm.ArrayCopy(src,srcpos,dest,destpos,length)的方法来给数组进行拷贝 /** * 测试数组的拷贝 */ public class TestArrayCopy { public static void main(String[] args) { extendRange(); } public static void testBasicCopy(){ String s1[] = {\"aa\",\"bb\",\"cc\",\"dd\",\"ee\"}; String s2[] = new String[10]; System.arraycopy(s1,2,s2,6,3); for (int i=0;i&lt; s2.length;i++) { System.out.println(i+\"--\"+s2[i]); } } //测试从数组中删除某个元素（本质上还是数组的拷贝） public static void testBasicCopy2() { //删掉cc String s1[] = {\"aa\",\"bb\",\"cc\",\"dd\",\"ee\"}; System.arraycopy(s1,3,s1,3-1,s1.length-3); s1[s1.length-1] = null; for (int i=0;i&lt; s1.length;i++) { System.out.println(i+\"--\"+s1[i]); } } //数组的扩容（本质上是：先定义一个更大的数组，然后讲原书租内容原封不动拷贝到新数组中） public static void extendRange() { String s1[]={\"aa\",\"bb\",\"cc\"}; String s2[] = new String[s1.length+10]; System.arraycopy(s1,0,s2,0,s1.length); for (String temp:s2) //foreach循环 { System.out.println(temp); } } } 多维数组1. 二维数组的声明public class Test2DemensionArray { public static void main(String[] args) { //Java中多维数组的声明和初始化应该从低维到高维的顺序进行 int[][] a= new int[3][]; a[0] = new int[]{20,30}; a[1] = new int[]{10,15,80}; a[2] = new int[]{50,60}; } } 在Java中只能指明一维数组的长度，二维的长度是不确定的，需要另外声明空间。但是在C语言中，指明的是二维的长度，而一维的长度是不确定的，这就是Java和C在二维数组上的区别","categories":[{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JAVA4. 面向对象深入","slug":"JAVA4. 面向对象深入","date":"2022-09-09T07:13:36.525Z","updated":"2022-09-09T07:13:36.525Z","comments":true,"path":"2022/09/09/java4.mian-xiang-dui-xiang-shen-ru/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/java4.mian-xiang-dui-xiang-shen-ru/","excerpt":"","text":"多态的内存分析多态存在的三大必要条件就是：继承、方法重写、父类引用指向子类对象 那么子类对象在被创建在堆中的时候，也会继承父类的方法，在内存中表现为继承树的形式，但是多态涉及重写的概念，因此子类中重写父类的构造方法或者成员方法时，无论子类对象还是父类对象都会有一个this属性来指向当前类的对象，因此调用重写的方法时，也是调用this指向对象的方法 以下面代码来说明： public class TestPolym { public static void main(String[] args) { Animal a = new Dog();//父类类型指向了子类对象，发生了多态,Dog是Animal的子类 //也可以这样写：Animal d = new Dog(); animalCry(a); Animal c = new Cat(); animalCry(c); } static void animalCry(Animal a) { a.shout(); } } class Animal{ public void shout() { System.out.println(\"叫了一声\"); } } class Dog extends Animal //继承 { public void shout() //父类方法重写 { System.out.println(\"旺旺旺！\"); } } class Cat extends Animal //继承 { public void shout() //父类方法重写 { System.out.println(\"喵喵喵喵！\"); } } 其内存结构图如下所示： 我们知道程序在没有编译器帮忙的情况下的执行语句是java+程序名（类名），这时就会找到这个程序，从这个程序的main函数进入，将这个类中的全部信息加载进入方法区，包括这个类中调用到的类 接着执行Animal a = new Dog();，a是一个局部变量存放在栈区中，且a是一个对象，这个对象存放在堆区中，然后栈区中的变量a赋值为堆区中创建对象的地址 每个对象下面的方法都会传递两个隐式参数（this,super），super在前面已经介绍过了它是指向该对象的父类对象，但是每个对象中的this表示的是什么呢？ this指向的就是最终的对象，即new出来的对象，这里是Dog对象，即不管你定义的变量是哪个父类类型（一定要是指向子类对象），它都会去调用最终new出来this对象中的方法 public class Test { public static void main(String[] args) { HttpServlet s = new MyServlet(); //new一个子类对象在多态继承时，this表示的是子类对象 s.service(); } } class HttpServlet { public void service() { System.out.println(\"HttpServlet.service()\"); doGet(); //到底调用的是子类的doGet（）还是调用父类的doGet（） } public void doGet(){ System.out.println(\"HttpServlet.doGet()\"); } } class MyServlet extends HttpServlet { public void doGet() //子类中重写父类的方法 { System.out.println(\"Myservlet.doGet()\"); } } OUT： HttpServlet.service() Myservlet.doGet() 抽象类和抽象方法1. 什么是抽象类抽象类是一种模板，抽象类为所有子类提供类一个通用模板，子类可以在这个模板的基础上进行扩展，即重写抽象类中的方法 2. 为什么要定义抽象类通过抽象类，可以避免子类设计的随意性。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用，也就是说继承抽象类的子类必须要重写抽象类中的方法，因为抽象类中的方法只是给出了声明而没有定义 3. 要点 有抽象方法的抽象类只能定义为抽象类 抽象类不能实例化，不能用new来实例化抽象类 抽象类可以包含属性、方法、构造方法。但是构造方法不能用new实例，只能用来被子类调用 抽象类只能用来继承 抽象方法必须被子类实现 4. 抽象类的意义实现了设计和实现的分离 5. 实现定义抽象类使用abstract关键字定义 package OO.TestAbstract; /** * 测试抽象类 */ public abstract class Animal { String str; //抽象类中可以有其属性 public abstract void run(); public void breath()//抽象类中可以有其实现方法 { System.out.println(\"呼吸\"); } public Animal()//抽象类中也可以重写抽象类的构造方法 { System.out.println(\"创造一个动物\"); } } class Cat extends Animal{ @Override public void run() { System.out.println(\"猫步\"); } } package OO.TestAbstract; public class Test { Animal a = new Cat();//尽管抽象类不能使用new创建对象，但是可以抽象类可以作为对象的类型 } 接口1. 什么是接口接口是比抽象类还抽象的“抽象类”，接口中只有常量和方法。接口是一种规范，实现的是“如果你是….，则必须能….”的现实逻辑 2. 接口的作用可以更加规范的对子类进行约束，全面地专业的实现：设计与具体实现的分离。项目的具体需求是多变的，而规范是不变的，开发大型项目的时候就是面向接口编程，定义好接口后，只要改变接口中的方法就可以实现开发，而不需要频繁的改变接口的内容 3. 定义格式 [访问修饰符] interface 接口名 extends 父接口1,父接口2…. 常量定义 总是public static final 方法定义 总是public abstract 子类通过implements来实现接口中的规范（方法） 接口不能创建实例，但是可以作为引用变量的类型 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的 4. 接口的多继承/** * 测试接口多继承 */ public interface InterfaceA { public void aaa(); } interface InterfaceB{ public void bbb(); } interface InterfaceC extends InterfaceA,InterfaceB{ //继承接口A和接口B，拥有了接口A和接口B中的全部方法 public void ccc(); } class Testclass implements InterfaceC{ //此时有一个子类继承了接口C，那么这个子类也继承了接口A和接口B，需要重写接口A和B的全部方法 @Override public void aaa() { } @Override public void bbb() { } @Override public void ccc() { } } 内部类java中的内部类主要分为成员内部类（非静态内部类、静态内部类）、匿名内部类、局部内部类 1. 非静态内部类 非静态成员内部类必须==寄存在一个外部类的对象里==。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员 非静态内部类不能有静态方法、静态属性和静态初始化块，即不能出现static关键字定义的变量和方法 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例 成员变量访问要点： 访问内部类方法里的局部变量：直接使用变量名 访问内部类的属性：使用this.变量名的方法 外部类属性：使用外部类名.this.变量名public class TestInnerClass { public static void main(String[] args) { //创建内部类对象 Outer.inner inner = new Outer().new inner();//先创建外部类对象，再new内部类对象，非静态内部类对象依托于外部类对象 inner.show(); } } class Outer{ private int age = 10; public void testOuter() { } //非静态内部类 class inner { int age = 20; public void show() { int age = 30; System.out.println(\"外部类的成员变量age：\"+Outer.this.age); System.out.println(\"内部类的成员变量age：\"+this.age); System.out.println(\"局部变量age：\"+age); } } } OUT： 外部类的成员变量age：10 内部类的成员变量age：20 局部变量age：30 2. 静态内部类定义方式： static class className{ //类体 } 使用要点: ==当一个静态内部类对象存在，并不一定存在对应的外部类对象==。因此，静态内部类的实例方法不能直接访问外部类的实例方法 静态内部类看做外部类的一个静态成员。因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过new静态内部类的实例 /** * 测试静态内部类 */ public class TestStaticInnerClass { public static void main(String[] args) { Outer2.Inner2 inner = new Outer2.Inner2();//静态内部类不依托与外部类对象 } } class Outer2{ static class Inner2 { } } 3. 匿名内部类语法： new 父类构造器（实参类表）\\实现接口（）{ //匿名内部类类体 } 注意 匿名内部类没有访问修饰符 匿名内部类没有构造方法 主要应用于那些只使用一次以及临时使用而定义的内部类中，类似==应用于以接口对象为参数的方法==，应为接口不能使用new方法来实例化，因此可以使用声明匿名内部类的方式来传输参数 public class TestAnnonymousInnerClass { public static void test01(AA a) { a.aa(); } public static void main(String[] args) { TestAnnonymousInnerClass.test01(new AA() //匿名内部类 { @Override public void aa() { System.out.println(\"TestAnonymousInnerClass.main(...).new AA(){...}.aa()\"); } }); } } interface AA{ void aa(); } 4. 局部内部类定义在方法内部，作用域只限于本方法，称为局部内部类，局部内部类在开发中应用很少 String类1. 常量池在JVM中，有一个概念叫作常量池，它分为全局字符串常量池、class文件常量池、运行时常量池，JVM会将程序中使用双引号引起来的字符串内容放入常量池中 讲常量池的目的是为了说明比较两个字符串的时候不能单纯的使用==号来比较，应该使用equals来比较","categories":[{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JAVA3. 初识面向对象","slug":"JAVA3. 初识面向对象","date":"2022-09-09T07:13:36.513Z","updated":"2022-09-09T07:13:36.513Z","comments":true,"path":"2022/09/09/java3.chu-shi-mian-xiang-dui-xiang/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/java3.chu-shi-mian-xiang-dui-xiang/","excerpt":"","text":"继承的实现继承让我们更加容易实现类的扩展，实现了代码的重用，子类是父类的扩展，使用extends实现 继承使用要点： 父类也称为超类、基类、派生类等 Java中只有单继承，没有像C++那样的多继承、多继承会引起混乱，使得继承链过于复杂，系统难于维护 java中类没有多继承，接口有多继承 子类继承父类，可以得到父类的全部属性和方法（除了父类的构造方法），但不见得可以直接访问（比如父类私有的属性和方法） 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object instanceof运算符instanceof是二元运算符，左边是对象，右边是类;当对象为右边类或子类所创建的对象时，返回true;否则返回false 代码似乎出现了问题 package OO; /** * 测试继承 */ public class TestExends { public static void main(String[] args) { Student stu = new Student(); stu.name = \"小明\"; stu.height = 180; stu.rest(); //子类调用父类的方法 Student stu2 = new Student(\"小红\",6,\"计算机\"); } } class Person /*extends object*/{ String name; int height; public void rest() { System.out.println(\"休息一会！\"); } } //String name; //int height; String major; public void study() { System.out.println(\"学习两小时！\"); } /* public void rest() { System.out.println(\"休息一会！\"); } */ public Student(String name,int height,String major) //重载构造方法 { this.name = name; this.height = height; this.major = major; } public Student() //重载构造方法 { } } 方法的重写override子类通过重写父类的方法，可以用自身的行为替换父类的行为 方法的重写需要符合下面的三个要点： “==”：方法名、形参列表和父类相同 “&lt;=”：返回值类型和声明异常类型（子类中重写父类的返回值类型），子类小于等于父类 “&gt;=”：访问权限，子类大于等于父类 /** * 测试重写 */ public class TestOverRide { public static void main(String[] args) { Horse h = new Horse(); h.run(); } } class vehicle { public void run(){ System.out.println(\"跑...\"); } public void stop(){ System.out.println(\"停止！\"); } } class Horse extends vehicle{ public void run(){ System.out.println(\"得得得得...\"); //重写父类的方法实现子类的自身行为 } } OUT： 得得得得... Object类以及toString方法Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法 package OO; public class TestObject { public static void main(String[] args) { //Object obj; TestObject to = new TestObject(); System.out.println(to); //打印一个对象相当于调用对象的toString方法 Person2 p2 = new Person2(\"小红\",6); System.out.println(p2); } public String toString() { return \"测试Object对象\"; //子类重写父类的toString方法 } } class Person2{ String name; int age; @Override public String toString() { return name+\"，年龄：\"+age; } public Person2(String name,int age) //重载构造方法 { this.name = name; this.age = age; } } OUT： 测试Object对象 小红，年龄：6 == 和equals方法“==”代表比较双方是否相同，如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象 equals方法： Object类中定义有：public boolean equals（Object obj）方法，提供定义“对象内容相等”的逻辑，经常会重写equals方法 String类中也定义了equals方法，主要就是对两个String对象逐个字符进行比较，如果都相等则返回true package OO; import java.util.Objects; public class TestEquals { public static void main(String[] args) { Object obj; String str; User u1 = new User(5,\"小明\",\"123456\"); User u2 = new User(5,\"小红\",\"123456\"); System.out.println(u1==u2); System.out.println(u1.equals(u2));//本来u1和u2是两个不同的对象调用equals方法应该是false但是通过重写equals方法可以使其结果为true } } class User{ int id; String name; String pwd; public User(int id,String name,String pwd) { super(); this.id = id; this.name = name; this.pwd = pwd; } @Override //用编译器自动生成这段代码 public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof User)) return false; User user = (User) o; //强制转型 if(id!= user.id){ //重写equals方法 return false; } return true; } } OUT： false true super父类对象引用及继承树的追溯1. super父类对象引用super是直接父类对象的引用，可以==通过super来访问父类中被子类覆盖的方法或属性==，使用super调用普通方法，语句没有位置限制，可以在子类中随便调用 若是构造方法的第一行代码没有显式的调用super或者this那么java默认都会调用super（），含义是调用父类的无参数构造方法，这里的super（）可以省略 package OO; /** * 测试父类 */ public class TestSuper01 { public static void main(String[] args) { new ChildClass().f(); } } class FatherClass{ public int value; public void f(){ value = 100; System.out.println(\"FatherClass.value=\" + value); } } class ChildClass extends FatherClass{ public int value; public void f() { super.f(); //通过super调用父类对象的普通方法 value = 200; System.out.println(\"ChildClass.value=\"+value); System.out.println(value); System.out.println(super.value); //通过super调用父类对象的成员变量 } } OUT: FatherClass.value=100 ChildClass.value=200 200 100 2. 继承树追溯构造方法的第一句都是super()（可写可不写），相当于调用父类构造方法 属性/方法查找顺序： 查找当前类中有没有待查属性 依次上溯每个父类，查看每个父类是否有待查属性，直到Object 如果没找到，则出现编译错误 上面步骤，只要找到待查变量，则这个过程终止 构造方法调用顺序：构造方法第一句总是：super()来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后依次向下执行类的初始化块和构造方法，直到当前子类为止 注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复 package OO; public class TestSuper02 { public static void main(String[] args) { System.out.println(\"开始创建一个ChildClass对象....\"); new ChildClass_2(); //new一个子类对象，相当于调用子类的构造方法 } } class FatherClass_2{ public FatherClass_2(){ //super(); System.out.println(\"创建FatherClass\"); } } class ChildClass_2 extends FatherClass_2{ public ChildClass_2(){ //super(); System.out.println(\"创建ChildClass\"); } } OUT： 开始创建一个ChildClass对象.... 创建FatherClass 创建ChildClass 封装 程序追求“高内聚，低耦合” 1. 访问控制符java是使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露的。java中4种“访问控制符”说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性 private 表示私有属性 default表示没有修饰符修饰，只有同一个包的类能访问 protected表示可以被同一个包的类以及其他包中的子类访问 public表示可以被该项目的所有包中的所有类访问 2. 封装的使用细节对于上面的四个关键字，什么时候去使用什么应该如何定义区分？有一定的规则：类的属性的处理： 一般使用private访问权限 提供相应的==get/set方法==来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作（注意：boolean变量的get方法是is开头） 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法可以用public修饰。 get和set的方法一般可以通过编译器的自动生成写出来 package OO; /** * 测试封装 */ public class Person4 { private int id; private String name; private int age; private boolean man; public void setName(String name) { this.name = name; } public void setAge(int age){ // 若是对set方法有一些约束可以在set方法里面进行修改（同理get方法也是一样的） if(age&gt;=1 &amp;&amp; age&lt;=100) { this.age = age; } else{ System.out.println(\"请输入正常的年龄！\"); } } public void setMan(boolean man) { this.man = man; } public String getName(){ return this.name; } public int getAge(){ return this.age; } public int getId() { return id; } public void setId(int id) { this.id = id; } } package OO; /** * 测试封装 */ public class TestEncapsulation { public static void main(String[] args) { Human h = new Human(); h.height = 180; //h.age = 13;age是私有属性 Person4 p4 = new Person4(); p4.setAge(14);//由于age已经是私有的属性，不能直接通过对象来访问它，因此要给它设置get和set的方法 p4.setName(\"小红\"); System.out.println(p4.getName()); } } 多态及对象的转型1. 多态多态指的是同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同 多态的要点： 多态是方法的多态，不是属性的多态（多态与属性无关）。 多态的存在要有三个必要条件：继承、方法重写、父类引用指向子类对象。 父类引用指向子类对象之后，用该父类引用调用子类重写的方法，此时多态就出现了。 package OO; public class TestPolym { public static void main(String[] args) { Animal a = new Animal(); animalCry(a); Animal d = new Dog();//父类类型指向了子类对象，发生了多态,Dog是Animal的子类 //也可以这样写：Animal d = new Dog(); animalCry(d); Animal c = new Cat(); animalCry(c); } static void animalCry(Animal a) { a.shout(); } } class Animal{ public void shout() { System.out.println(\"叫了一声\"); } } class Dog extends Animal //继承 { public void shout() //父类方法重写 { System.out.println(\"旺旺旺！\"); } } class Cat extends Animal //继承 { public void shout() //父类方法重写 { System.out.println(\"喵喵喵喵！\"); } } OUT： 叫了一声 旺旺旺！ 喵喵喵喵！ 2. 对象的转型Animal d = new Dog();//自动向上转型 Dog d = (Dog) d;//强制向下转型 final关键字作用： 修饰变量：被他修饰的变量不可改变，一旦赋了初值，就不能被重新赋值 修饰方法：该方法不可被子类重写，但是可以被重载 修饰类：修饰的类不能被继承 数组数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引（下标）来访问它们 特点： 长度是确定的，数组一旦被创建，它的大小就是不可以改变的。 其元素必须是相同类型，不允许出现混合类型。 数组类型可以是任何数据类型，包括基本类型和引用类型。 数组变量属于引用类型，数组也是对象，数组中的每个元素相当于该对象的成员变量。 1. 数组的声明注意事项： 声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关 声明一个数组的时候并没有真正被创建 构造一个数组，必须指定长度 2. 数组的初始化方式/** * 测试三种初始化的方式 */ public class Test02 { public static void main(String[] args) { //静态初始化 int a[] = {1,2,3}; User b[] = {new User(100 ,\"小明\"), new User(101,\"小红\"), new User(102,\"小李\") }; //默认初始化 int c[] = new int[3];//默认给数组的元素进行赋值，赋值的规则和尘缘变量默认赋值规则一样 //动态初始化，通过下标挨个赋值 int d[] = new int[2]; d[0] = 1; d[1] = 2; } } 3. 数组的遍历foreach循环foreach循环是用来读取数组或集合中所有的元素，即对数组进行遍历 public class Test03 { public static void main(String[] args) { int a[] = new int[4]; //动态初始化数组 for (int i=0;i&lt;a.length;i++) { a[i] = 100*i; } //循环读取数组 for (int i=0;i&lt;a.length;i++) { System.out.println(a[i]); } //foreach循环用于读取数组元素的值 for(int m:a){ System.out.println(m); } } } OUT： 0 100 200 300 0 100 200 300","categories":[{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JAVA2. 面向对象前沿知识","slug":"JAVA2. 面向对象前沿知识","date":"2022-09-09T07:13:36.504Z","updated":"2022-09-09T07:13:36.505Z","comments":true,"path":"2022/09/09/java2.mian-xiang-dui-xiang-qian-yan-zhi-shi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/java2.mian-xiang-dui-xiang-qian-yan-zhi-shi/","excerpt":"","text":"面向对象和面向过程的区别1. 面向过程面向过程是指针对一个问题，为其设定一系列有序的解决步骤来解决这个问题，分为第一步，第二步，第三步等 2. 面向对象而面向对象针对的是解决问题的几个重要“部件”，就是将问题抽象分解为几个相关的部分，然后专注于这几个部分怎么做即可 3. 区别面向过程可以看作是一项不需要“协作”的工作，从头到尾可以一步一步的完成，而面向对象则是一项需要“协作”的工作，将这个工作分发给几个人来完成，这几个人完成自己需要完成的工作后再整合起来，从而达到完成整项工作的目的 面向对象作用于宏观把握设计程序，面向过程在于微观实现具体步骤，这两者不是对立的，一项工程中既需要面向对象也需要面向过程 类与对象1. 对象是什么？对象和类的实例等同，对象中包含了属性和方法，就像一个人的拥有其特殊的性格和行为 2. 类类是一类事物的抽象，在JAVA中类作为程序的基本组成单位，因此类相当于一项工程中的组成部件，复杂的工程就是通过组建起一个个部件来完成的 类中一般包含三种常见的成员：属性，方法，构造器 3. 类与对象之间的联系类相当于对象的模板，创建一个类的实例，也就是创建对象，就需要知道这个对象中包含什么属性和拥有什么行为，而这些都是由类的定义得出的，因此说类是创建对象的模板 public class STU { //属性 int id = 1900300221; String name; int age=18; //方法 void study() { System.out.println(\"我在学习！\"); } void play() { System.out.println(\"我在看小说！\"); } public static void main(String[] args) { //new一个对象 STU st = new STU(); st.study(); st.play(); System.out.println(st.id); System.out.println(st.age); } } out: 我在学习！ 我在看小说！ 1900300221 18 public class STU { //属性 int id; String name; int age; //类可以相互嵌套 Computer comp;//每个人计算机 //方法 void study() { System.out.println(\"我在学习！\"+comp.brand); } void play() { System.out.println(\"我在看小说！\"); } public static void main(String[] args) { //new一个对象 STU st = new STU(); st.id = 1; st.name = \"Student\"; st.age = 18; Computer c = new Computer(); c.brand = \"HuaWei\"; //引用类型传递 st.comp = c; st.study(); st.play(); } } //一个java文件中可以有多个类，但只能有一个public修饰的类 class Computer{ String brand; } out: 我在学习！HuaWei 我在看小说！ 内存分析Java虚拟机的内存可分为三个区域：栈stack、堆heap、方法区method area 1. 内存中的栈 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧（用于存储局部==变量==、==操作数==、==方法出口==等） JVM为每个线程（线程可以理解为一个函数方法）创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等） 栈属于线程私有，不能实现线程间的共享（一个程序进程中可以有多个函数方法，也就是多个线程） 栈存储特性是“先进后出，后进先出”，当方法执行完毕之后，栈帧会消除，直到栈帧全部消除，栈也消除 栈是由系统自动分配，速度快！栈是一个连续的内存空间！ 2. 内存中的堆 堆用于存储创建好的对象（包括数组，数组也是对象） JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢！ 3. 内存中的方法区（静态区） JVM只有一个方法区，被所有线程共享！ 方法区在堆中，实际也是堆，只是用于存储类、常量相关的信息！ 用来存放程序中永远是不变或唯一的内容。（类信息、静态变量、字符串常量等） 在我看来，方法区就相当于厨房里的佐料区，当厨师（线程）在需要添加佐料时（执行栈帧的时候）需要在这个区域里寻找所需要的佐料（寻找字符串常量、静态变量、以及类对象等） 4. 解读图 下面根据上方的程序绘画解读图，以便对内存有更进一步的了解 一个程序的内存初始状态如图所示： 加载类的相关信息进入方法区 有类信息之后，再类信息中寻找main方法，接着调用main，此时会在栈区生成main方法的栈帧，在调用main方法时，发现方法内还有STU()构造方法，因此会再生成一个STU构造方法的栈帧 接着执行STU构造方法的栈帧，执行完毕之后会在堆中创建STU（初始化）类对象，并将栈区中的栈帧删除，接着执行main方法的赋值语句，注意的是st.name的字符串常量是在方法区中找 再下去就遇到了Computer的构造方法，因此再栈中创建一个Computer构造方法的栈帧，并在堆区中开辟空间给Computer的对象，然后删除在栈区中的Computer构造方法的栈帧，并将对象的地址赋值给c 直到程序执行完毕，系统收回内存 构造器（构造方法） 构造方法用于对象的初始化 1. 要点： 通过new关键字调用 构造器虽然有返回值，但是==不能定义返回值类型（返回值的类型肯定是本类）==，不能在构造器里使用return返回某个值 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加，可自己写一个无参构造函数 构造器的方法名必须和类名一致 public class TestConStructor { public static void main(String[] args) { Point p = new Point(3.0,4.0); Point origin = new Point(0.0,0.0); System.out.println(p.getDistance(origin)); } } class Point { double x,y; //构造方法必须和类的名字一致 public Point(double _x,double _y){ x = _x; y = _y; //不能返回值，但能用return结束 return ; } public double getDistance(Point p) { return Math.sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y)); } } 2. 构造方法的重载构造方法的重载和其他方法的重载一样，其实编写构造方法也可以认为是一种重载 class User { int id; String name; String pwd; //下面就是构造方法的重载，根据参数的不同构造函数也不同 public User() { } public User(int id, String name) { super(); //构造方法的第一句总是super（），不加的话编译器会自动加上 this.id = id; //this关键字表示创建好的对象 this.name = name; } public User(int id,String name,String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public static void main(String[] args) { User u1 = new User(); User u2 = new User(101,\"小明\"); User u3 = new User(1000,\"小红\",\"123456\"); } } 垃圾回收机制（了解概念即可） java引入垃圾回收机制，令C++程序员头疼的内存管理问题迎刃而解。java程序员可以将更多的精力放到业务逻辑上而不是内存管理工作上，大大的提高令开发效率 1. 垃圾回收机制算法的作用 发现无用的对象 回收无用对象占用的内存空间 2. 垃圾回收相关算法 引用计数法堆中每个对象都有一个引用计数。被引用一次，计数加1。被引用变量值变为null，则计数减1,直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法使别 引用可达法（常用）程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点 3. 分代垃圾回收机制不同的对象的生命周期是不一样的，因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。 对象可以分为：年轻代，年老代，持久代JVM将内存分为：Eden（年轻代）、Survivor（持久代）、Tenured/Old（年老代，在方法区中） 垃圾回收的过程： 新创建的对象，绝大多数都会存储在Eden中 当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor（持久代）中，例如S1，同时清空Eden区（年轻代） 当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor（持久代）中，如S2 重复多次（默认15次）Survivor中没有被清理的对象，则会复制到老年代Old（Tenured）区中 当Old区达到一定比例时，会对Old区进行一次清理Major GC 当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为Minor GC 4. JVM调优和Full GC在JVM调优的过程中，很大一部分工作就是对于Full GC的调节，有如下原因可能导致Full GC： 年老代（Tenured）被写满 持久代（Perm）被写满 System.gc()被显式调用，只是程序建议GC启动，而不是调用GC 上一次GC之后Heap的各域分配策略动态变化 5. 容易造成内存泄露的操作 创建大量无用对象 静态集合类的使用 各种链接对象（IO流对象、数据库连接对象、网络连接对象）未关闭 监听器的使用，释放对象时，没有删除相应的监听器 this的本质1. 对象创建的过程 分配对象空间，并将对象成员变量初始化为0或空 执行属性值的显式初始化 执行构造方法（实际上在执行构造方法前，对象已经被创建好了，执行构造方法的意义在于对对象进一步初始化） 返回对象的地址给相关的变量 this的本质就是“创建好的对象的地址”，由于在构造方法调用前，对象已经被创建好，因此，在构造方法中也可以使用this代表“当前对象” public class TestThis { int a,b,c; TestThis(int a,int b)//重写构造方法 { this.a = a; //this指当前类的对象 this.b = b; } TestThis(int a,int b,int c) { this(a,b); //表示调用当前类的构造方法,不可以使用TestThis(a,b)来调用 this.c = c; //同一个类的构造方法中调用另一个构造方法必须使用this，且必须在位于构造方法的第一句 } void sing() { } void eat() { this.sing(); //可以使用this来调用当前类的方法，this可用可不用 System.out.println(\"吃饭了！\"); } public static void main(String[] args) { TestThis hi = new TestThis(2,3); hi.eat(); } } this不能用于static方法中，因为static方法修饰的是静态变量（方法），而静态变量是位于方法区中，this指的是当前对象，对象是在堆中，因此不能在static中使用，可联系前面的内存分析来理解 static关键字在类中，用static声明的成员变量为静态成员变量，也称为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效 static修饰的成员变量和方法从属于类，普通变量和方法从属于对象 结合内存图来理解，static修饰的类成员变量和方法称为静态变量和静态方法，它们属于方法区中，而对象位于堆中，类信息就像是汽车的图纸，对象就是汽车，不可能只有图纸就要汽车实现动起来的功能，因此==静态方法中不能调用对象方法，但是对象方法中可以调用静态方法== /** * 测试static */ public class User2 { int id; String name; String pwd; static String company = \"baidu\";//用类static修饰是属于类的而不属于对象 public User2(int id,String name) { this.id = id; this.name = name; } public void login() { System.out.println(\"登录：\"+name); } public static void printCompany() { //在静态方法中不能调用非静态方法，但是在非静态方法中可以调用静态方法 System.out.println(company); } public static void main(String[] args) { User2 u = new User2(101,\"小马\"); User2.printCompany(); User2.company = \"ali\"; User2.printCompany(); } } 静态初始化块 构造方法用于对象的初始化，而静态初始化块，用于类的初始化操作，在静态初始化块中不能直接访问非static成员 注意事项： 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。 构造方法执行顺序和上面的顺序一样 参数传值机制java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件不会影响原件 1. 不同数据类型参数的传值 基本数据类型参数的传值传递的是值的副本。副本改变不会影响原件，相当于再创建了另一个对象，这个对象的值和原件的值是一样的，但是两个对象的地址是不一样的。 引用类型参数的传值传递的是值的副本。但是引用类型指的是“对象的地址”。因此，副本和原参数都指向令同一个“地址” public class User4 { int id; String name; String pwd; public User4(int id,String name) //重载构造方法 { this.id = id; this.name = name; } public void testParameterTransfer01(User4 u) //u1和u的地址都指向同一个地方 { u.name = \"小红\"; } public void testParameterTransfer02(User4 u) { u = new User4(200,\"小李\"); //new相当于调用类的构造方法，相当于新建一个对象，因此u的地址改变了 } public static void main(String[] args) { User4 u1 = new User4(100,\"小明\"); u1.testParameterTransfer01(u1); System.out.println(u1.name); u1.testParameterTransfer02(u1); System.out.println(u1.name); } } OUT: 小红 小红 java包机制包机制是java中管理类的重要手段。开发中，我们会遇到大量同名的类，通过包我们很容易解决类重名的问题，也可以实现对类的有效管理。包对于类，相当于文件夹对于文件的作用 通过package实现对类的管理，package的使用有两个要点： 通常是类的第一句非注释性语句 包名：域名倒着写即可，再加上模块名，便于内部管理类 注意事项： 写项目时都要加包，不要使用默认包 com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分 新建包的步骤：在编译器src目录上单击右键，选择new-&gt;package 1. import详解如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名，import之后，便于便于编写代码，提高可维护性注意要点： java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用 如果导入两个同名的类，只能用包名+类名来显示调用相关类 2. 静态导入其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性 package cn.sxt.gao; import cn.sxt.oo.User; //表示在其他包中导入了User类 import java.util.Date; import java.sql.*; import static java.lang.Math.*; public class Test { //如果不用import可以使用cn.sxt.oo.User user = new cn.sxt.oo User();来调用 public static void main(String[] args) { User user = new User(); String str; Date date = new Date(); //util中的Date System.out.println(Math.PI); //静态导入之前 System.out.println(PI); //静态导入之后 } }","categories":[{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JAVA1. 基础知识","slug":"JAVA1. 基础知识","date":"2022-09-09T07:13:36.498Z","updated":"2022-09-09T07:13:36.498Z","comments":true,"path":"2022/09/09/java1.ji-chu-zhi-shi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/java1.ji-chu-zhi-shi/","excerpt":"","text":"变量和常量1. 变量Java中的变量和Python中的变量差不多，主要分为局部变量和静态变量，以及成员变量。其中成员变量和静态变量是Java面向对象中常用到的 类型 声明位置 从属于 生命周期 局部变量 方法或语句块内部 方法/语句块 从生命位置开始，直到方法或语句块执行完毕，局部变量消失 成员变量（实例变量） 类内部，方法外部 对象 对象创建，成员变量也跟着创建。对象消失，成员变量也跟着消失 静态变量（类变量） 类内部，static修饰 类 类被加载（程序启动即加载），静态变量就有效，类被卸载，静态变量消失 2. 常量用final来定义 3. 变量和常量的命名规范 所有变量、方法、类名要做到见名知意 类、成员变量：首字母小写和驼峰原则配合 局部变量：首字母小写和驼峰原则配合 常量：大写字母和下划线 类名：首字母大写和驼峰原则配合 方法名：首字母小写和驼峰原则配合 数据类型1. 基本数据类型数值型：整数类型（byte一个字节，short二个字节，int四个字节，long八个字节），浮点类型（float四个字节，double八个字节）字符型（char两个字节）布尔型（boolean一位） 整形变量：定义long型变量时，初始常量一般要在后面加L/l表示这是一个long类型的常量 浮点型变量：浮点数值默认是double类型，float类型的数值后面有一个后缀F或f==浮点数是不精确的一定不要用来比较：== public class TestPrimitiveDatatype { public static void main(String[] args) { float f = 0.1f; double d = 1.0/10; System.out.println(f == d); float d1 = 423432423f; float d2 = d1 + 1; if(d1==d2) { System.out.println(\"d1==d2\"); } else{ System.out.println(\"d1!=d2\"); } } } out: false d1==d2 如果要比较浮点数要用java.math包下面的两个有用的类：BigInteger和BigDecimal 字符型变量：char类型用来表示在Unicode编码表中的字符，除了用英文字符来作为字符常量之外还能用中文字符来作为字符常量 char a = 'a'; char b = '中'; 转义字符 含义 Unicode值 \\b 退格 \\u0008 \\n 换行 \\u000a \\r 回车 \\u000d \\t 制表符 \\u0009 \\ “ 双引号 \\u0022 \\ ‘ 单引号 \\u0027 \\ \\ 反斜杠 \\u005c 布尔型：布尔常量只有true和false两种，常用判断 boolean man = true; 2. 引用数据类型（四个字节）类（class）接口（interface）数组 3. 自动类型转化容量小的数据类型可以自动转换为容量大的数据类型 虚线表示转换时可能会有精度的损失 运算符1.算数运算符整数运算法则： 如果两个操作数有一个为Long，则结果也为Long 没有long时，结果为int。即使操作数全为short，byte，结果也是int。 浮点运算法则： 如果两个操作数有一个为double，则结果为double 只有两个操作数都是float，则结果才为float 取模运算法则： 操作数可以为浮点数，一般使用整数，结果是余数，结果符号和左边操作数相同，如7%3=1，-7%3=-1，7%-3=1 2. 扩展运算符public class TestOperator { public static void main(String[] args) { int a = 3; int b = 4; a += b;//相当于a=a+b System.out.println(\"a=\"+a+\"\\nb=\"+b); a = 3; a *= b + 3;//相当于a=a*(b+3) System.out.println(\"a=\"+a+\"\\nb=\"+b); } } out: a=7 b=4 a=21 b=4 3. 关系运算符用于比较判断，判断结果只有true和false两个值 4. 逻辑运算符 运算符 意义 逻辑与（&amp;） 两个操作数为true，结果才是true，否则是false 逻辑或（|） 两个操作数有一个是true，结果就是true 短路与（&amp;&amp;） 只要一个为false，则直接返回false 短路或（||） 只要有一个为true，则直接返回true 逻辑非（！） 取反 逻辑异或（^） 相同为false，不同为true 短路计算顺序是从左到右计算，只需通过运算符左边的操作数就可以确定该逻辑表达式的值，则不会继续计算运算符右边的操作数，提高效率 5. 位运算符 运算符 意义 ~ 取反 &amp; 按位与 | 按位或 ^ 按位异或 &lt;&lt; 左移运算符，左移一位相当于乘2 右移运算符，右移一位相当于除2取商 6. 字符串连接符“+”运算符除了作为算术运算符之外，还作为字符串连接符，当运算符两侧操作数中只要有一个是字符串（String）类型，系统会自动将另一个操作数转换为字符串再进行连接 带标签的break和continue语句有类似于goto语句的功能，break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方 /** * 测试带标签的break和continue语句 */ public class TestLabelContinue { //打印101~150之间所有的质数 public static void main(String[] args) { outer:for(int i=101;i&lt;150;i++) { for(int j = 2;j&lt;i/2;j++) { if(i%j==0) { continue outer; } } System.out.print(i+\" \"); } } } out: 101 103 107 109 113 127 131 137 139 149 函数方法及方法的重载1. 函数方法在面向过程中，函数是最基本单位，整个程序由一个个函数组成，面向对象中，整个程序的基本单位是类，方法是从属于类和对象的 在Java中进行方法调用中传递参数时，遵循==值传递==的原则（传递的都是数据的副本） 基本类型传递的是该数据值得copy值 引用类型传递的是该对象引用的copy值，但指向的是同一个对象 public class TestMethod { public static void main(String[] args) { //通过对象调用普通方法 TestMethod tm = new TestMethod();//new一个对象出来 tm.printSxt(); tm.add(1,2,3); int sum = tm.add1(1,2,3); } void printSxt() { System.out.println(\"小明\"); System.out.println(\"小红\"); System.out.println(\"小方\"); } //带参数的函数方法 void add(int a, int b,int c) { int sum = a+b+c; System.out.println(sum); } //有返回值的方法 int add1(int a, int b,int c) { int sum = a+b+c; System.out.println(sum); return sum; } } out: 小明 小红 小方 6 6 2. 方法的重载方法的重载是指在一个类中可以定义多个方法名相同，但参数不同的方法。调用时，会根据不同的参数自动匹配对应的方法 重载的方法，实际是完全不同的方法，只是名称相同而已 不同在于：形参类型、形参个数、形参顺序不同 但是只有返回值不同或只有形参的名称不同，则不能构成方法的重载，因为调用方法时无法区分要调用哪个方法 public class TestOverLoad { public static void main(String[] args) { System.out.println(add(3,5)); System.out.println(add(3,5,10)); System.out.println(add(3.0,5)); System.out.println(add(3,5.0)); } public static int add(int n1,int n2) //加了static之后，就可以在main函数中直接调用，而不需要new一个对象了 { int sum = n1+n2; return sum; } public static int add(int n1,int n2,int n3) { int sum = n1 + n2 + n3; return sum; } public static double add(double n1,int n2) { double sum = n1 + n2; return sum; } public static double add(int n1,double n2) { double sum = n1 + n2; return sum; } }","categories":[{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"解决编译海思SDK引发的思考","slug":"解决编译海思SDK引发的思考","date":"2022-09-09T07:13:36.491Z","updated":"2022-09-09T07:13:36.492Z","comments":true,"path":"2022/09/09/jie-jue-bian-yi-hai-si-sdk-yin-fa-de-si-kao/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/jie-jue-bian-yi-hai-si-sdk-yin-fa-de-si-kao/","excerpt":"","text":"踩坑—如何安装海思的SDK（假）在我将海思给的sample使用VScode打开之后，发现很多都是标红的头文件，由于当时我还是在Windows上的VScode打开的sample样例，而海思Hi3516DV300的SDK是在Ubantu虚拟机上面编译的，所以我在想该不会是Windows上面没有SDK的这些文件，因此我将sample文件夹传入映射出来虚拟机的磁盘里面，再在虚拟机上面下载VScode（就是喜欢VScode，不解释），然后使用VScode打开sample工程，发现还是有很多海思的API文件是找不到，这是怎么回事呢？我开始百度寻找问题的原因，怀疑是编译SDK的时候出现错误，就又按照教程文档重新编译一遍，发现交叉编译工具arm-himix200-linux.tgz可能还真的没有安装（为什么说可能，因为我重新编译了之后这个文件就不见了，所以我不确定之前有没有编译），但是重新编译之后还是没能解决问题。 我只能去求助于老师了，最后老师和我说：“VScode可能会找不到，这也就是在VScode标红的原因，但是实际上在Ubantu编译出的SDK目录下是能找到这些文件的”，然后我在Ubantu上面使用find指令，确实找到了这些头文件 然后老师说：“使用VScode是用来写代码的，编译又不用VScode”，这引起了我的疑问，因为平时主要是开发的python，使用Pycharm直接帮忙编译了，所以开发只需要在Pycharm上面开发即可，还没有听说过代码编写和代码编译分离的方式，这让我感到新奇，但是如果说是开发PC端的程序的话，还是可以在VScode上面进行开发编译一条龙的，那么在VScode开发的代码又是如何在开发板上面得以运行的呢？ 编写的代码程序是如何在开发板上运行的？（真）先来看看C源程序如何编程可执行程序的： 参考博客如果想程序运行在本地PC中，那么在编译过程可以使用gcc进行本地编译，如果想程序运行在开发板中，那么在编译过程中可以使用arm-linux-gcc，也就是所谓的交叉编译，运行在开发板上的程序一般都是使用的是交叉编译得到的可执行文件 1. Ubantu虚拟机和开发板之间的关系在可带系统的开发板中，会烧入一个比桌面版更轻量的操作系统（也是一个Linux操作系统），这个操作系统支持的指令比桌面版操作系统少很多，但是也是能做到大部分操作系统那样的读写操作，这也是程序执行的操作，因此带操作系统的开发板可以像桌面版Linux操作系统一样通过指令（因为不带桌面所以轻量）来执行可执行程序 而Ubantu虚拟机或Linux服务器的作用是：在Linux环境上搭建交叉编译工具，如海思的交叉编译工具链：arm-himix200-linux，然后通过Linux环境编译出可以在arm架构上执行的可执行文件 2. 编译出来的可执行文件如何迁移到开发板主要是通过以下三种： 通过U盘或SD卡拷贝可执行文件，再将U盘或者SD卡接入开发板 通过NFS服务器连接Windows和开发板，但是文件系统不能做太大更改，Uboot和内核也不能更改 通过TFTP 我打算使用老师介绍的第二种方式搭建NFS服务器连接Windows和开发板","categories":[{"name":"Hispark开发学习笔记","slug":"Hispark开发学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Hispark%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"MIPI开发SDK","slug":"MIPI开发SDK","date":"2022-09-09T07:13:36.481Z","updated":"2022-09-09T07:13:36.481Z","comments":true,"path":"2022/09/09/mipi-kai-fa-sdk/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/mipi-kai-fa-sdk/","excerpt":"","text":"视频接收接口 SLVS-EC 接口由SONY公司定义，用于高帧率和高分辨率图像采集，它可以将高速串行的数据转化为 DC（Digital Camera）时序后传递给下一级模块VICAP（Video Capture ），SLVS-EC串行视频接口可以提供更高的传输带宽，更低的功耗，在组包方式上，数据的冗余度也更低。在应用中SLVS-EC接口提供了更加可靠和稳定的传输 MIPI Rx(含MIPI接口、LVDS接口和HISPI接口） 1. 重要概念 MIPIMIPI的全称是 Mobile Industry Processor Interface（移动行业处理器接口），本文描述的MIPI接口特指物理层使用D-PHY传输规范，协议层使用CSI-2的通信接口 LVDSLVDS的全称是 Low Voltage differential Signaling（低压差分信号）通过同步码区分消隐区和有效数据。 SLVS-ECSLVS-EC的全称是Scalable Low Voltage Signaling Embedded Clock，是与MIPI并列的接口，用于高帧率和高分辨率图像采集 Lane（应该是常说的路）用于连接发送端和接收端的一对高速差分线，即可以是时钟Lane，也可以是数据Lane，可以理解为在两个不同芯片之间完成信息运输的通道，是MIPI里面的基本信息传输单元。两块使用MIPI连接的芯片，中间使用差分信号对进行连接，收发端各有一个Lane模块，完成数据收发。 Link发送端和接收端之间的时钟Lane和至少一个数据Lane组成一个Link，本文中的link是一个软件概念，每一个link包括两个数据lane 同步码MIPI接口使用CSI-2里面的短包进行同步，LVDS使用同步码区分有效数据和消隐区。LVDS有两种同步方式： 使用SOF/EOF表示帧起始和结束，使用SOL/EOL表示行的起始和结束 使用SAV(invalid) EAV(invalid)表示消隐区的无效数据开始和结束，使用SAV(valid) EAV(valid)表示有效像素数据的开始和结束 每个同步码由4个字段组成，每个字段的位宽与像素数据位宽保持一致。前3个字段为固定基准码字，第4个字段由sensor厂家确定 2. 功能描述Hi3516DV300最大支持Lane（路）数为4路MIPI输入、4路LVDS输入，最大对接sensor数目为2 由于对接的每个sensor所需要的lane不尽相同，用户需要确定MIPI Rx的lane分布模式 开发文档讲的不清不楚的，搞不懂 3. API参考MIPI Rx中与对接sensor时序相关的API接口： API接口名 解释 HI_MIPI_SET_DEV_ATTR 设置MIPI、SLVS和并口设备属性 HI_MIPI_SET_HS_MODE 设置MIPI Rx的Lane分布 HI_MIPI_SET_PHY_CMVMODE 设置共模电压模式 HI_MIPI_RESET_SENSOR 复位 sensor HI_MIPI_UNRESET_SENSOR 撤销复位 sensor HI_MIPI_RESET_MIPI 复位MIPI Rx HI_MIPI_UNRESET_MIPI 撤销复位MIPI Rx HI_MIPI_RESET_SLVS 复位SLVS HI_MIPI_UNRESET_SLVS 撤销复位 SLVS HI_MIPI_ENABLE_MIPI_CLOCK 打开MIPI 设备的时钟 HI_MIPI_DISABLE_MIPI_CLOCK 关闭MIPI 设备的时钟 HI_MIPI_ENABLE_SLVS_CLOCK 打开SLVS 设备的时钟 HI_MIPI_DISABLE_SLVS_CLOCK 关闭SLVS 设备的时钟 HI_MIPI_ENABLE_SENSOR_CLOCK 打开SENSOR 的时钟 HI_MIPI_DISABLE_SENSOR_CLOCK 关闭SENSOR的时钟 HI_MIPI_CLEAR 清除设备相关的配置 MIPI Tx中对接显示屏、级联的相关API接口： API接口名 解释 HI_MIPI_TX_SET_DEV_CFG 设置MIPI Tx设备的属性 。 HI_MIPI_TX_SET_CMD 设置发送给MIPI Tx设备的命令数据 HI_MIPI_TX_ENABLE 使能MIPI Tx设备 HI_MIPI_TX_DISABLE 禁用MIPI Tx设备 HI_MIPI_TX_GET_CMD 用于从外围设备读取信息 4. 数据类型 combo_dev_t：MIPI Rx、 SLVS设备类型 lane_divide_mode_t：MIPI Rx 的Lane分布。 combo_dev_cfg_t：MIPI Tx设备属性 typedef struct { unsigned int devno; /* MIPI Tx设备号 */ short lane_id[LANE_MAX_NUM]; /* lane个数和模式配置，取决于lane_id中非-1值的个数，仅四种模式可选，且lane个数、lane号码、lane顺序固定 */ output_mode_t output_mode; /* MIPI Tx输出模式 */ video_mode_t video_mode; /* MIPI Tx视频模式 */ output_format_t output_format; /* MIPI Tx输出格式 */ sync_info_t sync_info; /* MIPI Tx设备的同步信息 */ unsigned int phy_data_rate; /* MIPI Tx输出速率 */ unsigned int pixel_clk; /* 像素时钟 */ } combo_dev_cfg_t; video_mode_t output_format_t：MIPI Tx 输出格式 typedef enum { OUT_FORMAT_RGB_16_BIT = 0x0, OUT_FORMAT_RGB_18_BIT = 0x1, OUT_FORMAT_RGB_24_BIT = 0x2, OUT_FORMAT_YUV420_8_BIT_NORMAL = 0x3, OUT_FORMAT_YUV420_8_BIT_LEGACY = 0x4, OUT_FORMAT_YUV422_8_BIT = 0x5, OUT_FORMAT_BUTT } output_format_t; sync_info_t：MIPI Tx设备同步信息 typedef struct { unsigned short vid_pkt_size;//接收包大小 unsigned short vid_hsa_pixels;//输入行同步脉冲区像素个数。 unsigned short vid_hbp_pixels;//输入后消隐区像素个数。 unsigned short vid_hline_pixels;//检测到的每行总像素个数。 unsigned short vid_vsa_lines;//检测到的帧同步脉冲行数。 unsigned short vid_vbp_lines;//帧同步脉冲后消隐区行数。 unsigned short vid_vfp_lines;//帧同步脉冲前消隐区行数。 unsigned short vid_active_lines;//VACTIVE行数。 unsigned short edpi_cmd_size;//写内存命令字节数。video mode时该值无效，command mode时该值设为hact。 } sync_info_t; output_mode_t：MIPI Tx输出模式 typedef enum { OUTPUT_MODE_CSI = 0x0, /* csi mode */ OUTPUT_MODE_DSI_VIDEO = 0x1, /* dsi video mode */ OUTPUT_MODE_DSI_CMD = 0x2, /* dsi command mode */ OUTPUT_MODE_BUTT } output_mode_t; cmd_info_t：发送给MIPI Tx设备的命令信息 typedef struct { unsigned int devno; /* MIPI Tx设备号 */ unsigned short data_type; /* 命令数据类型 */ unsigned short cmd_size; /*命令数据大小，范围：(0,200]，单条指令时，cmd置为NULL时、低八位对应数据1、高八位对应数据2 */ unsigned char *cmd; /*命令数据指针。单条指令时，可置为NULL；长指令时，可进行赋值 */ } cmd_info_t;","categories":[{"name":"Hispark开发学习笔记","slug":"Hispark开发学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Hispark%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"HiMPP开发SDK-视频输出","slug":"HiMPP开发SDK-视频输出","date":"2022-09-09T07:13:36.474Z","updated":"2022-09-09T07:13:36.475Z","comments":true,"path":"2022/09/09/himpp-kai-fa-sdk-shi-pin-shu-chu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/himpp-kai-fa-sdk-shi-pin-shu-chu/","excerpt":"","text":"HiMPP——视频输出（VO） VO（Video Output 视频输出）模块主动从内存相应位置读取视频和图形数据，并通过相应的显示设备输出视频和图形 Hi3516DV300支持的显示设备、视频层、图形层： 不支持高清显示设备DHD1，回写设备WD 由于Hi3516DV300不支持回写，回写相关知识就不看了 Hi3516DV300芯片规格： 输出最大时序为：1080p@60、输出接口：HDMI/BT.1120/BT.656/MIPI Tx/LCD、叠加拼接显示：VGS叠加 Hi3516DV300芯片视频层规格： 不支持动态绑定功能、缩放能力，一个通道一个画面，HI3516DV300只能有4个通道，支持CSC调节 Hi3516DV300视频输出接口时序 左边是对应的输出接口、右边是对应接口的最大输出时序 1. 基本概念 超高清、高清和标清显示设备SDK将高清和标清显示设备分别标示为 DHDx（Device High Definition x）和DSDx（Device Standard Definition x）其中，x 为索引号，从0开始取值，表示第几路高清标清显示设备 Hi3516DV300有1个高清显示设备DHD0。由于DHD0能够 支持到4K（3840x2160）的时序，因此DHD0也可以称之为超高清显示设备 视频层对于固定在每个显示设备上面对应的视频层，SDK也对应采取VHDx和VSDx来标示 通道SDK将通道归属于视频层管理，一个视频层上可显示多个视频每一个视频显示区域称为一个通道，视频被限制在通道内，通道被限制在视频层内。对于一个视频层，其上面的通道都是独立的。同时，不同的视频层上的通道也是独立的。对于通道的排号上面不存在跨层的连续。对于系统绑定，应该使用视频层号和通道号来进行绑定配置； 缩放和显示设备视频层内的通道不可重叠，超高清视频层的通道具有缩放能力。VI或VDEC的源图像经由缩放后，输出到VO的某一通道显示 如果输出给VO通道的图像超过VO的通道区域大小，则VO将会对图像进行缩放 视频层在显示视频图像上的策略为：对于支持缩放的视频层，则对视频进行缩放显示，对于不支持缩放的视频层，则对于视频进行裁剪显示 由于Hi3516DV300没有高清层，所以就不写高清层的缩放了 通道优先级超高清和高清显示设备软件上支持多个通道同时输出显示，按照优先级顺序对输出图像进行叠加，当各个通道的画面有重叠区域时，优先级高的图像显示在上层，如果各个通道优先级一致，则通道号越大的默认优先级越高 单画面直通模式单画面直通模式是指在SINGLE模式下，VO通道中的图像不经过VGS模块处理而直接显示出来，节省一次VGS搬移过程，并且VO无需申请私有内存，但是需要满足以下条件才会选择走直通模式 VO 通道使能，且只有一个通道显示 VO 没有显示OSD和COVER VO 没有使能边框 VO 没有使能抗闪 VO 没有电子放大 VO 没有开启镜像 VO 通道图像像素格式和设置的像素格式一致 VO 通道图像视频格式为LINEAR（包括LINEAR DISCRETE 格式） VO 通道图像大小 =通道大小=画布大小 如果不满足直通模式的条件，由于VO默认不分配内存，因此需要在使能视频层之前调用 HI_MPI_VO_SetDisplayBufLen 接口设置缓冲长度来确定分配内存，否则VO将不会输出视频显示 解压和压缩Hi3516DV300支持输入源图像是压缩数据（格式为段压缩，256Bytes为一段），VO会进行解压显示。解压功能是视频层 的功能，在MULTI模式下，前端送入VO各通道的数据的压缩模式必须保持一致 旋转VO支持对进入通道前的图像进行旋转操作。对通道设置旋转角度，旋转是作用于进入通道前的图像的。 输入和输出数据格式VO支持输入和输出指定格式的数据，如图所示： 输出是指回写数据到DDR，显然Hi3516DV300不支持回写的功能。表中PIXEL FORMAT：输入输出像素格式、VIDEO FORMAT：视频格式、COMPRESS MODE：压缩模式、DYNAMIC RANGE：视频动态范围 SINGLE模式 和MULTI模式SINGLE模式和MULTI模式是对支持多区域（为区别于软件上的通道概念，此处称为多区域）的视频层而言的，即硬件支持多区域。SINGLE 模式表示在硬件上配置一个显示区域，MULTI模式是在硬件上配置多个显示区域（大于等于1个区域） 注意：将多区域与通道区别开来，SINGLE模式和 MULTI 模式下都可以实现多通道显示，前者其所有通道被组织成一幅图像显示在一个区域内，后者其每个通道独立并独占一个显示区域。另外，一个视频层只能工作在其中一种模式下。 像素格式转换SINGLE模式非直通时支持像素格式转换，如果输入图像的像素格式和视频层的像素格式不相同，可调用VGS做像素格式转换 MULTI模式下不支持像素格式转换，输入图像的像素格式须和视频层像素格式相同 这里只是记录了一部分的功能，还有类似低功耗策略、HDR、图形层绑定、分辨率、局部放大等功能没有记下来 2. API参考 视频输出（VO）实现启用视频输出设备或通道、发送视频数据到输出通道等功能。该功能模块提供以下API，下面分别从设备、视频层、通道、回写、图形层等方面进行介绍 设备相关API API接口名 解释 HI_MPI_VO_Enable 启用视频输出设备 HI_MPI_VO_Disable 禁用视频输出设备 HI_MPI_VO_SetPubAttr 设置视频输出设备的公共属性 HI_MPI_VO_GetPubAttr 获取视频输出设备的公共属性 HI_MPI_VO_CloseFd 关闭所有视频输出设备的Fd HI_MPI_VO_SetDevFrameRate 设置设备用户时序下设备帧率 HI_MPI_VO_GetDevFrameRate 获取设备帧率 HI_MPI_VO_SetModParam 设置模块参数 HI_MPI_VO_GetModParam 获取模块参数 HI_MPI_VO_SetVtth 设置设备垂直时序中断门限 HI_MPI_VO_GetVtth 获取设备垂直时序中断门限 HI_MPI_VO_SetVtth2 设置设备垂直时序2中断门限 HI_MPI_VO_GetVtth2 获取设备垂直时序2中断门限 HI_MPI_VO_SetUserIntfSyncInfo 设置用户接口时序信息，用于配置时钟源、时钟大小和时钟分频比 视频层相关API API接口名 解释 HI_MPI_VO_EnableVideoLayer 使能视频层 HI_MPI_VO_DisableVideoLayer 禁止视频层 HI_MPI_VO_SetVideoLayerAttr 设置视频层属性 HI_MPI_VO_GetVideoLayerAttr 获取视频层属性 HI_MPI_VO_SetVideoLayerPriority 设置视频层优先级 HI_MPI_VO_GetVideoLayerPriority 获取视频层优先级 HI_MPI_VO_SetVideoLayerPartitionMode 设置视频层的分割模式 HI_MPI_VO_GetVideoLayerPartitionMode 获取视频层的分割模式 HI_MPI_VO_SetVideoLayerCSC 设置视频层CSC HI_MPI_VO_GetVideoLayerCSC 获取视频层CSC HI_MPI_VO_SetVideoLayerCrop 设置视频层CROP功能属性 HI_MPI_VO_GetVideoLayerCrop 获取视频层CROP功能属性 HI_MPI_VO_BatchBegin 设置视频层上的通道的属性等批处理开始 HI_MPI_VO_BatchEnd 设置视频层上的通道的属性等批处理结束 HI_MPI_VO_SetVideoLayerBoundary 设置视频层上区域边框的宽度和颜色 HI_MPI_VO_GetVideoLayerBoundary 获取视频层上区域边框的宽度和颜色 HI_MPI_VO_GetScreenFrame 获取视频层上的输出图像帧 HI_MPI_VO_ReleaseScreenFrame 释放视频层上的输出图像帧 HI_MPI_VO_SetDisplayBufLen 设置视频层上的显示缓存长度 HI_MPI_VO_GetDisplayBufLen 获取视频层上的显示缓存长度 HI_MPI_VO_SetVideoLayerParam 设置视频层参数 HI_MPI_VO_GetVideoLayerParam 获取视频层参数 HI_MPI_VO_BindVideoLayer 绑定视频层到某个设备 HI_MPI_VO_UnBindVideoLayer 解绑定视频层 HI_MPI_VO_SetVideoLayerDecompress 设置视频层是否开启解压缩功能，仅MULTI模式下有效 HI_MPI_VO_GetVideoLayerDecompress 获取视频层是否开启解压缩功能 通道相关API API接口名 解释 HI_MPI_VO_EnableChn 启用指定的视频输出通道 HI_MPI_VO_DisableChn 禁用指定的视频输出通道 HI_MPI_VO_SetChnAttr 设置指定视频输出通道的属性 HI_MPI_VO_GetChnAttr 获取指定视频输出通道的属性 HI_MPI_VO_SetChnParam 设置通道参数幅型比参数 HI_MPI_VO_GetChnParam 获取通道参数（幅型比参数） HI_MPI_VO_SetChnDisplayPosition 设置指定视频输出通道的显示位置 HI_MPI_VO_GetChnDisplayPosition 获取指定视频输出通道的显示位置 HI_MPI_VO_GetChnFrame 获取输出通道图像数据 HI_MPI_VO_ReleaseChnFrame 释放输出通道图像数据 HI_MPI_VO_SendFrame 将视频图像送入指定视频输出通道显示 HI_MPI_VO_SetChnFrameRate 设置指定视频输出通道的显示帧率 HI_MPI_VO_GetChnFrameRate 获取指定视频输出通道的显示帧率 HI_MPI_VO_PauseChn 暂停指定的视频输出通道 HI_MPI_VO_ResumeChn 恢复指定的视频输出通道 HI_MPI_VO_StepChn 单帧播放指定的视频输出通道 HI_MPI_VO_RefreshChn 刷新指定的视频输出通道 HI_MPI_VO_ShowChn 设置显示通道 HI_MPI_VO_HideChn 设置隐藏通道 HI _MPI_VO_SetZoomInWindow 设置视频输出局部放大窗口 HI_MPI_VO_GetZoomInWindow 获取视频输出局部放大窗口参数 HI_MPI_VO_GetChnPTS 获取指定视频输出通道当前显示图像的时间戳 HI_MPI_VO_QueryChnStatus 查询视频输出通道状态 HI_MPI_VO_ClearChnBuf 清空指定输出通道的缓存buffer数据 HI_MPI_VO_SetChnBorder 设置指定输出通道的边框属性 HI_MPI_VO_GetChnBorder 获取指定输出通道的边框属性 HI_MPI_VO_SetChnRotation 设置视频输出通道旋转角度 HI_MPI_VO _GetChnRotation 获取视频输出通道旋转角度 更多的API以及数据类型还需要查看开发文档 3. 数据类型 VO_PUB_ATTR_S：定义视频输出设备属性结构体 typedef struct hiVO_PUB_ATTR_S { HI_U32 u32BgColor; /* 设备背景色 RGB 表示 */ VO_INTF_TYPE_E enIntfType; /* enIntfType; /* Vo 接口类型 */ VO_INTF_SYNC_E enIntfSync; /* enIntfSync; /* Vo 接口时序类型 */ VO_SYNC_INFO_S stSyncInfo; /* /* Vo 接口时序信息 */ } VO_PUB_ATTR_S; VO_INTF_SYNC_E：定义时序类型枚举 typedef enum hiVO_INTF_SYNC_E { VO_OUTPUT_PAL = 0, /* PAL standard */ VO_OUTPUT_NTSC, /* NTSC standard */ VO_OUTPUT_1080P24, /* 1920 x 1080 at 24 Hz. */ VO_OUTPUT_1080P25, /* 1920 x 1080 at 25 Hz. */ VO_OUTPUT_1080P30, /* 1920 x 1080 at 30 Hz. */ VO_OUTPUT_720P50, /* 1280 x 720 at 50 Hz. */ VO_OUTPUT_720P60, /* 1280 x 720 at 60 Hz. */ VO_OUTPUT_1080I50, /* 1920 x 1080 at 50 Hz, interlace. */ VO_OUTPUT_1080I60, /* 1920 x 1080 at 60 Hz, interlace. */ VO_OUTPUT_1080P50, /* 1920 x 1080 at 50 Hz. */ VO_OUTPUT_1080P60, /* 1920 x 1080 at 60 Hz. */ VO_OUTPUT_576P50, /* 720 x 576 at 50 Hz. */ VO_OUTPUT_480P60, /* 720 x 480 at 60 Hz. */ VO_OUTPUT_800x600_60, /* VESA 800 x 600 at 60 Hz (non-interlaced) */ VO_OUTPUT_1024x768_60, /* VESA 1024 x 768 at 60 Hz (non-interlaced) */ VO_OUTPUT_1280x1024_60, /* VESA 1280 x 1024 at 60 Hz (non-interlaced) */ VO_OUTPUT_1366x768_60, /* VESA 1366 x 768 at 60 Hz (non-interlaced) */ VO_OUTPUT_1440x900_60, /* VESA 1440 x 900 at 60 Hz (non-interlaced) CVT Compliant */ VO_OUTPUT_1280x800_60, /* 1280*800@60Hz VGA@60Hz */ VO_OUTPUT_1600x1200_60, /* VESA 1600 x 1200 at 60 Hz (non-interlaced) */ VO_OUTPUT_1680x1050_60, /* VESA 1680 x 1050 at 60 Hz (non-interlaced) */ VO_OUTPUT_1920x1200_60, /* VESA 1920 x 1600 at 60 Hz (non-interlaced) CVT (Reduced Blanking) */ VO_OUTPUT_640x480_60, /* VESA 640 x 480 at 60 Hz (non-interlaced) CVT */ VO_OUTPUT_960H_PAL, /* ITU-R BT.1302 960 x 576 at 50 Hz (interlaced) */ VO_OUTPUT_960H_NTSC, /* ITU-R BT.1302 960 x 480 at 60 Hz (interlaced) */ VO_OUTPUT_1920x2160_30, /* 1920x2160_30 */ VO_OUTPUT_2560x1440_30, /* 2560x1440_30 */ VO_OUTPUT_2560x1440_60, /* 2560x1440_60 */ VO_OUTPUT_2560x1600_60, /* 2560x1600_60 */ VO_OUTPUT_3840x2160_24, /* 3840x2160_24 */ VO_OUTPUT_3840x2160_25, /* 3840x2160_25 */ VO_OUTPUT_3840x2160_30, /* 3840x2160_30 */ VO_OUTPUT_3840x2160_50, /* 3840x2160_50 */ VO_OUTPUT_3840x2160_60, /* 3840x2160_60 */ VO_OUTPUT_4096x2160_24, /* 4096x2160_24 */ VO_OUTPUT_4096x2160_25, /* 4096x2160_25 */ VO_OUTPUT_4096x2160_30, /* 4096x2160_30 */ VO_OUTPUT_4096x2160_50, /* 4096x2160_50 */ VO_OUTPUT_4096x2160_60, /* 4096x2160_60 */ VO_OUTPUT_320x240_60, /* For ota5182 at 60 Hz (8bit) */ VO_OUTPUT_320x240_50, /* For ili9342 at 50 Hz (6bit) */ VO_OUTPUT_240x320_50, /* Hi3559AV100: For ili9341 at 50 Hz (6bit) */ /* Hi3556AV100/Hi3519AV100: For st7789 at 50Hz(6bit) */ VO_OUTPUT_240x320_60, /* For ili9341 at 60 Hz (16bit) */ VO_OUTPUT_800x600_50, /* For LCD at 50 Hz (24bit) */ VO_OUTPUT_720x1280_60, /* For MIPI DSI Tx 720 x1280 at 60 Hz */ VO_OUTPUT_1080x1920_60, /* For MIPI DSI Tx 1080x1920 at 60 Hz */ VO_OUTPUT_7680x4320_30, /* For HDMI2.1 at 30 Hz */ VO_OUTPUT_USER, /* User timing. */ VO_OUTPUT_BUTT } VO_INTF_SYNC_E; VO_SYNC_INFO_S：定义时序信息结构体 typedef struct hiVO_SYNC_INFO_S { HI_BOOL bSynm; /* 同步模式，LCD接口选择1，表示信号同步 */ HI_BOOL bIop; /* 0为隔行，1为逐行，LCD接口一般配置为1。 */ HI_U8 u8Intfb; /* 无效参数，可以忽略。 */ HI_U16 u16Vact; /* 垂直有效区，隔行输出时表示顶场垂直有效区。单位：行。 */ HI_U16 u16Vbb; /* 垂直消隐后肩，隔行输出时表示顶场垂直消隐后肩。单位：行。 */ HI_U16 u16Vfb; /* 垂直消隐前肩，隔行输出时表示顶场垂直消隐前肩。单位：行。 */ HI_U16 u16Hact; /* 水平有效区。单位：像素。 */ HI_U16 u16Hbb; /* 水平消隐后肩。单位：像素。 */ HI_U16 u16Hfb; /* 水平消隐前肩。单位：像素。 */ HI_U16 u16Hmid; /* 底场垂直同步有效像素值。 */ HI_U16 u16Bvact; /* 底场垂直有效区，隔行时有效。单位：行。 */ HI_U16 u16Bvbb; /* 底场垂直消隐后肩，隔行时有效。单位：行。 */ HI_U16 u16Bvfb; /* 底场垂直消隐前肩，隔行时有效。单位：行。 */ HI_U16 u16Hpw; /* 水平同步信号的宽度。单位：像素。 */ HI_U16 u16Vpw; /* 垂直同步信号的宽度。单位：行。 */ HI_BOOL bIdv; /* 数据有效信号的极性。配置0 为高有效，配置1 为低有效。 */ HI_BOOL bIhs; /* 水平有效信号的极性，配置0 为高有效，配置1 为低有效。 */ HI_BOOL bIvs; /* 垂直有效信号的极性，配置0 为高有效，配置1 为低有效。 */ } VO_SYNC_INFO_S; 消隐的概念涉及数字图像信号处理，参考资料 时序像素时钟计算公式： 1.内部只做以下参数检查：u16Hact、u16Hbb、u16Hfb、u16Vbb、u16Vfb、u16Hpw、u16Vpw要求不能为0，u16Vact要求大于等于 100。在bIop为HI_FALSE时，要求u16Bvact、u16Bvbb和u16Bvfb不能为0。用户须自行保证时序配置的正确性 2.配置消隐区时，水平消隐后肩u16Hbb 已经包含水平同步信号的宽度u16Hpw；垂直消隐后肩u16Vbb 已经包含垂直同步信号高度u16Vpw（隔行时，底场垂直消隐后肩u16Bvbb 已经包含u16Vpw） VO_USER_INTFSYNC_INFO_S：用户接口时序信息，包括配置时钟源类型、时钟大小、时钟分频比和时钟相位 typedef struct hiVO_USER_INTFSYNC_INFO_S { VO_USER_INTFSYNC_ATTR_S stUserIntfSyncAttr;//用户接口时序属性：时钟源类型、时钟大小配置信息。 HI_U32 u32PreDiv;//设备前置分频，数值范围[1, 32]。 HI_U32 u32DevDiv;//设备的时钟分频比，数值范围[1,4]。 HI_BOOL bClkReverse;//时钟相位是否反向。HI_TRUE：时钟反向；HI_FALSE：时钟不反向。 } VO_USER_INTFSYNC_INFO_S; VO_USER_INTFSYNC_ATTR_S：用户接口时序属性，包括配置时钟源类型、时钟大小（时钟源输出的大小配置信息） typedef struct hiVO_USER_INTFSYNC_ATTR_S { VO_CLK_SOURCE_E enClkSource; union { VO_USER_INTFSYNC_PLL_S stUserSyncPll; HI_U32 u32LcdMClkDiv; }; } VO_USER_INTFSYNC_ATTR_S; VO_USER_INTFSYNC_PLL_S：用户接口时序PLL信息，用于配置PLL typedef struct hiVO_USER_INTFSYNC_PLL_S { HI_U32 u32Fbdiv;//PLL整数倍频系数，数值范围：[0,0xfff]。 HI_U32 u32Frac;//PLL小数分频系数，数值范围：[0,0xffffff]。 HI_U32 u32Refdiv;//PLL参考时钟分频系数，数值范围：(0,0x3f]。 HI_U32 u32Postdiv1;//PLL第一级输出分频系数，数值范围：(0,0x7]。 HI_U32 u32Postdiv2;//PLL第二级输出分频系数，数值范围：(0,0x7]。 } VO_USER_INTFSYNC_PLL_S; VO_CLK_SOURCE_E：VO设备的时钟源类型 typedef enum hiVO_CLK_SOURCE_E { VO_CLK_SOURCE_PLL,//PLL类型时钟源 VO_CLK_SOURCE_LCDMCLK,//LCD分频器时钟源。 VO_CLK_SOURCE_BUTT } VO_CLK_SOURCE_E; VO_INTF_TYPE_E：定义接口类型 #define VO_INTF_CVBS (0x01L &lt;&lt; 0) #define VO_INTF_YPBPR (0x01L &lt;&lt; 1) #define VO_INTF_VGA (0x01L &lt;&lt; 2) #define VO_INTF_BT656 (0x01L &lt;&lt; 3) #define VO_INTF_BT1120 (0x01L &lt;&lt; 4) #define VO_INTF_HDMI (0x01L &lt;&lt; 5) #define VO_INTF_LCD (0x01L &lt;&lt; 6) #define VO_INTF_BT656_H (0x01L &lt;&lt; 7) #define VO_INTF_BT656_L (0x01L &lt;&lt; 8) #define VO_INTF_LCD_6BIT (0x01L &lt;&lt; 9) #define VO_INTF_LCD_8BIT (0x01L &lt;&lt; 10) #define VO_INTF_LCD_16BIT (0x01L &lt;&lt; 11) #define VO_INTF_LCD_18BIT (0x01L &lt;&lt; 12) #define VO_INTF_LCD_24BIT (0x01L &lt;&lt; 13) #define VO_INTF_MIPI (0x01L &lt;&lt; 14) #define VO_INTF_MIPI_SLAVE (0x01L &lt;&lt; 15) typedef HI_U32 VO_INTF_TYPE_E; VO_VIDEO_LAYER_ATTR_S：定义视频层属性结构体，在视频层属性中存在三个概念，即设备分辨率、显示分辨率和图像分辨率 图像分辨率指放置各个通道图像的画布大小 显示分辨率是把图像分辨率中描述的画布经过VO放大后的显示区域 设备分辨率与设备时序一致，即如果时序为1920 x 1080，那设备分辨率就为1920 x 1080 视频层属性的相关概念 视频层的内存使用分为通道聚集和非聚集两种方式: 1. 聚集方式：决定内存分配大小的因素：实际显示通道的分辨率的总和；不支持视频层的放大功能；仅适用于MULTI模式；聚集方式开启后，对于MULTI模式下的视频层，可以调用通道显示位置接口（HI_MPI_VO_SetChnDisplayPosition）来合理布局通道的显示位置。 2. 非聚集方式：决定内存分配大小的因素：显示图像的起始坐标（0，0）与最右下角的坐标所决定的区域大小和缩放比例（图像分辨率与显示分辨率的比）；支持视频层的放大功能。通过视频放大功能，在相同显示分辨率情况下，依据适当的比例把图像分辨率调小，那么需要分配的内存也相应减少，这种情况下可以做到节省内存，但是会因放大导致图像质量下降；在拼接好图像画面后，通道画面的显示位置不可以调整 typedef struct hiVO_VIDEO_LAYER_ATTR_S { RECT_S stDispRect; /* 显示分辨率大小 */ SIZE_S stImageSize; /* 视频层画布大小 */ HI_U32 u32DispFrmRt; /* 显示帧率 */ PIXEL_FORMAT_E enPixFormat; /* 视频层使用的像素格式 */ HI_BOOL bDoubleFrame; /* 视频层是否开启倍帧 */ HI_BOOL bClusterMode; /* 视频层上的通道是否采用聚集的方式使用内存 */ DYNAMIC_RANGE_E enDstDynamicRange; /* 输出动态范围类型 */ } VO_VIDEO_LAYER_ATTR_S; VO_PART_MODE_E：定义视频层分割模式枚举类型 typedef enum hiVO_PART_MODE_E { VO_PART_MODE_SINGLE = 0, /* 视频层按照单区域配置给硬件显示 */ VO_PART_MODE_MULTI = 1, /* 视频层按照多区域配置给硬件显示 */ VO_PART_MODE_BUTT } VO_PART_MODE_E; VO_CSC_S：定义图像输出效果结构体 typedef struct hiVO_CSC_S { VO_CSC_MATRIX_E enCscMatrix; /* CSC矩阵选择 */ HI_U32 u32Luma; /* 亮度值[0, 100] */ HI_U32 u32Contrast; /* 对比度值 */ HI_U32 u32Hue; /* 色调值 */ HI_U32 u32Satuature; /* 饱和度值 */ } VO_CSC_S; VO_CSC_MATRIX_E：定义CSC转换矩阵 typedef enum hiVO_CSC_MATRIX_E { VO_CSC_MATRIX_IDENTITY = 0, /* 单位转换矩阵 */ VO_CSC_MATRIX_BT601_TO_BT709, /* BT.601 LIMIT到BT.709 LIMIT色彩空间的CSC矩阵 */ VO_CSC_MATRIX_BT709_TO_BT601, /* BT.709 LIMIT到BT.601 LIMIT色彩空间的CSC矩阵 */ VO_CSC_MATRIX_BT601_TO_RGB_PC, /* BT.601 FULL到RGB色彩空间的CSC矩阵 */ VO_CSC_MATRIX_BT709_TO_RGB_PC, /* BT.709 FULL到RGB色彩空间的CSC矩阵 */ VO_CSC_MATRIX_RGB_TO_BT601_PC, /* RGB到BT.601 FULL色彩空间的CSC矩阵 */ VO_CSC_MATRIX_RGB_TO_BT709_PC, /* RGB到BT.709 FULL色彩空间的CSC矩阵 */ VO_CSC_MATRIX_RGB_TO_BT2020_PC, /* RGB到BT.2020色彩空间的CSC矩阵 */ VO_CSC_MATRIX_BT2020_TO_RGB_PC, /* BT.2020到RGB色彩空间的CSC矩阵 */ VO_CSC_MATRIX_RGB_TO_BT601_TV, /* RGB到BT.601 LIMIT色彩空间的CSC矩阵 */ VO_CSC_MATRIX_RGB_TO_BT709_TV, /* RGB到BT.709 LIMIT色彩空间的CSC矩阵 */ VO_CSC_MATRIX_BUTT } VO_CSC_MATRIX_E;","categories":[{"name":"Hispark开发学习笔记","slug":"Hispark开发学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Hispark%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"HiMPP开发SDK-视频输入","slug":"HiMPP开发SDK-视频输入","date":"2022-09-09T07:13:36.466Z","updated":"2022-09-09T07:13:36.466Z","comments":true,"path":"2022/09/09/himpp-kai-fa-sdk-shi-pin-shu-ru/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/himpp-kai-fa-sdk-shi-pin-shu-ru/","excerpt":"","text":"HiMPP——视频输入（VI） 视频输入VI模块实现的功能：通过MIPI Rx(含MIPI接口、LVDS接口和HISPI接口），SLVS-EC，BT.1120，BT.656，BT.601，DC等接口接收视频数据。VI将接收到的数据存入到指定的内存区域（视频缓存池），在此过程中，VI可以对接收到的原始视频图像数据进行处理实现视频数据的采集 1. 概念 视频输入设备视频输入设备支持若干种时序输入，负责对时序进行解析。 视频输入物理 PIPE视频输入PIPE绑定在设备后端，负责设备解析后的数据再处理 视频输入虚拟PIPE视频输入虚拟PIPE不绑定设备，负责其他模块或用户发送过来的数据再处理 视频物理通道物理通道负责将最终处理后的数据输出到DDR，在真正将数据输出到DDR之前，它可以实现裁剪等功能 掩码掩码用于指示VI设备的视频数据来源 镜头畸变校正（LDC）镜头畸变校正，一些低端镜头容易产生图像畸变，需要根据畸变程度对其图像进行校正 DISDIS 模块通过比较当前图像与前两帧图像采用不同自由度的防抖算法计算出当前图像在各个轴方向上的抖动偏移向量，然后根据抖动偏移向量对当前图像进行校正，从而起到防抖的效果 BASBayer scaling，即Bayer 域缩放。 低延时低延时指图像写出指定的行数到DDR后，VI上报一个中断，把图像发给后端模块处理，可以减少延时，且硬件会有机制保证图像是先写后读，不会出现读图像错误 提前上报中断提前上报中断指图像写出指定的行数到DDR后，VI上报一个中断，把图像发给后端模块处理，可以减少延时，但没有和低延时一样的硬件机制保证后端模块读图像不会出错 2. 功能描述 VI从软件上划分了输入设备（DEV）输入 PIPE（图示为物理 PIPE，虚拟PIPE只包含ISP_BE） 、物理通道（PHY_CHN）、扩展通道（EXT_CHN）四个层级 视频输入设备（DEV）所有VI设备都是相互独立的，负责对MIPI接口的时序进行解析 视频输入PIPE（PIPE）VI的PIPE包含了ISP的相关处理功能，主要是对图像数据进行流水线处理，输出YUV图像格式给通道，ISP_FE主要负责从DEV接收BAYER格式的图像数据，ISP_BE主要负责执行图像处理ISP 视频物理通道（PHY_CHN）Hi3516DV300 物理通道支持的典型分辨率如2688 x1944@20fps 、2688x1536 @30fps等 视频扩展通道（EXT_CHN）扩展通道是物理通道的扩展，扩展通道具备缩放、裁剪、鱼眼矫正功能，它通过绑定物理通道将物理通道输出作为自己的输入，然后输出用户设置的目标图像 管道和通道的区别：管道（pipe）相当于图像数据的前加工厂，经过加工后的，再传给通道（channel），至于为什么还有再设置一个通道来传输（channel）我就不太能理解了 Hi3516DV300的VI通道功能框图： 绑定关系： MIPI和DEV的绑定关系Hi3516DV300的Dev与MIPI绑定关系是固定的不能动态修改绑定关系 DEV和PIPE的绑定关系每个PIPE都可以与任意Dev绑定但不能动态修改绑定关系，每一个PIPE对应着一个或2个的PHY_CHN（物理通道） 线性模式（非WDR模式）的一条通路应该是一个物理PIPE绑定一个Dev，WDR模式下需要多个物理PIPE绑定一个Dev，例如2合1WDR，我们需要2个物理PIPE绑定到一个Dev。且在WDR模式下只有绑定到Dev的 第1条物理PIPE的通道有数据输出，其他绑定的物理PIPE的通道是没有图像数据输出 从模式： 暂时不了解，看不懂有什么功能 掩码配置： 我认为应该配置输入视频的输入场景的，暂时不看，用到再回来补充 可以使用cat /proc/umap/vi查看vi的相关属性配置 3. API参考 这部分API提供了视频输入（VI）实现启用视频输入设备、视频输入PIPE创建，视频输入通道配置、Dev绑定MIPI设备，PIPE绑定Dev等功能的API接口，同样我只列出一些我觉得能用得上的，具体API还需要查看开发文档，接口调用流程图： API接口名 解释 HI_MPI_VI_SetDevAttr 设置 VI 设备属性 HI_MPI_VI_GetDevAttr 获取 VI 设备属性 HI_MPI_VI_EnableDev 启用 VI 设备 HI_MPI_VI_DisableDev 禁用 VI 设备 HI_MPI_VI_SetMipiBindDev 设置 VI 设备与 MIPI 设备的绑定关系 HI_MPI_VI_GetMipiBindDev 获取 VI 设备所绑定的 MIPI 设备 HI_MPI_VI_SetDevBindPipe 设置 VI 设备与 物理 PIPE 的绑定关系 HI_MPI_VI_GetDevBindPipe 获取 VI 设备所绑定的物理 PIPE HI_MPI_VI_GetPipeCmpParam 获取 VI 物理 PIPE 的 RAW 压缩参数 HI_MPI_VI_CreatePipe 创建一个 VI PIPE HI_MPI_VI_DestroyPipe 销毁一个 VI PIPE HI_MPI_VI_SetPipeAttr 设置 VI PIPE 的属性 HI_MPI_VI_GetPipeAttr 获取 VI PIPE 的属性 HI_MPI_VI_StartPipe 启用 VI PIPE HI_MPI_VI_StopPipe 禁用 VI PIPE HI_MPI_VI_SetUserPic 设置用户图片，作为无视频信号时的插入图片 HI_MPI_VI_EnableUserPic 启用 VI PIPE 插入用户图片 HI_MPI_VI_DisableUserPic 禁用 VI PIPE 插入用户图片 HI_MPI_VI_SetPipePreCrop 设置 VI 物理 PIPE 输入端的裁剪功能属性 HI_MPI_VI_GetPipePreCrop 获取 VI 物理 PIPE 输入端的裁剪功能属性 HI_MPI_VI_SetPipePostCrop 设置 VI 物理 PIPE 输出端的裁剪功能属性 HI_MPI_VI_GetPipePostCrop 获取 VI 物理 PIPE 输出端的裁剪功能属性。 HI_MPI_VI_SetPipeDumpAttr 设置 VI 物理 PIPE dump属性 HI_MPI_VI_GetPipeDumpAttr 获取 VI 物理 PIPE dump属性 HI_MPI_VI_SetPipeFrameSource 设置 VI PIPE 数据的来源 HI_MPI_VI_GetPipeFrameSource 获取 VI PIPE 数据的来源 HI_MPI_VI_GetPipeFrame 获取 VI 物理 PIPE 的数据 HI_MPI_VI_ReleasePipeFrame 释放 VI PIPE 的数据 HI_MPI_VI_SendPipeYUV 通过 VI PIPE 发送 YUV 数据 HI_MPI_VI_SendPipeRaw 通过 VI PIPE 发送 RAW 数据 HI_MPI_VI_QueryPipeStatus 查看 VI PIPE 状态 HI_MPI_VI_EnablePipeInterrupt 启动 VI 物理 PIPE 中断 HI_MPI_VI_DisablePipeInterrupt 禁用 VI 物理 PIPE 中断 HI_MPI_VI_PipeAttachVbPool 将 VI 的 PIPE绑定到某个视频缓存 VB 池中 HI_MPI_VI_PipeDetachVbPool 将 VI 的 PIPE 从某个视频缓存 VB 池中解绑定 HI_MPI_VI_ChnAttachVbPool 将 VI PIPE 的通道绑定到某个视频缓存 VB 池中 HI_MPI_VI_ChnDetachVbPool 将 VI PIPE 的 通道从某个视频缓存 VB 池中解绑定 HI_MPI_VI_SetChnAttr 设置 VI 通道属性 HI_MPI_VI_GetChnAttr 获取 VI 通道属性 HI_MPI_VI_EnableChn 启用 VI 通道 HI_MPI_VI_DisableChn 禁用 VI 通道 HI_MPI_VI_SetChnCrop 设置 VI 通道裁剪功能属性 HI_MPI_VI_GetChnCrop 获取 VI 通道裁剪功能属性 HI_MPI_VI_SetChnRotation 设置 VI 图像旋转属性 HI_MPI_VI_GetChnRotation 获取 VI 图像旋转属性 HI_MPI_VI_SetChnRotationEx 设置 VI 的任意角度旋转属性 HI_MPI_VI_GetChnRotationEx 获取 VI 的任意角度旋转属性 HI_MPI_VI_SetChnEarlyInterrupt 设置 VI 通道提前上报中断属性 HI_MPI_VI_GetChnEarlyInterrupt 获取 VI 通道提前上报中断属性 HI_MPI_VI_SetPipeFrameInterruptAttr 设置 VI PIPE 上报中断属性 HI_MPI_VI_GetPipeFrameInterruptAttr 获取 VI PIPE 上报中断属性 HI_MPI_VI_GetChnFrame 从 VI 通道获取采集的图像 HI_MPI_VI_ReleaseChnFrame 释放一帧从 VI 通道获取的图像 HI_MPI_VI_QueryChnStatus 查询 VI 通道的状态 上面这些是我认为的能用得上的，都是一些比较低阶功能的API接口，还有一些高阶的API接口没有记下来，需要使用的话需要查阅相关的开发文档，即使记下这些，也只是为了更快查询罢了，使用的话也需要查询相关开发文档 4. 数据类型 VI_DEV_BIND_PIPE_S：定义 VI DEV 与 PIPE 的绑定关系 typedef struct hiVI_DEV_BIND_PIPE_S HI_U32 u32Num;//该VI Dev所绑定的PIPE数目，取值范围[1, VI_MAX_PIPE_NUM]。 VI_PIPE PipeId[VI_MAX_PIPE_NUM];//该VI Dev绑定的PIPE号。 }VI_DEV_BIND_PIPE_S; 数据类型实在是太多了，用到再去查吧，只能一点一点记了","categories":[{"name":"Hispark开发学习笔记","slug":"Hispark开发学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Hispark%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"HiMPP开发SDK-视频处理子系统","slug":"HiMPP开发SDK-视频处理子系统","date":"2022-09-09T07:13:36.459Z","updated":"2022-09-09T07:13:36.459Z","comments":true,"path":"2022/09/09/himpp-kai-fa-sdk-shi-pin-chu-li-zi-xi-tong/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/himpp-kai-fa-sdk-shi-pin-chu-li-zi-xi-tong/","excerpt":"","text":"HiMPP——视频处理子系统（VPSS） VPSS（Video Process Sub System）是视频处理子系统，支持的具体图像处理功能包括 FRC（Frame Rate Control）、 CROP 、 Sharpen 、 3DNR 、 Scale 、 像素格式转换 、LDC 、 Spread 、 固定角度旋转 、 任意角度旋转 、鱼眼校正、 Cover/Coverex 、Overlayex 、 Mosaic 、 Mirror/Flip 、 HDR 、 Aspect Ratio 、 压缩解压等 1. 基本概念 GROUPVPSS对用户提供组（GROUP）的概念，各 GROUP 分时复用 VPSS 硬件，硬件依次处理各个组提交的任务 用户可通过 MPI 接口对 GROUP 进行管理。 每个 GROUP 仅可与一个输入源绑定 。 GROUP 的物理通道有两种工作模式： AUTO 和 USER ，两种模式间可动态切换。 AUTO模式下各通道仅可与一个接收者绑定 ，主要用于预览和回放场景下做播放控制 。 USER 模式下各通道可与多个接收者绑定。USER 模式主要用于对同一通道图像进行多路编码的场景，此模式下播放控制不生效，因此回放场景下不建议使用 USER 模式 。 VPSS只有工作在离线模式下才支持 AUTO 模式。 CHANNELVPSS组的通道。通道分为 2 种：物理通道和扩展通道。 VPSS硬件提供多个物理通道，每个通道具有缩放、裁剪等功能。扩展通道具备裁剪、缩放功能，它通过绑定物理通道，将物理通道输出作为自己的输入，把图像裁剪、缩放成用户设置的目标分辨率输出。 PIPEVPSS组的管道，取值只能为 0 FRC帧率控制，分为 2 种： 组帧率控制和通道帧率控制 组帧率控制：用于控制各 GROUP 对输入图像的接收 通道帧率控制：用于控制各个物理通道和扩展通道图像的处理 CROP裁剪，分为 3 种：组裁剪、物理通道裁剪以及扩展通道裁剪 组裁剪， VPSS 对输入图像进行裁剪 物理通道裁剪， VPSS 对各个物理通道的输出图像进行裁剪 扩展通道裁剪， VPSS 调用 VGS 对扩展通道的输出图像进行裁剪 Sharpen锐化，对图像进行锐化处理。仅 Hi3559AV100、Hi3519AV100 支持 。 像素格式转换支持输入输出图像的数据格式转换。 Scale缩放，对图像进行缩小放大。物理通道水平、垂直最大支持 15 倍缩小，最大支持16倍放大；扩展通道水平、垂直最大支持30倍缩小，最大支持16倍放大，Hi3516DV300通道 0 只支持放大，其它通道只支持缩小。 Mirror/FlipMirror即水平镜像 Flip 即上下翻转。 可使用 Mirror+Flip 实现180旋转。 Mosaic马赛克，对VPSS的输出图像填充马赛克块 Cover视频遮挡区域，对 VPSS 的输出图像填充纯色块 3DNR去噪。通过参数配置，把图像中的高斯噪声去除，使得图像变得平滑，有助于降低编码码率 固定角度旋转支持 0 度、 90 度、180 度以及 270 度固定角度的旋转功能 任意角度旋转支持任意角度的旋转功能 LDC对输入图像做镜头畸变校正 Spread对输入图像做展宽处理 鱼眼校正 HDR 输出VPSS 支持的 HDR 类型包括 HDR10 和 HLG，Hi3516DV300只 支持 SDR 压缩所有芯片 VPSS 均支持 linear 格式的 SEG 压缩。 解压VPSS 均支持 linear 格式 SEG 解压 Aspect Ratio幅形比，指定输出画面相对于输入画面的宽高纵横比。幅形比参数在通道属性中设置。只有在 VPSS 通道设置为 USER 模式时才生效，AUTO模式下幅形比参数由VO设置，设定为 ASPECT_RATIO_ MANUAL 模式时，用户手动设置图像的起始坐标和宽高， VPSS 会根据用户的设置来输出图像并添加黑边。设定为 ASPECT_RATIO_AUTO 模式时， VPSS 会保持输出画面的宽高比和输入宽高比一致，自动在画面上下或者左右加上黑边。 工作模式 VI_OFFLINE_VPSS_OFFLINE 在此模式下，Hi3516DV300通道 0 压缩和 mirror功能不能同时开启，通道 0 不支持幅形比 、不支持缩放。 VI_ONLINE_VPSS_OFFLINE VI_ONLINE_VPSS_ONLINE VI_OFFLINE_VPSS_ONLINE 在此模式下，通道 0 压缩、幅形比和 mirror 不能同时开启，支持两两组合。 vpss_en[VPSS_IP_NUM]VPSS 硬件开关，用户可以在加载VPSS ko 时设置模块参数（vpss_en）来设置VPSS IP使能。只支持开启或关闭VPSS1，VPSS0 和VPSS1 默认打开。Hi3516DV300不支持这个参数 分块Hi3516DV300输入图像宽度超过2048时分块，分块处理时如果 通道输出宽度小于 512 则不支持压缩输出 VPSS 上下文关系 VPSS 数据流图 2. 输入输出特性Hi3516DV300仅支持8bit YUV 输入像素格式仅包含： PIXEL_FORMAT_YVU_SEMIPLANAR_422 PIXEL_FORMAT_YVU_SEMIPLANAR_420 PIXEL_FORMAT_YUV_400 PIXEL_FORMAT_YUV_SEMIPLANAR_422 PIXEL_FORMAT_YUV_SEMIPLANAR_420 输出像素格式仅包含： PIXEL_FORMAT_YVU_SEMIPLANAR_422 PIXEL_FORMAT _YVU_SEMIPLANAR_420 PIXEL_FORMAT_YUV_400 PIXEL_FORMAT_YUV_SEMIPLANAR_422 PIXEL_FORMAT_YUV_SEMIPLANAR_420 3. API参考 API接口名 解释 太多了不记了 4. 数据类型 VPSS_GRP：定义VPSS组号 VPSS_CHN：定义VPSS通道号 VPSS_GRP_ATTR_S：定义 VPSS GROUP 属性 typedef struct hiVPSS_GRP_ATTR_S{ HI_U32 u32MaxW;//输入图像宽度 HI_U32 u32MaxH;//输入图像高度 PIXEL_FORMAT_E enPixelFormat;//输入图像像素格式 DYNAMIC_RANGE_E enDynamicRange;//输入图像动态范围 FRAME_RATE_CTRL_S stFrameRate;//组帧率 HI_BOOL bNrEn;//NR使能开关 VPSS_NR_ATTR_S stNrAttr;//NR属性 } VPSS_GRP_ATTR_S; VPSS_NR_ATTR_S：定义 VPSS GRP 的 3DNR 属性 typedef struct hiVPSS_NR_ATTR_S{ VPSS_NR_TYPE_E enNrType;//NR类型 COMPRESS_MODE_E enCompressMode;//重构帧压缩类型 NR_MOTION_MODE_E enNrMotionMode;//NR运动矢量模式 } VPSS_NR_ATTR_S; VPSS_CHN_ATTR_S：定义VPSS物理通道的属性 typedef struct hiVPSS_CHN_ATTR_S VPSS_CHN_MODE_E enChnMode;//通道工作模式。 HI_U32 u32Width;//目标图像宽度 HI_U32 u32Height;//目标图像高度 VIDEO_FORMAT_E enVideoFormat;//目标图像视频格式 PIXEL_FORMAT_E enPixelFormat;//目标图像像素格式 DYNAMIC_RANGE_E enDynamicRange;//目标图像动态范围 COMPRESS_MODE_E enCompressMode;//目标图像压缩模式 FRAME_RATE_CTRL_S stFrameRate;//帧率控制信息 HI_BOOL bMirror;//水平镜像使能 HI_BOOL bFlip;//垂直翻转使能 HI_U32 u32Depth;//用户获取通道图像的队列长度 ASPECT_RATIO_S stAspectRatio;//幅形比参数 } VPSS_CHN_ATTR_S; 太多了慢慢记","categories":[{"name":"Hispark开发学习笔记","slug":"Hispark开发学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Hispark%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"HIMPP开发SDK-系统控制","slug":"HIMPP开发SDK-系统控制","date":"2022-09-09T07:13:36.451Z","updated":"2022-09-09T07:13:36.453Z","comments":true,"path":"2022/09/09/himpp-kai-fa-sdk-xi-tong-kong-zhi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/himpp-kai-fa-sdk-xi-tong-kong-zhi/","excerpt":"","text":"HiMPP——系统控制 这部分的开发文档介绍的是使用海思的HI_MPI_SYS_xxxxx的API接口来实现对硬件也就是开发板中的各个部件的复位、基本初始化工作，同时还包括了对MPP（媒体处理子系统）中的各个业务模块进行初始化、出初始化还有管理MPP各个业务模块的工作状态，并且提供了当前MPP系统的版本信息、提供大块物理内存管理等功能 在我看来，这个部分就像一个流程管理，管理了程序的整个生命周期，应用程序要利用开发板上的MPP子系统执行业务，就必须完成MPP系统初始化工作，当应用程序不再需要MPP子系统的时候，就需要释放利用MPP的资源，包括内存和清除初始值，也就是去初始化的过程 下面介绍开发文档中系统控制提供的功能 1. 视频缓存池视频缓存池主要向媒体业务提供大块物理内存管理功能 ，负责内存的分配和回收，充分发挥内存缓存池的作用，让物理内存资源在各个媒体处理模块中合理使用 一组大小相同、物理地址连续的缓存块组成一个视频缓存池。必须在系统初始化之前配置公共视频缓存池。根据业务的不同，公共缓存池的数量、缓存块的大小和数量不同 初始化视频缓冲池的代码 暂时未找到，待填 所有的视频输入通道都可以从公共视频缓存池中获取视频缓存块用于保存采集的图像，如图中所示VI从公共视频缓存池B中获取视频缓存块Bm,缓存块Bm经VI发送给VPSS，输入缓存块Bm经过VPSS 处理之后被释放回公共视频缓存池。假设VPSS通道的工作模式是USER，则VPSS通道0从公共视频缓存池B中获取缓存块Bi作为输出图像缓存buffer发送给VENC，VPSS通道1从公共视频缓存池B中获取缓存块Bk 作为输出图像缓存buffer 发送给VO，Bi 经VENC 编码完之后释放回公共视频缓存池，Bk 经VO 显示完之后释放回公共视频缓存池 不管怎么样，都会回到公共视频缓存池 不同类型的视频缓存池大小计算相关API接口在hi_buffer.h文件中，下面我只记录一些可能会用得上的API 视频缓存池大小计算接口 接口简介 COMMON_GetPicBufferConfig 一般linear格式的YUV各部分数据大小 COMMON_GetPicBufferSize 一般linear格式的YUV缓存池 VI_GetRawBufferSize VI写出的Raw数据缓存池 VI_GetRawBufferSizeEx 帧压缩模式下根据压缩比计算VI写出的Raw数据缓存BUFFER大小，非帧压缩模式VI_GetRawBufferSize一致。 AVS_GetPicBufferSize AVS输入的YUV数据缓存池 VDEC_GetPicBufferSize VDEC输出的YUV帧存缓存池 VDEC_GetTmvBufferSize VDEC输出的Tmv数据缓存池 VENC_GetRefBufferSize VENC输出的重构帧YUV缓存池 VENC_GetRefBufferSize VENC参考帧大小 VENC_GetRefPicInfoBufferSize VENC参考帧信息（pme、pmeinfo、tmv）大小 VENC_GetQpmapSize Qpmap映射表大小 VENC_GetQpmapSizeStride Qpmap映射表stride VENC_GetSkipWeightSize SkipWeight映射表大小 VENC_GetSkipWeightSizeStride SkipWeight映射表stride VPSS_GetWrapBufferSize VPSS低延时卷绕功能输出buffer大小。仅Hi3516EV200支持 YUV数据结构YUV，是一种颜色编码方法。常使用在各个视频处理组件中。 YUV在对照片或视频编码时，考虑到人类的感知能力，允许降低色度的带宽。YUV是编译true-color颜色空间（color space）的种类，Y’UV, YUV, YCbCr，YPbPr等专有名词都可以称为YUV，彼此有重叠。“Y”表示明亮度（Luminance或Luma），也就是灰阶值，“U”和“V”表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。 参考帧参考帧指的是IPB编码时所需参考的帧。 YUV参考资料参考帧参考资料 这两个基础知识还尚未了解，待实践 2. 系统绑定为了启动流程控制的目的，MPP系统提供了系统绑定的接口（HI_MPI_SYS_Bind），即通过数据接收者绑定数据源来建立两者之间的关联关系（只允许数据接收者绑定数据源）绑定后，数据源生成的数据将自动发送给接收者。 MPP支持的绑定关系： 3. 设置VI和VPSS的工作模式VI和VPSS各自的工作模式分为在线，离线，并行模式 这里可以试试平行模式来处理，看看能不能更快的处理数据 我的理解是通过系统绑定建立起PIPE，然后通过设置PIPE两端的模块的工作方式，来起到控制系统的目的，PIPE可以设置成多种工作模式 第0个PIPE有4种模式： VI在线VPSS离线 VI在线VPSS在线 VI离线VPSS离线 VI离线VPSS在线 其他PIPE可以有2种模式 当第0个PIPE为VI离线VPSS在线时绑定的其他PIPE只能设置VI离线VPSS在线 当第0个PIPE设置成其它模式时绑定的其他PIPE只能为VI 离线VPSS离线 PIPE在不同的工作模式下可以进行切换，此时VI需要重建，情况如下： VI在线模式可以切换到VI并行模式 VI并行模式可以切换到VI在线模式 VI在线模式不能切换到VI离线模式 VI离线模式不能切换到VI在线模式及VI并行模式 设置工作模式的代码： 尚未找到，找到之后填上去 4. 内存管理Hi3516DV300将内存划分为OS内存和MMZ（Media Memory Zone）内存，而且用户可以通过load脚本继续划分MMZ内存以供某功能某块单独使用 OS内存：是指由操作系统管理的内存 MMZ内存：是指由MMZ驱动模块进行管理供媒体业务单独使用的内存，在驱动加载时可以指定该模块管理内存的大小，海思整套系统（MPP\\NNIE\\IVE等）都是基于其专有内存进行数据传输、存储的。 查看MMZ内存信息使用cat /proc/media-mem，可以查看到系统总共、已使用的、剩余的MMZ，包括每一块已经使用的MMZ的使用情况 视频缓存池（VB）VB的本质上就是一个物理地址连续的MMZ内存块，只不过在MPP层里提供了一系列初始化，申请，释放操作的接口，所以VB其实也属于MMZ内存 一组大小相同，物理地址连续的缓存块（VB）组成一个视频缓存池（VB POOL）。这个视频缓存池的作用就是给MPP提供大块物理内存管理功能，负责内存的分配和回收。因为VB的使用者主要是海思的硬件模块,比如vi/vpss/venc等等, 需要连续的物理地址, 有点类似早期的linux为硬件DMA分配内存也要求物理地址连续 5. API参考下面只介绍一些可能用得上的API接口 API接口名 解释 HI_MPI_SYS_SetConfig 配置系统控制参数 HI_MPI_SYS_GetConfig 获取系统控制参数 HI_MPI_SYS_Init 初始化MPP系统 HI_MPI_SYS_Exit 去初始化MPP系统 HI_MPI_SYS_Bind 数据源到数据接收者绑定 HI_MPI_SYS_UnBind 数据源到数据接收者解绑定 HI_MPI_SYS_GetBindbyDest 根据目标获取绑定的源 HI_MPI_SYS_GetBindbySrc 根据源获取绑定的目标 HI_MPI_VB_SetConfig 设置MPP视频缓存池属性 HI_MPI_VB_GetConfig 获取MPP视频缓存池属性 HI_MPI_VB_Init 初始化MPP视频缓存池 HI_MPI_VB_Exit 去初始化MPP视频缓存池 HI_MPI_VB_CreatePool 创建一个视频缓存池 HI_MPI_VB_DestroyPool 销毁一个视频缓存池 HI _MPI_VB_GetBlock 获取一个缓存块 HI_MPI_VB_ReleaseBlock 释放一个已经获取的缓存块 HI_MPI_VB_PhysAddr2Handle 用户态通过缓存块的物理地址获取其句柄 HI_MPI_VB_Handle2PhysAddr 获取一个缓存块的物理地址 HI_MPI_VB_Handle2PoolId 获取一个缓存块所在缓存池的ID HI_M PI_VB_InitModCommPool 初始化模块公共视频缓冲池 HI_MPI_VB_ExitModCommPool 注销模块公共视频缓冲池 HI_MPI_VB_SetModPoolConfig 设置模块公共视频缓冲池属性 HI_MPI_VB_GetModPoolConfig 获取模块公共视频缓冲池属性 HI_MPI_VB_InquireUserCnt 查询缓存块使用计数信息 HI_MPI_VB_GetSupplementAddr 获取VB Block内存的辅助信息 HI_MPI_VB_SetSupplementConfig 设置VB内存的附加信息 HI_MPI_VB_GetSupplementConfig 获取VB内存的附加信息 HI_MPI_SYS_SetR awFrameCompressParam 设置VI模块 RAW数据的帧压缩比 HI_MPI_SYS_GetRawFrameCompressParam 获取VI模块RAW数据的帧压缩比 HI_MPI_LOG_SetLevelConf 设置日志等级 HI_MPI_LOG_G etLevelConf 获取日志等级 HI_MPI_LOG_SetWaitFlag 设置读取日志时等待标志 HI_MPI_LOG_Read 读取日志 HI_MPI_LOG_Close 关闭日志文件 sys _mod_init 系统初始化 sys _mod_exit 系统去初始化 是不是很多？但是我还没有将全部API记录下来，而且具体的API的使用仍然需要查开发文档，这里只是给出一个概述 6. 数据类型海思给出了它特殊的数据类型，就是一些已经定义好的结构体、枚举类型、或者是变量，分为三大类：基本数据类型、系统控制数据类型、视频公共类型 下面给出一些比较常见的数据类型： 基本数据类型HI_Ux形式的表示的是unsigned的数据类型，x=8,16,32,64分别对应了char，short，int，long long，long对应的是HI_UL(HI_ULONG) HI_Sx形式的表示的是signed的数据类型，同样x=8,16,32,64分别对应了char，short，int，long long OPERATION_MODE_E：定义操作模式枚举 typedef enum hiOPERATION_MODE_E { OPERATION_MODE_AUTO = 0,//自动模式，一般此模式使用程序内部的默认参数 OPERATION_MODE_MANUAL = 1,//手动模式，一般此模式使用用户配置的参数 OPERATION_MODE_BUTT } OPERATION_MODE_E; 对于前期开发来说，可以直接选择自动模式来进行，开发到一定程度，知识储备足够了可以尝试一下使用手动模式 VB_MAX_POOLS：最大的视频缓存池个数 MOD_ID_E：定义MPP模块ID枚举类型 typedef enum hiMOD_ID_E { HI_ID_CMPI = 0, HI_ID_VB = 1, HI_ID_SYS = 2, HI_ID_RGN = 3, HI_ID_CHNL = 4, HI_ID_VDEC = 5, HI_ID_AVS = 6, HI_ID_VPSS = 7, HI_ID_VENC = 8, HI_ID_SVP = 9, HI_ID_H264E = 10, HI_ID_JPEGE = 11, HI_ID_MPEG4E = 12, HI_ID_H265E = 13, HI_ID_JPEGD = 14, HI_ID_VO = 15, HI_ID_VI = 16, HI_ID_DIS = 17, HI_ID_VALG = 18, HI_ID_RC = 19, HI_ID_AIO = 20, HI_ID_AI = 21, HI_ID_AO = 22, HI_ID_AENC = 23, HI_ID_ADEC = 24, HI_ID_VPU = 25, HI_ID_PCIV = 26, HI_ID_PCIVFMW = 27, HI_ID_ISP = 28, HI_ID_IVE = 29, HI_ID_USER = 30, HI_ID_DCCM = 31, HI_ID_DCCS = 32, HI_ID_PROC = 33, HI_ID_LOG = 34, HI_ID_VFMW = 35, HI_ID_H264D = 36, HI_ID_GDC = 37, HI_ID_PHOTO = 38, HI_ID_FB = 39, HI_ID_HDMI = 40, HI_ID_VOIE = 41, HI_ID_TDE = 42, HI_ID_HDR = 43, HI_ID_PRORES = 44, HI_ID_VGS = 45, HI_ID_FD = 47, HI_ID_ODT = 48, //Object detection trace HI_ID_VQA = 49, //Video quality analysis HI_ID_LPR = 50, //Object detection trace HI_ID_SVP_NNIE = 51, HI_ID_SVP_DSP = 52, HI_ID_DPU_RECT = 53, HI_ID_DPU_MATCH = 54, HI_ID_MOTIONSENSOR = 55, HI_ID_MOTIONFUSION = 56, HI_ID_GYRODIS = 57, HI_ID_PM = 58, HI_ID_SVP_ALG = 59, HI_ID_IVP = 60, HI_ID_MCF = 61, HI_ID_QR = 62, HI_ID_FR = 63, HI_ID_BUTT, } MOD_ID_E VB_UID_E：定义视频缓冲池的模块ID枚举类型 typedef enum hiVB_UID_E { VB_UID_VI = 0, VB_UID_VO = 1, VB_UID _VGS = VB_UID_VENC = 3, VB_UID_VDEC = 4, VB_UID_H265E = 5, VB_UID_H264E = 6, VB_UID_JPEGE = 7, VB_UID_H264D = 8, VB_UID_JPEGD = 9, VB_UID_VPSS = 10, VB_UID_DIS = 11, VB_UID_USER = 12, VB_UID_PCIV = 13, VB_ UID_AI = 14, VB_UID_AENC = 15, VB_UID_RC = 16, VB_UID_VFMW = 17, VB_UID_GDC = 18, VB_UID_AVS = 19, VB_UID_DPU_RECT = 20, VB_UID_DPU_MATCH = 21, VB_UID_MCF = 22, VB_UID_BUTT = 23, } VB_UID_E; VB_SOURCE_E：定义VB来源选择 typedef enum hiVB_SOURCE_E { VB_SOURCE_COMMON = 0,//公共VB VB_S OURCE_MODULE = 1,//模块VB VB_SOURCE_PRIVATE = 2,//私有VB VB_SOURCE_USER = 3,//用户VB VB_SOURCE_BUTT } VB_SOURCE_E; VIDEO_DISPLAY_MODE_E：定义视频显示模式枚举 typedef enum hiVIDEO_DISPLAY_MODE_E { VIDEO_DISPLAY_MODE_PR EVIEW = 0×0,//回放模式 VIDEO_DISPLAY_MODE_PLAYBACK = 0×1,//预览模式 VIDEO_DISPLAY_MODE_BUTT }VIDEO_DISPLAY_MODE_E; WDR_MODE_E：WDR模式枚举 typedef enum hiWDR_MODE_E { WDR_MODE_NONE = 0,//线性模式 WDR_MODE_BUILT_IN,//Sensor合成WDR模式 WDR_MODE_QUDRA,//QUDRA WDR模式 WDR_MODE_2To1_LINE,//2帧合成行WDR模式 WDR_MODE_2To1_FRAME,//2帧合成帧WDR模式 WDR_MODE_2To1_FRAME_FULL_RATE,//2帧合成帧WDR全帧率模式 WDR_MODE_3To1_LINE,//3帧合成行WDR模式 WDR_MODE_3To1_FRAME,//3帧合成帧WDR模式 WDR_MODE_3To1_FRAME_FULL_RATE,//3帧合成帧WDR全帧率模式 WDR_MODE_4To1_LINE,//4帧合成行WDR模式 WDR_MODE_4To1_FRAME,//4帧合成帧WDR模式 WDR_MODE_4To1_FRAME_FULL_RATE,//4帧合成帧WDR全帧率模式 WDR_MODE_BUTT, }WDR_MODE_E; 经查阅知，WDR在光照分布差距较大的图片中的效果较好，但是还未实践 PAYLOAD_TYPE_E：定义音视频净荷类型枚举 其实就是定义音视频的编码形式，主要是PT_H265、PT_H264、PT_JPEG、PT_PNG DATA_RATE_E：定义设备的速率 typedef enum hiDATA_RATE_E { DATA_RATE_X1 = 0,//一拍一像素 DATA_RATE_X2 = 1,//一拍两像素 DATA_RATE_BUTT }DATA_RATE_E; FRAME_FLAG_E：定义帧的类型 typedef enum hiFRAME_FLAG_E { FRAME_FLAG_SNAP_FLASH = 0x1 &lt;&lt; 0,//拍照时是否开启闪光灯 FRAME_FLAG_SNAP_CUR = 0x1 &lt;&lt; 1,//拍照的有效数据帧 FRAME_FLAG_SNAP_REF = 0x1 &lt;&lt; 2,//拍照帧的参考帧 FRAME_FLAG_SNAP_END = 0x1 &lt;&lt; 31,//连拍的最后一张帧数据标示 FRAME_FLAG_BUTT } FRAME_RATE_CTRL_S：定义帧率控制结构体 typedef struct hiFRAME_RATE_CTRL_S { HI_S32 s32SrcFrameRate;//源帧率，即输入帧率，取值范围-1或[1, 240] HI_S32 s32DstFrameRate;//目的帧率，即输出帧率，取值范围：[-1, s32SrcFrameRate] } FRAME_RATE_CTRL_S; 帧率按我的理解的话应该是每秒的帧数，30fps常用于电影中，可以流畅的看视频 POINT_S：定义坐标信息结构体 typedef struct hiPOINT_S { HI_S32 s32X;//横坐标 HI_S32 s32Y;//纵坐标 }POINT_S; SIZE_S:定义大小信息结构体 typedef struct hiSIZE_S { HI_U32 u32Width;//宽度 HI_U32 u32Height;//高度 }SIZE_S; RECT_S：定义矩形区域信息结构体 typedef struct hiRECT_S { HI_S32 s32X;//矩阵框左上角横坐标（应该是，待验证） HI_S32 s32Y;//矩阵框左上角纵坐标 HI_U32 u32Width;//宽度 HI_U32 u32Height;//高度 }RECT_S; BORDER_S：定义边框属性结构体 typedef struct hiBORDER_S { HI_U32 u32TopWidth; //边框顶部宽度，以像素为单位 HI_U32 u32BottomWidth;//边框底部宽度，以像素为单位 HI_U32 u32LeftWidth; //边框左边宽度，以像素为单位 HI_U32 u32RightWidth;//边框右边宽度，以像素为单位 HI_U32 u32Color;//边框颜色，颜色格式为rgb888，u32的低24bit为有效位。 }BORDER_S; LUMA_INFO_S：定义亮度信息结构体 typedef struct hiLUMA_INFO_S { HI_U64 u64LumaPixSum;//亮度和 HI_U32 u32LumaPixAverage;//平均亮度 HI_U64 u64PTS;//当前帧的PTS }LUMA_INFO_S; ISP_FRAME_INFO_S：ISP的实时信息 typedef struct hiISP_FRAME_INFO_S { HI_U32 u32ISO;//当前sensor模拟增益*sensor数字增益*ISP数字增益*100 HI_U32 u32ExposureTime;//曝光时间，单位是微秒（us） HI_U32 u32IspDgain;//ISP数字增益 HI_U32 u32Again;//Sensor的模拟增益 HI_U32 u32Dgain;//Sensor的数字增益 HI_U32 au32Ratio[3];//多帧合成WDR相邻2帧默认曝光比 HI_U32 u32IspNrStrength;//ISP的NR强度。当前未支持，默认值为0 HI_U32 u32FNumber;//当前使用的镜头的光圈值 HI_U32 u32SensorID;//当前使用的sensorID HI_U32 u32SensorMode;//当前使用的sensor序列模式 HI_U32 u32HmaxTimes;//当前使用的sensor对应读出一行的时间，单位是纳秒（ns） HI_U32 u32VcNum;//当前采集的帧的序列号。当前未支持，默认值为0 } ISP_FRAME_INFO_S; JPEG_DCF_S：JPEG图片使用的DCF信息 typedef struct hiJPEG_DCF_S { HI_U8 au8CaptureTime[DCF_CAPTURE_TIME_LENGTH];//Jpeg图片拍摄的时间 HI_BOOL bFlash;//Jpeg照片拍摄的时候是否有闪光灯 HI_U32 u32DigitalZoomRatio;//Jpeg照片拍摄的时候的数码缩放倍数。 ISP_DCF_INFO_S stIspDCFInfo;//DCF其他信息，请参考HiISP 开发参考章节。 } JPEG_DCF_S; ROTATION_EX_S：定义任意角度旋转属性 typedef struct hiROTATION_EX_S { ROTATION_VIEW_TYPE_E enViewType; //任意角度旋转的旋转模式，裁剪模式、全模式和典型模式 HI_U32 u32Angle;//旋转的角度。范围是[0, 360] HI_ S32 s32CenterXOffset; //旋转中心点相对图象中心点水平偏移。仅典型模式支持。范围是[-511, 511] HI_S32 s32CenterYOffset; //旋转中心点相对图象中心点垂直偏移。仅典型模式支持。范围是[-511, 511] SIZE_S stDestSize; //旋转后的得到的图像大小，如果旋转后截取图像大小相对stDestSize有变化，会对图像进行缩放处理。范围是480*360到最大宽高值（HI3516DV300是4608 x 4608） } ROTATION_EX_S; ROTATION_VIEW_TYPE_E：定义旋转的视野模式 typedef enum hiROTATION_VIEW_TYPE_E { ROTATION_VIEW_TYPE_ALL = 0,//全模式，保留所有的图像，无图像视野损失，但随着旋转角度改变带来较多的黑边 ROTATION_VIEW_TYPE_TYPICAL = 1, //典型模式，用原有视野截取旋转后图像，会有部分图像损失，也会留有一定量的黑边 ROTATION_VIEW_TYPE_INSIDE = 2,//无黑边模式，在旋转后图中选取无黑边的视野大小 ROTATION_VIEW_TYPE_BUTT, } ROTATION_V IEW_TYPE_E; ROTATION_E：定义旋转角度枚举 typedef enum hiROTATION_E { ROTATION_0 = 0,//不旋转，旋转0度 ROTATION_90 = 1,//旋转90度 ROTATION_180 = 2,//旋转180度 ROTATION_270 = 3,//旋转270度 ROTATION_BUTT }ROTATION_E; 关于镜头矫正的API接口并没有列出来，因为现在的目的是能使用摄像头进行视觉开发，至于优化的问题可以在后面进行 系统控制数据类型 MPP_CHN_S：定义模块设备通道结构体 typedef struct hiMPP_CHN_S { MOD_ID_E enModId;//模块号 HI_S32 s32DevId;//设备号 HI_S32 s32ChnId;//通道号 } MPP_CHN_S; MPP_BIND_DEST_SL：定义MPP系统绑定目的信息结构体 typedef struct hiMPP_BIND_DEST_S { HI_U32 u32Num;//通过SYS绑定的目的数目 MPP_CHN_S astMppChn[BIND_DEST_MAXNUM];//通过SYS绑定的目的模块通道信息结构体 }MPP_BIND_DEST_S; VI_VPSS_MODE_E：定义VI PIPE和VPSS组的工作模式 typedef enum hiVI_VPSS_MODE_E VI_OFFLINE_VPSS_OFFLINE = 0,//VI离线，VPSS离线 VI_OFFLINE_VPSS_ONLINE,//VI离线，VPSS在线 VI_ONLINE_VPSS_OFFLINE,//VI在线，VPSS离线 VI_ONLINE_VPSS_ONLINE,//VI在线，VPSS在线 VI_PARALLEL_VPSS_OFFLINE,//VI并行，VPSS离线 VI_PARALLEL_VPSS_PARALLEL,//VI并行，VPSS并行 VI_VPSS_MODE_BUTT } VI_VPSS_MODE_E; VI_ OFFLINE _VPSS_ONLINE，VI_ONLINE_VPSS_ONLINE，VI_PARALLEL_VPSS_PARALLEL 模式下VI PIPE编号与VPSS GROUP号一一对应，数据从VI PIPE流动 到VPSS GROUP不需要软件设定绑定关系 VI_VPSS_MODE_S：定义VI各个PIPE和VPSS各个组的工作模式 typedef struct hiVI_VPSS_MODE_S { VI_VPSS_MODE_E aenMode[VI_MAX_PIPE_NUM];//VI各个PIPE和VPSS各个组的工作模式。 } VB_CONFIG_S：定义视频缓存池属性结构体 typedef struct hiVB_CONFIG_S HI_U32 u32MaxPoolCnt;//整个系统中可容纳的缓存池个数。(0, VB_MAX_POOLS] VB_POOL_CONFIG_S astCommPool[VB_MAX_COMM_POOLS];//公共缓存池属性结构体 } VB_CONFIG_S VB_POOL_CONFIG_S：定义视频缓存池属性结构体 typedef struct hiVB_POOL_CONFIG_S { HI_U64 u64BlkSize;//缓存块大小 HI_U32 u32BlkCnt;//每个缓存池的缓存块个数 VB_REMAP _MODE_E enRemapMode;//VB的内核态虚拟地址映射模式 HI_CHAR acMmzName[MAX_MMZ_NAME_LEN];//当前缓存池从哪个MMZ区域分配内存 }VB_POOL_CONFIG_S; VB_REMAP_MODE_E：定义VB内核态虚拟地址映射模式 typedef enum hiVB_REMAP_MODE_E { VB_REMAP_MODE_NONE = 0, // VB不映射内核态虚拟地址 VB_REMAP_MODE_NOCACHE = 1, //VB映射nocache属性的内核态虚拟地址 VB_REMAP_MODE_CACHED = 2, //VB映射cached属性的内核态虚拟地址 VB_REMAP_MODE_BUTT } VB_REMAP_MODE_E; RAW_FRAME_COMPRESS_PARAM_S ：定义VI模块RAW数据的压缩比 typedef struct hiRAW_FRAME_COMPRESS_PARAM_S { HI_U32 u32CompRatio_10Bit;//VI 10bit RAW数据的压缩比 HI_U32 u32CompRatio_12Bit;//VI 12bit RAW数据的压缩比 HI_U32 u32CompRatio_14Bit;//VI 14bit RAW数据的压缩比 }RAW_FRAME_COMPRESS_PARAM_S; 这里的 压缩比是 放大了1000 倍， 即$\\frac{输入大小}{输出大小}\\times1000$ 当 压缩比发生变化的时候，所需要的VB大小是不一样的，可以通过VI_GetRawBufferSizeEx函数计算VB大小 当设置的压缩比超过默认值时，由于压缩算法的原因可能会导致视觉上可见的损失，因而，为了保证压缩效果，建议用户设置的值不要超过默认值 这里只是列出一些定义的结构体，还有一些定义好的宏定义就没有列出来了，需要自己查阅文档，VPSS和VGS的相关操作也没有列出 视频公共类型 PIXEL_FORMAT_E：定义像素格式类型 typedef enum hiPIXEL_FORMAT_E { PIXEL_FORMAT_RGB_444 = 0, PIXEL_FORMAT_RGB_555, PIXEL_FORMAT_RGB_565, PIXEL_FORMAT_RGB_888, PIXEL_FORMAT_BGR_444, PIXEL_FORMAT_BGR_555, PIXEL_FORMAT_BGR_565, PIXEL_FORMAT_BGR_888, PIXEL_FORMAT_ARGB_1555, PIXEL_FORMAT_ARGB_4444, PIXEL_FORMAT_ARGB_8565, PIXEL_FORMAT_ARGB_8888, PIXEL_FORMAT_ARGB_2BPP, PIXEL_FORMAT_ABGR_1555, PIXEL_FORMAT_ABGR_4444, PIXEL_FORMAT_ABGR_8565, PIXEL_FORMAT_ABGR_8888, PIXEL_FORMAT_RGB_BAYER_8BPP, PIXEL_FORMAT_RGB_BAYER_10BPP, PIXEL_FORMAT_RGB_BAYER_12BPP, PIXEL_FORMAT_RGB_BAYER_14BPP, PIXEL_FORMAT_RGB_BAYER_16BPP, PIXEL_FORMAT_YVU_PLANAR_422, PIXEL_FORMAT_YVU_PLANAR_420, PIXEL_FORMAT_YVU_PLANAR_444, PIXEL_FORMAT_YVU_SEMIPLANAR_422, PIXEL_FORMAT_YVU_SEMIPLANAR_420, PIXEL_FORMAT_YVU_SEMIPLANAR_444, PIXEL_FORMAT_YUV_SEMIPLANAR_422, PIXEL_FORMAT_YUV_SEMIPLANAR_420, PIXEL_FORMAT_YUV_SEMIPLANAR_444, PIXEL_FORMAT_YUYV_PACKAGE_422, PIXEL_FORMAT_YVYU_PACKAGE_422, PIXEL_FORMAT_UYVY_PACKAGE_422, PIXEL_FORMAT_VYUY_PACKAGE_422, PIXEL_FORMAT_YYUV_PACKAGE_422, PIXEL_FORMAT_YYVU_PACKAGE_422, PIXEL_FORMAT_UVYY_PACKAGE_422, PIXEL_FORMAT_VUYY_PACKAGE_422, PIXEL_FORMAT_VY1UY0_PACKAGE_422, PIXEL_FORMAT_YUV_400, PIXEL_FORMAT_UV_420, /* SVP data format */ PIXEL_FORMAT_BGR_888_PLANAR, PIXEL_FORMAT_HSV_888_PACKAGE, PIXEL_FORMAT_HSV_888_PLANAR, PIXEL_FORMAT_LAB_888_PACKAGE, PIXEL_FORMAT_LAB_888_PLANAR, PIXEL_FORMAT_S8C1, PIXEL_FORMAT_S8C2_PACKAGE, PIXEL_FORMAT_S8C2_PLANAR, PIXEL_FORMAT_S8C3_PLANAR, PIXEL_FORMAT_S16C1, PIXEL_FORMAT_U8C1, PIXEL_FORMAT_U16C1, PIXEL_FORMAT_S32C1, PIXEL_FORMAT_U32C1, PIXEL_FORMAT_U64C1, PIXEL_FORMAT_S64C1, PIXEL_FORMAT_BUTT } PIXEL_FORMAT_E; DYNAMIC_RANGE_E：定义动态范围枚举 typedef enum hiDYNAMIC_RANGE_E { DYNAMIC_RANGE_SDR8 = 0, DYNAMIC_RANGE_SDR10, DYNAMIC_RANGE_HDR10, DYNAMIC_RANGE_HLG, DYNAMIC_RANGE_SLF, DYNAMIC_RANGE_XDR, DYNAMIC_RANGE_BUTT } DYNAMIC_RANGE_E; VIDEO_FORMAT_E：定义视频格式结构体 typedef enum hiVIDEO_FORMAT_E { VIDEO_FORMAT_LINEAR = 0, /* nature video line */ VIDEO_FORMAT_TILE_64x16, /* tile cell: 64pixel x 16line */ VIDEO_FORMAT_TILE_16x8, /* tile cell: 16pixel x 8line */ VIDEO_FORMAT_LINEAR_DISCRETE, /* The data bits are aligned in bytes */ VIDEO_FORMAT_BUTT } VIDEO_FORMAT_E; COMPRESS_MODE_E：定义视频压缩数据格式结构体 typedef enum hiCOMPRESS_MODE_E { COMPRESS_MODE_NONE = 0, /* no compress */ COMPRESS_MODE_SEG, /* compress unit is 256x1 bytes as a segment.*/ COMPRESS_MODE_TILE, /* compress unit is a tile.*/ COMPRESS_MODE_LINE, /* compress unit is the whole line. raw for VI */ COMPRESS_MODE_FRAME, /* compress unit is the whole frame. YUV for VI(3DNR), RGB for TDE(write)/VO(read) */ COMPRESS_MODE_BUTT } COMPRESS_MODE_E; VB_CAL_CONFIG_S：定义视频图像帧各部分数据大小配置信息结构体 ```c typedef struct hiVB_CAL_CONFIG_S { HI_U32 u32VBSize; //视频图像帧总大小。 HI_U32 u32HeadStride; //视频图像帧压缩头stride HI_U32 u32HeadSize; //视频图像帧压缩头总大小 HI_U32 u32HeadYSize; //视频图像帧亮度压缩头大小 HI_U32 u32MainStride; //视频图像帧主体数据stride HI_U32 u32MainSize; //视频图像帧主体数据总大小 HI_U32 u32MainYSize; //视频图像帧主体数据亮度大小 HI_U32 u32ExtStride; //10bit像素的视频图像帧额外存储的2bit数据stride HI_U32 u32ExtYSize; //10bit像素的视频图像帧额外存储的2bit数据亮度大小 }VB_CAL_CONFIG_S; 暂时先不去了解这个数据类型，因为我觉得这边的开发需要比较多的图像知识","categories":[{"name":"Hispark开发学习笔记","slug":"Hispark开发学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Hispark%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"规范git commit","slug":"规范git commit","date":"2022-09-09T07:13:36.445Z","updated":"2022-09-09T07:13:36.445Z","comments":true,"path":"2022/09/09/gui-fan-git-commit/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/gui-fan-git-commit/","excerpt":"","text":"commit message格式&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; 1. type(必须)feat：新功能（feature）。 fix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。 fix：产生diff并自动修复此问题。适合于一次提交直接修复问题 to：只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix docs：文档（documentation）。 style：格式（不影响代码运行的变动）。 refactor：重构（即不是新增功能，也不是修改bug的代码变动）。 perf：优化相关，比如提升性能、体验。 test：增加测试。 chore：构建过程或辅助工具的变动。 revert：回滚到上一个版本。 merge：代码合并。 sync：同步主线或分支的Bug。 2. scope(可选)scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。如果你的修改影响了不止一个scope，你可以使用*代替。 3. subject(必须)subject是commit目的的简短描述，不超过50个字符。 建议使用中文（感觉中国人用中文描述问题能更清楚一些）。 结尾不加句号或其他标点符号。","categories":[{"name":"Git学习笔记","slug":"Git学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Hello_git","slug":"Hello_git","date":"2022-09-09T07:13:36.439Z","updated":"2022-09-09T07:13:36.440Z","comments":true,"path":"2022/09/09/hello-git/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/hello-git/","excerpt":"","text":"Hello GitHub1. 学习GitHub的意义​ GitHub是一个面向开源及私有软件的托管平台，在上面有来自世界各地的程序员发布的开源项目，这是一个很好的学习平台，而且它满足团队协作的优点，能让多人能够同时对一个项目进行编程。作为一个分布式的版本控制系统，它能让各位开发者在GitHub的库上克隆到本地库上进行搭建自己的工程，也可以通过Git上传到服务器上，适合分布开发。 2. 使用GitHub的方法 首先你需要创建GitHub平台的账号，完善个人资料 获取Git clone的HTTPS的地址的值，或者可以直接以压缩包的形式下载工程 GitHub作为程序员的最大同性交友网站，当然提供了类似赞，转发之类的功能 Fork的功能是一个将别人的开源项目添加到自己仓库的一个按钮，相当于克隆你喜欢的大佬的项目工程至你自己的仓库中，你还可以Fork一个工程然后对这个项目进行修复，向这个项目的拥有者提交一个pull requset，如果这个项目的拥有者认同你的成果，他们可能会将你的修复更新到原始的仓库中 Watch的功能是关注，目的是等作者更新的时候，你可以第一时间收到通知 Star的功能是收藏，目的是方便以后查找，希望大家能给自己喜欢的项目、喜欢的大佬一个⭐吧 其次为了让你的项目有地方存放，你要创建一个仓库（Repository），为了让团队成员和其他人能够理解这个项目的内容，创建的仓库里最好有一个ReadMe.md的说明文档，点击Initialize this repository with a README会自动创建在仓库中 为了体现分布开发的特点仓库中还包含了一种叫分支（branch）的东西 默认情况下，仓库中会有一个叫做master的主分支，但是可以在主分支中创建分支，团队成员根据分工拉取不同功能的分支进行不同的功能开发，这样就可以隔离每个人的工作，当每个人的分支都完成后，可以向主分支master发起pull Request，在确保这些分支的功能对项目是有效的时候可以将这些分支合并入主分支master中 在仓库的code选项卡中的Branch下拉框里命名新分支的名字就可以创建新的分支 Pull Request是将个人代码提交到团队代码的过程，在GitHub上也可以进行Pull Request的操作，在仓库的界面上就有Pull Request的按钮，点击后进入Compare Change的界面来比较代码，当然也可以通过Git提交本地修改好之后的项目文件 GitHub issue在仓库的选项卡中的按钮在这里可以看到其他用户或者项目合作者对于这个项目提出的一些疑问 在GitHub平台上可以点击Explore去发现感兴趣的相关方向的项目，相当于你选择了你感兴趣的Topics之后，由推荐系统给你推送相关的项目 当然，GitHub还有很多功能等待你去摸索，这里只介绍一小部分，值得一提的是想要利用好GitHub去了解别人优秀的作品，你需要具备一定的英语阅读理解的能力，因为大部分readme都是使用英文来写的，但是作为学习计算机的学子来说，这不是必须具备的技能吗？ 3. Git工作流程GitHub 只支持 Git 作为唯一的版本库格式进行托管，通过 Git 可以与 GitHub 帐户进行连接，它与远程仓库通过 SSH 协议进行连接，它可以将用户的 GitHub 上的项目取出到本地文件中 工作区是使用 git init 创建的空间，使用 git add 的指令可以将项目添加到 index （暂存区），暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中 当执行提交操作 git commit 时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树 如果需要将项目发布到远程仓库中，还需要使用 git push 指令，才能将本地项目推送到远程仓库，让项目合作者或者其他GitHub用户看到 4. 常用的Git命令 Git命令 功能 git init 创建版本库 git remote add origin git@github.com:yourName/repositoryname.git 连接远程仓库 git pull origin main(master) 从远程仓库拉取文件，开始改版使用main作为主分支 git status 查看工作目录的状态 git add &lt;file&gt; 将文件添加到暂存区（index） git commit -m \"commnet\" 提交更改,添加备注信息(此时将暂存区的信息提交到本地仓库) git push origin master 将本地仓库的文件push到远程仓库(若 push不成功，可加 -f 进行强推操作) git push -u origin master 用于仓库第一次推送 git remote -v 查看连接远程仓库的地址 git remote remove origin 取消与远程仓库的连接 git reflog 查看提交记录 git reset --hard HEAD@{X} 回滚git操作，用于恢复本地代码 git branch 查看本地分支 git branch -r 查看远程分支 git branch -a 查看所有分支 git fetch 用于从远程获取代码库，但是没有直接merge git diff origin 先fetch之后查看本地仓库和远程仓库有哪些不同 git log 查看历史提交记录 git checkout + 分支名称 切换分支 git branch -d localBranchName 删除本地分支 git push origin --delete remoteBranchName 删除远程分支 git remote update origin --prune 更新远程分支列表 git push origin --delete dev 删除远程分支dev","categories":[{"name":"Git学习笔记","slug":"Git学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"git问题参考","slug":"git问题参考","date":"2022-09-09T07:13:36.431Z","updated":"2022-09-09T07:13:36.432Z","comments":true,"path":"2022/09/09/git-wen-ti-can-kao/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/git-wen-ti-can-kao/","excerpt":"","text":"git 过程中遇到的问题1. 同步远程仓库error: failed to push some refs to 'https://github.com/selamangit/lightsemi-rf-test-tool.git' 当你想把本地仓库的代码 push 到远程仓库时，出现这样的报错 问题原因：远程库与本地库不一致造成的，我的问题是远程仓库没有main分支，这个是比较sb的错误不值得参考，但是如果远程已经有分支了还出现这个错误的话可以像使用下面的语句进行同步一下 解决办法：git pull --rebase origin master（pull=fetch+merge） 但是这又面临另外一个问题：远程仓库是新创建的，同步之后会把本地仓库的代码覆盖掉，当然覆盖之后也是有办法回滚代码恢复本地仓库的，但是为了能让本地仓库的代码能成功上传到远程仓库中，我们需要另外想一个办法将代码上传 2. On branch master nothing to commit, working tree clean问题原因：远程仓库没有main分支 解决办法：建立一个main分支 3. fatal: couldn’t find remote ref main问题原因：远程仓库没有main分支 解决办法：建立一个main分支 4. ! [rejected] main -&gt; main (fetch first)问题原因：因为我在github网页上修改了readme.md文档，导致远程仓库和本地仓库的代码不一致，发生冲突。这时候需要将远程仓库的代码拉去下来先，但是先备份自己修改的本地代码 解决办法： git fetch origin git merge origin/mai 5. fatal: unable to access ‘https://github.com/selamangit/lightsemi-rf-test-tool.git/': OpenSSL SSL_read: Connection was reset, errno 10054问题原因：因为git在拉取或者提交项目时，中间会有git的http和https代理，但是我们本地环境本身就有SSL协议了，所以取消git的https代理即可，不行再取消http的代理。 也有可能是网速的原因，但是我试了好几次还是不行，而且当时网速还挺好，因此尝试下面的方法 解决办法： git config --global --unset http.proxy #取消http代理 git config --global --unset https.proxy #取消https代理","categories":[{"name":"Git学习笔记","slug":"Git学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"git远程仓库版本回退","slug":"git远程仓库版本回退","date":"2022-09-09T07:13:36.423Z","updated":"2022-09-09T07:13:36.424Z","comments":true,"path":"2022/09/09/git-yuan-cheng-cang-ku-ban-ben-hui-tui/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/git-yuan-cheng-cang-ku-ban-ben-hui-tui/","excerpt":"","text":"git远程仓库版本回退1. git reset使用命令git log查看版本号，查看需要回退的版本号 使用 git reset --hard 目标版本号 命令将版本回退 接着使用 git push -f 忽略版本冲突强制提交，但是也只适用于不需要目标版本后面的版本的情况，否则在多人协作的过程，有一个老六使用了这个语句进行版本回退，会造成白打工的情况 2. git revert 参考资料 (70条消息) git 远程仓库回退的两种方式_wangfy_的博客-CSDN博客_git 回退","categories":[{"name":"Git学习笔记","slug":"Git学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"git更新远程仓库代码","slug":"git更新远程仓库代码","date":"2022-09-09T07:13:36.418Z","updated":"2022-09-09T07:13:36.418Z","comments":true,"path":"2022/09/09/git-geng-xin-yuan-cheng-cang-ku-dai-ma/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/git-geng-xin-yuan-cheng-cang-ku-dai-ma/","excerpt":"","text":"git更新远程仓库代码到本地在项目开发的过程中使用git进行版本管理的时候，会有很多人参与开发，或者你在开源仓库中发现了很好的项目并且这个项目还在迭代更新中，，这时候你一开始拉取的版本可能还会存在很多的bug，因此你需要更新一下自己的本地仓库 下面介绍一种方法来达到我们的目的： 1. git pullgit pull的作用是：从远程库中获取某个分支的更新，再与本地指定的分支进行自动merge。完整格式是： git pull &lt;远程库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如：取回远程库中的develop分支，与本地的develop分支进行merge，要写成： git pull origin develop:develop 如果是要与本地当前分支merge，则冒号后面的&lt;本地分支名&gt;可以不写 git pull origin develop 通常，git会将本地库分支与远程分支之间建立一种追踪关系。比如，在git clone的时候，所有本地分支默认与远程库的同名分支建立追踪关系。也就是说，本地的master分支自动追踪origin/master分支。因此，如果当前处于本地develop分支上，并且本地develop分支与远程的develop分支有追踪关系，那么远程的分支名可以省略： git pull origin git pull 命令等同于先做了git fetch ，再做了git merge 2. git fetchgit fetch的作用是：从远程分支拉取代码，当发生远程仓库和本地仓库代码不一致的情况时，直接使用git pull有可能会覆盖本地仓库修改的代码，造成冲突等无法知道，fetch代码下来要git diff orgin/xx来看一下差异然后再合并。 远程跟踪分支已更新(Git术语叫做commit)，需要将这些更新取回本地，这时就要用到 git fetch 语法： git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…]] git fetch [&lt;options&gt;] &lt;group&gt; git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)…] git fetch --all [&lt;options&gt;] 更新远程跟踪分支 git fetch origin 上面命令从远程 refs/heads/ 命名空间复制所有分支，并将它们存储到本地的refs/remotes/origin/命名空间中，除非使用分支 .&lt;name&gt;.fetch 选项来指定非默认的refspec 将某个远程主机的更新 git fetch origin develop 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master分支，就可以用origin/master读取。 更新所有分支 git fetch 明确使用refspec git fetch origin develop:remo_develop 从远程存储库的分支 remo_develop 提取到本地存储库中的 develop 分支中 接下来查看fetch到暂存区的远程分支，使用 git branch -r 查看远程分支 上面命令表示，本地主机的当前分支是main，远程分支是origin/main 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支 git checkout -b newBrach origin/master 或者直接使用merge git merge origin/master 好多人不建议使用git pull，喜欢自己merge，以便万一自动merge出错的时候可以解决冲突","categories":[{"name":"Git学习笔记","slug":"Git学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"git安装及配置","slug":"git安装及配置","date":"2022-09-09T07:13:36.410Z","updated":"2022-09-09T07:13:36.411Z","comments":true,"path":"2022/09/09/git-an-zhuang-ji-pei-zhi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/git-an-zhuang-ji-pei-zhi/","excerpt":"","text":"git安装及配置 本文是介绍下载名为git开源版本控制系统 (VCS) 的工具，通过git命令行配置远程连接上自己的github，以此来达到项目管理、分支开发的目的 1. 下载git工具下载链接 下载之后点击安装，你可以仔细查看每一项安装选择，当然一直点next也可以成功安装，对于初学者而言，建议直接next就完了，不必关注太多安装细节，重点还是在使用它，安装成功之后打开git bash的界面如下 2. 在 Git 中设置用户名首先使用git config 配置git用户信息，git用户信息和github的用户信息是不一样的 为计算机上的每个仓库配置Git用户名 首先打开Git Bash 使用git config --global user.name \"XXXXX\"设置Git用户名 确认正确配置用户名 $git config --global user.name &gt;XXXXX 为一个仓库配置Git用户名 首先打开Git Bash 将当前工作目录更改为您想要在其中配置与 git push 关联的名称的本地仓库 设置 Git 用户名： $ git config user.name \"XXXXX\" 3. 在GitHub中设置提交电子邮件地址GitHub使用Git中设置的电子邮件地址将git push的内容与GitHub帐户关联，如果要对个人电子邮件地址保密，可以使用 GitHub-provided no-reply 电子邮件地址作为提交电子邮件地址。 要将 noreply 电子邮件地址用于从命令行推送的提交，请在 Git 中设置提交电子邮件地址时使用该电子邮件地址，也可以选择阻止从命令行推送的提交显示您的个人电子邮件地址 在GitHub上设置提交电子邮件地址 如果您尚未启用电子邮件地址隐私保护，则在 GitHub 上编辑、删除或创建文件或者合并拉取请求时，可以选择将作者更改提交到哪个经验证的电子邮件地址。 如果您启用了电子邮件地址隐私，则不能更改提交作者电子邮件地址，默认情况下是 &lt;username&gt;@users.norreply.github.com 在任何页面的右上角，单击您的个人资料照片，然后单击 Settings（设置） 在左侧边栏中，单击 Emails（电子邮件） 在“Add email address（添加电子邮件地址）”中，输入您的电子邮件地址，然后单击 Add（添加） 在“Primary email address（主要电子邮件地址）”列表中，选择要与基于 web 的 Git 操作关联的电子邮件地址。 4. 在Git中设置提交电子邮件地址 为每个仓库设置电子邮件地址 git config --global user.name \"XXXXX\" 为一个仓库设置电子邮件地址 git config user.email \"XXXXX\" 自此为止，本地环境上的git的信息已经配置得差不多了，接下来只需要将本地git与远程的GitHub连接起来 5. 通过SSH连接 生成密钥（SSH key） ssh-keygen -t rsa -C \"your_email@youremail.com\" ​ 将生成的密钥添加至GitHub，即.ssh/id_rsa.pub中内容全部复制。在github的 Settings–&gt;SSH and GPG keys–&gt;New SSH key，key中粘贴复制的内容(Title自定义)。 接下来检验一下是否成功连接 ssh -T git@github.com 接下来你就可以将本地项目通过Git push到GitHub上面进行管理了","categories":[{"name":"Git学习笔记","slug":"Git学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Git分支开发","slug":"Git分支开发","date":"2022-09-09T07:13:36.402Z","updated":"2022-09-09T07:13:36.403Z","comments":true,"path":"2022/09/09/git-fen-zhi-kai-fa/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/git-fen-zhi-kai-fa/","excerpt":"","text":"分支开发1）创建分支git checkout -b dev git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令 2）提交内容（add + commit + push）这一步和常规的单分支开发一样，只不过是将文件add到该分支上，然后提交该分支罢了 git add . git commit -m '提交的备注信息' git push -u origin dev 3）将dev分支新增文件合并到main分支如果分支开发完毕，就可以将分支开发的内容合并到主分支main上 首先切换到主分支main上，如果是多人开发的话，需要先把远程main分支上的代码同步一下 git pull origin main 切换到main分支 git checkout main 合并dev分支 git merge dev 然后查看状态及执行提交命令 git status git push origin main 4）如果不需要dev分支继续开发，则可以把dev分支删除git branch -d dev 5）如果不需要远程分支也可以把远程分支给删掉 参考资料 [如何选择 Git 分支模式？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/158463879#:~:text=develop 分支保证的是开发集成中最新的版本。 Git-Flow 引入了一种叫做 hotfix,的分支，专门用于线上缺陷的修复。 当缺陷修复完，再集成到 develop 分支，及同步到 master。)","categories":[{"name":"Git学习笔记","slug":"Git学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"使用gcc编译的指令格式","slug":"使用gcc编译的指令格式","date":"2022-09-09T07:13:36.396Z","updated":"2022-09-09T07:13:36.396Z","comments":true,"path":"2022/09/09/shi-yong-gcc-bian-yi-de-zhi-ling-ge-shi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/shi-yong-gcc-bian-yi-de-zhi-ling-ge-shi/","excerpt":"","text":"使用gcc编译源文件的指令格式 我们都知道源程序想要变成可执行程序首先需要将源程序进行编译，经过编译之后源程序变成目标代码文件，也就是机器能看得懂机器代码，这就是编译器的作用，将高级语言转化为机器代码。目标代码文件还需要经过链接器，使得该源文件中导入的文件得以链接起来，这就是实现多文件开发的原因 1. gcc的功能而gcc就是一个编译器，里面包含了编译和链接的过程，可以实现将源文件转换为可执行文件的过程，gcc的基本用法为：gcc [options] [filenames]，其中options就是编译器所需要的参数，filenames给出相关的文件名称。不同的参数实现不同的功能，参数如下： options 描述 -c 只编译，不链接成为可执行文件，编译器只是由输入的.c等源代码文件生成.o为后缀的目标文件，通常用于编译不包含主程序的子程序文件 -o output_filename，确定输出文件的名称为output_filename，同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出预设的可执行文件a.out -g 产生符号调试工具（GNU的gdb）所必要的符号资讯，要想对源代码进行调试，我们就必须加入这个选项 -O 比-O更好的优化编译、链接，当然整个编译、链接过程会更慢 -I[dirname] 将dirname所指出的目录加入到程序头文件目录列表中，是在预编译过程中使用的参数。C程序中的头文件包含两种情况∶其中，A类使用尖括号（&lt; &gt;），B类使用双引号（“ ”）。对于A类，预处理程序cpp在系统预设包含文件目录（如/usr/include）中搜寻相应的文件，而B类，预处理程序在目标文件的文件夹内搜索相应文件。 -v gcc执行时执行的详细过程，gcc及其相关程序的版本号 -MM 编译器自动找出该.c编译成.o文件所需的依赖关系\\ -Wl,[options] 把参数[options]传递给链接器ld，如果[options]中间有逗号，就将[options]分成多个选项，然后传递给链接程序 -l 指定所要链接的动态链接库，如果编译选项加入了-static则表示寻找静态链接库，例如：CFLAGS += -lstdc++，则在lib路径中寻找名叫libstdc++的动态链接库，注意这里的lib路径不一定是当前库的lib文件夹，可能是标准库的lib文件夹，这就交给编译器去寻找，一般是向上寻找 -L 指定链接的第三方库所在的目录 -Wall 编译后显示所有警告 -D 定义宏，这种在编译器定义的宏变量也可以写在源代码文件.c当中，一般在编译器中定义的宏都是比较重要的宏变量 2. gcc遵循的基本规则gcc所遵循的部分约定规则： .c为后缀的文件，C语言源代码文件； .a为后缀的文件，是由目标文件构成的档案库文件； .C，.cc或.cxx 为后缀的文件，是C++源代码文件且必须要经过预处理； .h为后缀的文件，是程序所包含的头文件； .i 为后缀的文件，是C源代码文件且不应该对其执行预处理； .ii为后缀的文件，是C++源代码文件且不应该对其执行预处理； .m为后缀的文件，是Objective-C源代码文件； .mm为后缀的文件，是Objective-C++源代码文件； .o为后缀的文件，是编译后的目标文件； .s为后缀的文件，是汇编语言源代码文件； .S为后缀的文件，是经过预编译的汇编语言源代码文件","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言预编译指令","slug":"C语言预编译指令","date":"2022-09-09T07:13:36.390Z","updated":"2022-09-09T07:13:36.391Z","comments":true,"path":"2022/09/09/c-yu-yan-yu-bian-yi-zhi-ling/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-yu-bian-yi-zhi-ling/","excerpt":"","text":"预处理1. 什么是预处理？预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程，这个过程并不对程序的源代码进行解析，但它把源代码分割或处理成为特定的单位——预处理记号(preprocessing token)用来支持语言特性（如宏调用） 最常见的预处理是C语言和C++语言。预处理器在UNIX传统中通常缩写为PP，在自动构建脚本中C预处理器被缩写为CPP的宏指代。为了不造成歧义，C++(cee-plus-plus) 经常并不是缩写为CPP，而改成CXX 2. 为什么需要预处理？ISO规定程序由源代码被翻译分为若干有序的阶段，C语言中常见的预处理指令在前面已经介绍过了，而预处理指令一般被用来使源代码在不同的执行条件下可以高效的编译源代码，因为预处理器会先编译器一步进行工作，而它会对#开头的指令先进行判断，从而达到优化编译源代码的作用 参考资料 C语言预编译指令在看别人的工程源码的时候，经常会看到#ifdef在C语言的工程中出现，还有类似如：#undef，#define，#if，#ifndef，#else，#elif，#endif等不同的指令，这些指令叫做预处理指令，现在就来看看这些指令是什么意思吧 1. 条件编译 可以使用这些指令告诉编译器根据编译时的条件执行或忽略信息块 #ifdef、#else、#endif这三条指令是连在一起使用的，表示的是：如果使用#define定义了某个标识符的时候就执行……，否则执行……，例如： #ifdef PRINT printf(\"hello world!\");//如果定义了PRINT宏执行 #else printf(\"Hello world123\");//没有定义PRINT宏执行 #endif 也就是说如果预处理器已定义标识符PRINT，则执行#ifdef PRINT部分的代码，如果没有定义则执行#else部分的代码，它和C语言中的if和else很像，不同就在于：预处理器不识别标记块的花括号。这些指令结构可以嵌套 也可以使用if defined(xxx)来代替ifdef xxx ifndefifndef其实和ifdef相似只不过表示的逻辑是相反的，这是用于包含多个头文件的时候，可能这些头文件有相同的宏定义，ifndef可以防止相同的宏被重复定义。在首次定义一个宏的头文件中使用ifndef指令激活定义，随后在其他文件中的定义都被忽略 #if和#elif#if和if指令很像，#if后面跟的是整形常量表达式，然后判断表达式的真假 #if SYS == 1 #include \"ibmpc.h\" #elif SYS == 2 #include \"vax.h\" #elif SYS == 3 #include \"mac.h\" #else #include \"general.h\" #endif 2. #define和#undef #define（符号常量）定义格式为#define 宏名 替换体（有无都可以） 带参的宏定义 #define 宏名(参数表) 替换体 C语言允许宏带有参数。在宏定义中的参数称为形式参数，在宏调用中的参数称为实际参数。对带参数的宏，在调用中，不仅要宏展开，而且要用实参去代换形参。 普通的宏定义 #define 宏名 替换体 #define通常用来定义的是常量，但是它还有其他用法，它的替换体可以是字符串或者是函数调用 例如： #define PX printf(\"X is %d\\n\",x) int x = 2; PX; x = 3; PX; 两个都是调用了PX这个宏，但是输出的结果是完全不相同的 #define是我们很熟悉的一条宏定义指令，在C语言的初始学习就学了两个指令一个是#include和#define，在我看来这两条指令干的事其实是一样的，一个是将以.h开头的文件替换到#include的位置，而#define则是定义一个标识符（也可以叫做变量），在代码中引用改变量的时候实际上是用该变量定义的值来替换该变量所在的位置 需要注意的是：#define定义的标识符和const定义的标识符都称为常量，而数据类型定义的标识符则称为变量，从C预处理器的角度来看就是（#define是在预处理阶段起作用的，因此没有const的事），#define定义的标识符会被预处理器定义的，而不是被#define定义的标识符则预处理器不会去定义，因此还需要给变量进行赋值才可以使用 #undef#undef用于“取消”已定义的#define指令，例如： #define LIMIT 400 #undef LIMIT 这时就可以将LIMIT重新定义为一个新值，从而达到修改常量的目的，#define的作用域从声明或不同文件的#include位置开始到文件末尾或者是#undef的位置为止 2. 预定义宏 宏 描述 __DATE__ 当前源文件的编译日期，用 “Mmm dd yyy”形式的字符串常量表示 __FILE__ 当前源文件的名称，用字符串常量表示 __LINE__ 当前源义件中的行号，用十进制整数常量表示，它可以随#line指令改变 __TIME__ 当前源文件的最新编译吋间，用“hh:mm:ss”形式的字符串常量表示 __STDC__ 如果当前编译器符合ISO标准，那么该宏的值为1，否则未定义 __STDC_VERSION__ 如果当前编译器符合C89，那么它被定义为199409L;如果符合C99，那么它被定义为199901L:在其他情况下，该宏为宏定义 __STDC_HOSTED__ (C99)如果当前是宿主系统，则该宏的值为1;如果当前是独立系统，则该宏的值为0 __STDC_IEC_559__ (C99)如果浮点数的实现符合IEC 60559标准时，则该宏的值为1，否则为未定义 __STDC_IEC_559_COMPLEX__ (C99)如果复数运算实现符合IEC60559标准时，则该宏的值为1,否则为未定义 __STDC_ISO_10646__ (C99 )定义为长整型常量，yyyymmL表示wchai_t值遵循ISO 10646标准及其指定年月的修订补充，否则该宏为未定义 注意：__func__也是一个经常使用的预定义标识符，但是这个标识符不是预定义宏，它是一个表示函数名的字符串，这是官方C99标准定义的，但是ISO C++却不完全支持所有的C99扩展，因此，大多数的编译器提供商都使用__FUNCTION__取而代之，而__FUNCTION__通常是一个定义为__func__的宏 1. #line和#error #line#line能重置__LINE__和__FILE__宏报告的行号和文件名，例如： #line 1000 //设置当前行号为1000 #line 10 \"cool.c\" //设置当前行号为10，文件名重置为\"cool.c\" #error#error指令能让预处理器发出一条信息，该消息包含指令中的文本，例如： #if __STDC_IEC_559__ != 201112L #error Not C11 #endif 2. #pragma#pragma用于调用编译器的指令集 暂时不深入了解，用到再看，应该涉及编译原理部分的知识会用得上","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言知识点","slug":"C语言知识点","date":"2022-09-09T07:13:36.384Z","updated":"2022-09-09T07:13:36.384Z","comments":true,"path":"2022/09/09/c-yu-yan-zhi-shi-dian/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-zhi-shi-dian/","excerpt":"","text":"C语言“大杂烩”1. 结构体存储空间大小的计算结构体内存大小的计算要遵循字节对齐原则： 结构体变量的存储空间的大小能被其最宽基本类型成员的大小所整除； 结构体每个成员相对于结构体存储空间大小的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后填充字节 例如下面定义两个结构体： struct { char a; short b; char c; }S1; struct { char a; char b; short c; }S2; sizeof(S1)=6 sizeof(S2)=4 为什么交换顺序后结构体的存储空间会改变呢？首先要知道结构体根据顺序存储成员，来分配存储空间解： （1）首先找出成员变量中最大的字节，可见对于 S1 和 S2 最大是 short ，占 2 个字节； （2）所以以后都已2个字节为准，也就是说最多只要2个字节，其他填充占位，注意下图一个格子表示一个字节； （3）所以先画2个格子，以后看成员顺序，逐次增加，每次一2为增加基准 对于S1来说 ，顺序是char-&gt;short-&gt;char 第一个char占一个字节 多的这个补0，只是占位作用 short刚好占2个字节 第二个char也占1个字节 多的这个补0 所以对于 S1 结构体大小为 2*3=6，至于为什么第二个 char，多的那个字节不丢掉，就是遵循第三个原则，就是结构体大小结果要为成员中最大字节的整数倍。 对于S2，顺序是char-&gt;char-&gt;short 第一个char占一个字节 第二个char占一个字节 short刚好占2个字节 所以S2的结构体大小就是2*2 2. 快速排序快速排序的思想是：分治法+挖坑填数基本思想是： 先从数列中取出一个数作为基准数。 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 再对左右区间重复第二步，直到各区间只有一个数。 以一个数组为例，取区间的第一个数为基数。 0 1 2 3 4 5 6 7 8 9 72 6 57 88 60 42 83 73 48 85 初始时，i=0，j=9，X=a[i]=72 由于已经将a[0]中的数保存到X中，可以理解为在数组a[0]上挖了个坑，可以将其他数据填充到这来 从j开始向前找一个比X小或等于X的数，当j=8时，符合条件，将a[8]挖出来再填到上一个坑a[0]中。即a[0]=a[8]；接着执行i++ 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，接下来要再找一个数来填充a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]；接着执行j– 数组变为： 0 1 2 3 4 5 6 7 8 9 ==48== 6 57 ==88== 60 42 83 73 ==88== 85 i=3；j=7；X=72 再重复上述的步骤，先从后向前找，在从前向后找。 从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]；i++； 从i开始向后找，当i=5时，由于i==j退出。 此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。 数组变为： 0 1 2 3 4 5 6 7 8 9 48 6 57 42 60 72 83 73 88 85 可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了 对挖坑填数进行总结： i =L; j = R; 将基准数挖出形成第一个坑a[i]。 j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。 i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。 再重复执行2，3二步，直到i==j，将基准数填入a[i]中。 代码实现 void quick_sort(int *a,int l, int r) { int i, x, j; x = a[l]; i = l; j = r; int flag = 0; if (i &lt; j) { while (i != j) { while (a[j] &gt;= x &amp;&amp; flag == 0) { j--; if (i == j) { flag = 1; } } a[i] = a[j]; while (a[i] &lt;= x &amp;&amp; flag == 0) { i++; if (i == j) { flag = 1; } } a[j] = a[i]; } a[i] = x; quick_sort(a, l, i - 1); quick_sort(a, i + 1, r); } } 冒泡排序的时间复杂度是 $\\boldsymbol{O(n^2)}$ 快速排序的时间复杂度是 $\\boldsymbol{O(n*logn)}$ 3.顺序存储结构和链式存储结构区别 链表存储结构的内存地址不一定是连续的，但顺序存储结构一定是连续的； 链式存储适用于在较频繁地插入、删除、更新元素时，而顺序存储结构适用于频繁查询时使用。 空间上：顺序比链式节约空间，是因为链式结构每一个节点都有一个指针存储域 存储操作上：顺序支持随机存取，方便操作 插入和删除上：链式的要比顺序方便，顺序的存储结构插入的空间复杂度要不链式的要大，因为顺序表索引到相应的位置时，要将后面的元素后移，而链表可以直接插入 4.循环链表实现约瑟夫环‘#include &lt;stdio.h&gt;’ ‘#include &lt;stdlib.h&gt;’ typedef struct node{ int num; struct node *next; }Node; Node* initLink(int n); Node* game(Node *head); Node* initLink(int n) { int i; Node *temp=NULL,*head=NULL, *p=NULL; for(i=1;i&lt;=n;i++) { p =(Node*)malloc(sizeof(Node)); p-&gt;num=i; p-&gt;next = NULL; if(i==1) { temp=p; head=p; } else{ temp-&gt;next=p; temp=p; } } p-&gt;next=head; return head; } Node* game(Node *head) { Node *temp1=NULL,*temp2=NULL; temp1=head; while(temp1!=temp1-&gt;next) { for(int i=1;i&lt;3;i++) { temp2=temp1; temp1=temp1-&gt;next; } temp2-&gt;next=temp1-&gt;next; free(temp1); temp1=temp2-&gt;next; } return temp2; } int main() { int n; scanf(\"%d\",&amp;n); Node *head,*s; head = initLink(n); s = game(head); printf(\"%d\",s-&gt;num); } 5.KMP算法实现子串搜索 常规的子串搜索","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言的枚举类型","slug":"C语言的枚举类型","date":"2022-09-09T07:13:36.376Z","updated":"2022-09-09T07:13:36.377Z","comments":true,"path":"2022/09/09/c-yu-yan-de-mei-ju-lei-xing/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-de-mei-ju-lei-xing/","excerpt":"","text":"C语言的枚举类型 枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读 1. 定义和声明枚举类型的格式定义格式： enum 枚举名 {枚举元素1,枚举元素2,……}; 声明枚举类型变量： 枚举名 变量名 注意：此时变量只能赋值为枚举类型中的其中一个，也就是{枚举元素1,枚举元素2,……}中的一个 2. 枚举类型的特点在第一个枚举元素的后面的每个枚举元素都在前面元素的基础上加1，如果第一个枚举类型没有初始化，则第一个枚举元素默认为0 初始化的过程是在枚举类型定义的时候，可以对任意枚举元素进行初始化，初始化元素后面的枚举元素在初始化元素的基础上进行加1 例如： enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; 此时TUE, WED, THU, FRI, SAT, SUN分别是2，3，4，5，6，7又例如： enum season {spring, summer=3, autumn, winter}; 此时spring为0，autumn, winter分别为4，5 3. 枚举类型的遍历在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。但是枚举类型的遍历是有条件的，枚举元素的值必须是必须连续才能遍历 参考资料","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言的优先级","slug":"C语言的优先级","date":"2022-09-09T07:13:36.370Z","updated":"2022-09-09T07:13:36.371Z","comments":true,"path":"2022/09/09/c-yu-yan-de-you-xian-ji/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-de-you-xian-ji/","excerpt":"","text":"C语言中的运算符有逻辑运算符、算术运算符，关系运算符，位运算符 自增和自减运算符有前置和后置的说法，前置说明先加一再赋值，后置说明先赋值再加一。 逻辑运算符于关系运算符返回的是布尔值的结果。 按位与运算是对两个二进制数字相应位置进行判断，当对应位置上的两个数都是1则结果在该位上的数值也为1，否则为0。 按位异或运算是对两个二进制数字相应位置上的数进行判断，当对应位置上的两个数相同时，则结果在该位上的数字为0，否则为1。 在二进制中为了区别正负数，在二进制的前面加一位符号位，符号位为0表示这个数为正数，符号位为1表示这个数为负数。原码一个整数，按照绝对值大小转换成的二进制数，称为原码。反码将二进制数按位取反，所得到的新的二进制数称为原二进制的反码补码反码加1称为补码","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言文件操作函数","slug":"C语言文件操作函数","date":"2022-09-09T07:13:36.365Z","updated":"2022-09-09T07:13:36.365Z","comments":true,"path":"2022/09/09/c-yu-yan-wen-jian-cao-zuo-han-shu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-wen-jian-cao-zuo-han-shu/","excerpt":"","text":"文件操作函数1. open 函数原型 int open(const char * pathname, int flags); int open(const char * pathname, int flags, mode_t mode); 函数说明 互斥flags O_RDONLY以只读方式打开文件 O_WRONLY以只写方式打开文件 O_RDWR以可读写方式打开文件 创建文件 O_CREAT若欲打开的文件不存在则自动建立该文件 O_NOCTTY如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机 O_SYNC以同步的方式打开文件 返回值 若所有欲核查的权限都通过了检查则返回0值, 表示成功, 只要有一个权限被禁止则返回-1 2. close 函数原型 int close(int fd); 函数说明当使用完文件后若已不再需要则可使用close()关闭该文件，close()会让数据写回磁盘，并释放该文件所占用的资源，虽然在进程结束时，系统会自动关闭已打开的文件，但仍建议自行关闭文件，并确实检查返回值 参数fd为先前由open()或creat()所返回的文件描述词 返回值：若文件顺利关闭则返回0, 发生错误时返回-1","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言引用","slug":"C语言引用","date":"2022-09-09T07:13:36.358Z","updated":"2022-09-09T07:13:36.358Z","comments":true,"path":"2022/09/09/c-yu-yan-yin-yong/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-yin-yong/","excerpt":"","text":"C语言中的引用—&amp;","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言工程的链接","slug":"C语言工程的链接","date":"2022-09-09T07:13:36.352Z","updated":"2022-09-09T07:13:36.353Z","comments":true,"path":"2022/09/09/c-yu-yan-gong-cheng-de-lian-jie/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-gong-cheng-de-lian-jie/","excerpt":"","text":"链接在工程中作用 在前面已经介绍了很多关于C语言的编译过程，但是编译的操作只是将.c源代码文件变成一个后缀为.o或.obj的目标文件，然而在一个C语言的工程中，包含了很多.c和.h文件，要想让整个项目能运行起来，就必须将这些源文件链接起来，链接主要是链接函数和全局变量 工程构成的流程图： 可以看到由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File），也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。 编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于链接来说，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中） 只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（.o 文件或 .obj 文件），因此可以使用这些中间目标文件（.o 文件或 .obj 文件）来链接组成我们的应用程序，也就是可执行文件。总的来说：源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。 在编译时，编译器只检测程序语法和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error） 对于大型的C语言工程来说，编译和链接一般都会写在Makefile里面，方便控制整个工程的流程","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言宏定义中的##和#的作用","slug":"C语言宏定义中的##和#的作用","date":"2022-09-09T07:13:36.346Z","updated":"2022-09-09T07:13:36.347Z","comments":true,"path":"2022/09/09/c-yu-yan-hong-ding-yi-zhong-de-he-de-zuo-yong/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-hong-ding-yi-zhong-de-he-de-zuo-yong/","excerpt":"","text":"宏定义中#和##的作用1. ##的作用##在宏定义中起到连接的作用，一般是将两个参数连接起来 #define test(param1,param2)(param1##param2) 输出结果为两个变量连接起来 2. #的作用将#后面的宏参数进行字符串的操作，即将后面的参数两边加上一对双引号使其成为字符串","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言内存管理函数","slug":"C语言内存管理函数","date":"2022-09-09T07:13:36.340Z","updated":"2022-09-09T07:13:36.340Z","comments":true,"path":"2022/09/09/c-yu-yan-nei-cun-guan-li-han-shu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-nei-cun-guan-li-han-shu/","excerpt":"","text":"内存管理函数 头文件：#include &lt;unistd.h&gt;、 #include &lt;sys/mman.h&gt; 1. munmap 函数原型 int munmap(void *start, size_t length); 函数功能munmap()用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小。如果解除映射成功则返回0，否则返回-1。 2. mmap 函数原型 void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize); 函数功能mmap()用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写 参数 说明 start 指向欲对应的内存起始地址，通常设为NULL，代表让系统自动选定地址，对应成功后该地址会返回 length 代表将文件中多大的部分对应到内存 prot 可选参数：PROT_EXEC ：映射区域可被执行PROT_READ：映射区域可被读取PROT_WRITE：映射区域可被写入PROT_NONE：映射区域不能存取 flags 可选参数：MAP_FIXED如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享MAP_PRIVATE对映射区域的写入操作会产生一个映射文件的复制，即私人的”写入时复制” (copy on write)对此区域作的任何修改都不会写回原来的文件内容MAP_ANONYMOUS建立匿名映射，此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享 fd open()返回的文件描述词，代表欲映射到内存的文件 offset 文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍 3. memset_s 函数原型 errno_t memset_s(void * dest，rsize_t destsz，int ch，rsize_t count); 函数功能与下面的函数功能基本相同，只是在运行时检测到以下错误，并且如果dest和destsz本身有效，则在将ch替换目标范围[dest，dest + destsz) 1. `dest`是一个空指针 2. `destsz`或`count`大于`RSIZE_MAX` 3. `count`大于`destsz`（会发生缓冲区溢出） 4. memset 函数原型 void * memset(void * dest，int ch，size_t count); 函数功能将ch值（在转换为无符号字符后，就像通过（unsigned char）ch）替换dest指向的对象的前count个字符，如果count超出dest数组的末尾，则行为未定义。如果dest是空指针，行为是未定义的。 参考资料 5. memcmp 函数原型 int memcmp (const void *s1, const void *s2, size_t n); 函数功能memcmp()用来比较s1和s2所指的内存区间前n个字符 字符串大小的比较是以ASCII 码表上的顺序来决定，次顺序亦为字符的值。memcmp()首先将s1第一个字符值减去s2第一个字符的值，若差为0则再继续比较下个字符，若差值不为0则将差值返回 6. memcpy 函数原型 void *memcpy(void *dest, const void *src, size_t num); 函数功能memcpy()会复制src所指的内存内容的前num个字节到dest所指的内存地址上，memcpy()并不关心被复制的数据类型，只是逐字节地进行复制，这给函数的使用带来了很大的灵活性，可以面向任何数据类型进行复制 需要注意的是： dest 指针要分配足够的空间，也即大于等于 num 字节的空间。如果没有分配空间，会出现断错误 dest 和 src 所指的内存空间不能重叠（如果发生了重叠，使用 memmove() 会更加安全） 与strcpy()不同的是，memcpy()会完整的复制num个字节，不会因为遇到“\\0”而结束 返回指向dest的指针。注意返回的指针类型是void，使用时一般要进行强制类型转换","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言中系统相关的函数","slug":"C语言中系统相关的函数","date":"2022-09-09T07:13:36.332Z","updated":"2022-09-09T07:13:36.333Z","comments":true,"path":"2022/09/09/c-yu-yan-zhong-xi-tong-xiang-guan-de-han-shu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-zhong-xi-tong-xiang-guan-de-han-shu/","excerpt":"","text":"system 函数原型 int system(const char * command) 函数功能执行 dos(windows系统) 或 shell(Linux/Unix系统) 命令，参数字符串command为命令名。另，在windows系统下参数字符串不区分大小写。 在windows系统中，system函数直接在控制台调用一个command命令。 在Linux/Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行command命令，命令执行完后随即返回原调用的进程 命令执行成功返回0，执行失败返回-1 usleep 函数原型 void usleep(int micro_seconds); 函数功能usleep功能把进程挂起一段时间， 单位是微秒us（百万分之一秒） 这个函数不能工作在 Windows 操作系统中，usleep() 与sleep()类似，用于延迟挂起进程。进程被挂起放到reday queue。只是一般情况下，延迟时间数量级是秒的时候，尽可能使用sleep()函数。且此函数已被废除，可使用nanosleep 如果延迟时间为几十毫秒，或者更小，尽可能使用usleep()函数。这样才能最佳的利用CPU时间 函数实现 static inline int usleep(useconds_t usec) { struct timespec waittime = { .tv_sec = usec / 1000000L, .tv_nsec = (usec % 1000000L) * 1000 }; return nanosleep(&amp;waittime, NULL); }","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言中的联合体","slug":"C语言中的联合体","date":"2022-09-09T07:13:36.327Z","updated":"2022-09-09T07:13:36.327Z","comments":true,"path":"2022/09/09/c-yu-yan-zhong-de-lian-he-ti/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-zhong-de-lian-he-ti/","excerpt":"","text":"union 在C语言中有一种类型和结构体很像，叫做联合体或者叫共用体 1. 语法格式union 共用体名{ 成员列表 }; 共用体也是一种自定义类型，可以通过它来创建变量，例如： union data{ int n; char ch; double f; }; union data a, b, c; 也可以在定义共用体的同时创建变量，如果不再定义新的变量，也可以将共用体的名字省略 union data{ int n; char ch; double f; } a, b, c; 2. 结构体和共用体的区别结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙，存在对齐的现象），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 3. 共用体的应用共用体在一般的编程中应用较少，在单片机中应用较多。","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言中的位域结构体","slug":"C语言中的位域结构体","date":"2022-09-09T07:13:36.321Z","updated":"2022-09-09T07:13:36.321Z","comments":true,"path":"2022/09/09/c-yu-yan-zhong-de-wei-yu-jie-gou-ti/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-zhong-de-wei-yu-jie-gou-ti/","excerpt":"","text":"C语言中的位域结构体示例： #include &lt;iostream&gt; struct test{ uint8_t a:1; uint8_t b:1; uint8_t c:1; uint8_t d:1; uint8_t e:1; uint8_t f:1; uint8_t g:1; uint8_t h:1; }; int main() { uint8_t t=0xf1; uint8_t ky=0; struct test *p=(struct test *)(&amp;t); printf(\"%x \\n\",t); printf(\"%x %x %x %x %x %x %x %x\\n\",p-&gt;h,p-&gt;g,p-&gt;f,p-&gt;e,p-&gt;d,p-&gt;c,p-&gt;b,p-&gt;a); p-&gt;h=0; // p-&gt;b=0B11; // p-&gt;a=0B10; printf(\"%x \\n\",t); printf(\"%x %x %x %x %x %x %x %x\\n\",p-&gt;h,p-&gt;g,p-&gt;f,p-&gt;e,p-&gt;d,p-&gt;c,p-&gt;b,p-&gt;a); memcpy(&amp;ky,p,sizeof(struct test)); printf(\"%x \\n\",ky); std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; return 0; }xxxxxxxxxx&nbsp;#include &lt;iostream&gt;struct test{ &nbsp; &nbsp;uint8_t a:1; &nbsp; &nbsp;uint8_t b:1; &nbsp; &nbsp;uint8_t c:1; &nbsp; &nbsp;uint8_t d:1; &nbsp; &nbsp;uint8_t e:1; &nbsp; &nbsp;uint8_t f:1; &nbsp; &nbsp;uint8_t g:1; &nbsp; &nbsp;uint8_t h:1;};int main() { &nbsp; &nbsp;uint8_t t=0xf1; &nbsp; &nbsp;uint8_t ky=0; &nbsp; &nbsp;struct test *p=(struct test *)(&amp;t); &nbsp; &nbsp;printf(\"%x \\n\",t); &nbsp; &nbsp;printf(\"%x %x %x %x %x %x %x %x\\n\",p-&gt;h,p-&gt;g,p-&gt;f,p-&gt;e,p-&gt;d,p-&gt;c,p-&gt;b,p-&gt;a); &nbsp; &nbsp;p-&gt;h=0;// &nbsp; p-&gt;b=0B11;// &nbsp; p-&gt;a=0B10; &nbsp; &nbsp;printf(\"%x \\n\",t); &nbsp; &nbsp;printf(\"%x %x %x %x %x %x %x %x\\n\",p-&gt;h,p-&gt;g,p-&gt;f,p-&gt;e,p-&gt;d,p-&gt;c,p-&gt;b,p-&gt;a); &nbsp; &nbsp;memcpy(&amp;ky,p,sizeof(struct test)); &nbsp; &nbsp;printf(\"%x \\n\",ky); &nbsp; &nbsp;std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; &nbsp; &nbsp;return 0;}struct test{ &nbsp; &nbsp;uint8_t a:1; &nbsp; &nbsp;uint8_t b:1; &nbsp; &nbsp;uint8_t c:1; &nbsp; &nbsp;uint8_t d:1; &nbsp; &nbsp;uint8_t e:1; &nbsp; &nbsp;uint8_t f:1; &nbsp; &nbsp;uint8_t g:1; &nbsp; &nbsp;uint8_t h:1;};","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言中的static","slug":"C语言中的static","date":"2022-09-09T07:13:36.313Z","updated":"2022-09-09T07:13:36.314Z","comments":true,"path":"2022/09/09/c-yu-yan-zhong-de-static/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-zhong-de-static/","excerpt":"","text":"C 语言中 static 的作用 首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。 1. 隐藏static既可以修饰变量也可以修饰函数，对于变量而言，所有没有用static修饰的变量和函数都称为全局变量，全局变量具有全局可观性，通俗来说就是：具有全局可观性的变量或函数可以被其他文件使用，例如有两个文件： a.c char a = 'A'; // global variable void msg() { printf(\"Hello\\n\"); } main.c int main(void) { extern char a; // extern variable must be declared before use printf(\"%c \", a); (void)msg(); return 0; } 程序运行结果为： A Hello 也就是a.c里面的变量a和函数msg没有使用static修饰对于main.c是可见的，由此可以看见，static的作用是隐藏 static对于函数而言只有隐藏的作用，但是对于变量而言还有以下两个作用 2. 保持变量内容的持久全局变量和静态变量存储在静态数据区，这里的变量在程序刚开始的时候就完成初始化，也是唯一的一次初始化，只不过和全局变量比起来，static 可以控制变量的可见范围 #include &lt;stdio.h&gt; int fun(void){ static int count = 10; // 事实上此赋值语句从来没有执行过 return count--; } int count = 1; int main(void) { printf(\"global\\t\\tlocal static\\n\"); for(; count &lt;= 10; ++count) printf(\"%d\\t\\t%d\\n\", count, fun()); return 0; } global local static 1 10 2 9 3 8 4 7 5 6 6 5 7 4 8 3 9 2 10 1 3. 默认初始化为 0在静态数据区，内存中所有的字节默认值都是 0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置 0，然后把不是 0 的几个元素赋值。如果定义成静态的，就省去了一开始置 0 的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加 \\0 太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是 \\0","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言中的ioctl","slug":"C语言中的ioctl","date":"2022-09-09T07:13:36.307Z","updated":"2022-09-09T07:13:36.308Z","comments":true,"path":"2022/09/09/c-yu-yan-zhong-de-ioctl/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-zhong-de-ioctl/","excerpt":"","text":"ioctlioctl(input/output control)是一个专用于设备输入输出操作的系统调用,该调用传入一个跟设备有关的请求码，系统调用的功能完全取决于请求码，ioctl是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等 1. 函数形式int ioctl(int fd, int cmd, …); fd是用户程序打开设备时使用open函数返回的文件标示符cmd是用户程序对设备的控制命令，一般为函数调用后面的省略号，是一些补充参数，一般最多一个，这个参数的有无和cmd的意义相关例如： #define HI_MIPI_SET_HS_MODE _IOW(HI_MIPI_IOC_MAGIC, 0x0b, lane_divide_mode_t) fd = open(MIPI_DEV_NODE, O_RDWR); lane_divide_mode_t enHsMode; s32Ret = ioctl(fd, HI_MIPI_SET_HS_MODE, &amp;enHsMode); 函数返回是一个表示函数是否起作用的标识（一般是0和1） ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数来控制设备的I/O通道 2. 为什么需要ioctl一个操作系统可以分为两层：一层是用户态层，另一层是内核态层。在前面已经了解过内核态中防止的是什么，这里就不过多赘述，只需要知道内核里的代码是实现资源利用、调度等相关底层功能的，而为了确保系统底层的安全，用户态一般不可以直接访问内核态的资源，例如在传统的操作系统中，如果让操作系统驱动一个外设，用户态会向内核态发出一个请求，这个请求称为系统调用，它的实现代码在内核空间里面，大多数外设只能在内核空间里面直接寻址，因此将大多数标准外设的驱动程序代码都写进了内核中，但是现在外设开发越来越多，内核开发者不可能考虑完全所有的外设，这该怎么办呢？ 不知道这样写对不对，后续待更改！ 内核开发者们就将内核设计成可以扩展的，加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。而ioctl接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通 3. ioctl的作用如果不用ioctl的话，也可以实现对设备I/O通道的控制，但那是蛮拧了。例如，我们可以在驱动程序中实现write的时候检查一下是否有特殊约定的数据流通过，如果有的话，那么后面就跟着控制命令（一般在socket编程中常常这样做）。但是如果这样做的话，会导致代码分工不明，程序结构混乱，程序员自己也会头昏眼花的。所以，我们就使用ioctl来实现控制的功能。==要记住，用户程序所作的只是通过命令码(cmd)告诉驱动程序它想做什么，至于怎么解释这些命令和怎么实现这些命令，这都是驱动程序要做的事情。== 4. ioctl的实现 后面了解 参考文档","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言中的goto语句","slug":"C语言中的goto语句","date":"2022-09-09T07:13:36.301Z","updated":"2022-09-09T07:13:36.301Z","comments":true,"path":"2022/09/09/c-yu-yan-zhong-de-goto-yu-ju/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-zhong-de-goto-yu-ju/","excerpt":"","text":"C语言中的goto语句 goto语句是一种无条件转移语句，在日常使用中不怎么常见，但是在工程代码中确实出现的比较多，比如嵌入式工程代码（或许是嵌入式工程师到老还在工作） 1. 语法格式goto 语句标号; 其中标号是一个有效的标识符，这个标识符加上一个“:”一起出现在函数内某处，执行goto语句后，程序将跳转到该标号处并执行其后的语句 2. goto语句的缺点尽管现在的嵌入式工程代码中还会出现goto语句，但是我想在未来的嵌入式工程代码中，goto会逐渐被取代的，因为因为它将使程序层次不清，且不易读，但是使用goto和条件判断结合，可以实现switch的效果","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言中的extern","slug":"C语言中的extern","date":"2022-09-09T07:13:36.295Z","updated":"2022-09-09T07:13:36.296Z","comments":true,"path":"2022/09/09/c-yu-yan-zhong-de-extern/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-zhong-de-extern/","excerpt":"","text":"C语言中的extern利用关键字extern，可以在一个文件中引用另一个文件中定义的变量或者函数以及引用同一文件中尚未定义的变量或者函数 extern就像提前告诉编译器接下来会有这个变量或者函数，你可以在这里放心使用，从而骗过编译器，但是运行时如果找不到依然会报错 extern需要编译器具有一定的查找策略 extern关键字只需要指明类型和变量名就行了，不能再重新赋值，初始化需要在原文件所在处进行，如果不进行初始化的话，全局变量会被编译器自动初始化为0 1. 引用同一个文件中的变量以及函数#include &lt;stdio.h&gt; int main() { extern int num; extern int print(); print(); printf(\"%d\",num); return 0; } int num = 10; int print() { printf(\"Hello World!\\n\"); return 0; } 2. 引用不同文件中的变量以及函数//main.c #include &lt;stdio.h&gt; int main() { extern int num; extern int print(); print(); printf(\"%d\",num); return 0; } //Another_file.c int num = 10; int print() { printf(\"Hello World!\\n\"); return 0; }","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C语言中的#include","slug":"C语言中的#include","date":"2022-09-09T07:13:36.290Z","updated":"2022-09-09T07:13:36.290Z","comments":true,"path":"2022/09/09/c-yu-yan-zhong-de-include/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-yu-yan-zhong-de-include/","excerpt":"","text":"C语言中的#include #include起到的功能其实和#define大体上是相同的，都是用其他内容来替换#include或#define的位置，但是#define和#include不同就在于：内容的多少，#include的内容可以放在.h为后缀的文件中，因此替换的内容就很多了 1. #include的格式#include有两种表现形式：一种是文件名在尖括号中，如：#include&lt;stdio.h&gt;；另外一种则是文件名在双引号中，如：#include \"hello_world.h\" 这两种形式有什么不一样呢？ 在UNIX系统中，尖括号告诉预处理器在标准系统目录中寻找文件 在UNIX系统中，双引号告诉预处理器首先在当前工作目录中寻找文件，若未找到再去找标准系统目录 那么什么是标准系统目录呢？ 在我看来应该是把相应的SDK的bin目录配置进入环境变量，使得编译器能够快速的寻找到相应的.h文件 2. .h文件以.h为后缀的文件，通常称为头文件，这些头文件的信息包含了源代码文件（.c）开发所需的一些预处理指令、函数声明、宏定义等等，大部分的C语言函数库都是以.h文件的形式给出 头文件中一般包含： 明示常量：使用#define声明的变量 宏函数：将函数定义为带参数的宏的形式 函数声明：为了告诉.c文件，该函数存在，但函数体可能在其他地方 结构定义：例如结构体、枚举类型等信息 类型定义：定义相应类型的变量 为了避免多重#include同一个文件的错误，应该使用条件编译指令#ifndef、#ifdef、#define等来作为条件 3. 头文件和库文件的区别在很多的互联网企业中，会提供企业相应产品开发的SDK，同时会给出该SDK的开发文档，开发者需要根据开发文档去使用相应的API接口，但是当开发者想查看相应的API接口的时候，却发现在工程中找不到该API接口的源代码，只能找到这个函数声明的.h文件，但是调用开发文档上的API接口却是可以实现该API的功能的，这是为什么呢？ 这就是因为企业开发了SDK之后，为了保护自己的开发代码的核心技术，不愿意将API的源代码开放给开发者学习，因此将SDK的开发代码编译成为.a或.so文件，这些文件经过编译成为二进制也就是常说的机器代码，我们开发者很难理解的代码。这也是对知识产权的一种保护，想要看一个公司SDK的源代码？那就努力成为这个公司的员工即可 头文件中包含了SDK中API的函数声明，而SDK的API确实被编译成为库文件了，那么在调用API的时候程序如何找到相对应的库文件呢？ 用户想要调用库文件中的API只需要将包含相应的API的函数声明的头文件.h文件通过#include导入到当前工程下，而企业开发者已经将这些包含相应的API的函数声明的头文件.h通过连接的方式与相应的库文件链接起来了，因此就可以实现调用的目的 文件与库文件链接，应该属于操作系统部分的知识，而库文件也分为动态链接库、静态链接库 参考文档参考文档","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C库函数-signal()","slug":"C库函数-signal()","date":"2022-09-09T07:13:36.283Z","updated":"2022-09-09T07:13:36.283Z","comments":true,"path":"2022/09/09/c-ku-han-shu-signal/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-ku-han-shu-signal/","excerpt":"","text":"C库函数-signal() 这是C语言的处理信号的一个库函数，用于执行C语言中的事件触发函数，例如C++的QT中的槽函数和信号的绑定，但是QT中的信号可以自己编写，这个函数的信号却是定下来的，且以宏的形式给出来，signal.h可能还定义了其它信号，这依赖于具体实现。信号如下所示： 宏 信号意义 SIGABRT (Signal Abort) 程序异常终止。 SIGFPE (Signal Floating-Point Exception) 算术运算出错，如除数为 0 或溢出（不一定是浮点运算）。 SIGILL (Signal Illegal Instruction) 非法函数映象，如非法指令，通常是由于代码中的某个变体或者尝试执行数据导致的。 SIGINT (Signal Interrupt) 中断信号，如 ctrl-C，通常由用户生成。 SIGSEGV (Signal Segmentation Violation) 非法访问存储器，如访问不存在的内存单元。 SIGTERM (Signal Terminate) 发送给本程序的终止请求信号。 可以看到上面的大部分的信号都是出现很底层的错误，或者中断请求等操作系统级的通信信号，这是未来什么呢？ 这些信号可以作为进程之间通信的信息，用来报告程序是否出现异常行为，从而使开发者能把握程序的进行，从另一个角度来看也可以作为一种异常处理的手段 #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; void sighandler(int); int main() { signal(SIGINT, sighandler); while(1) { printf(\"开始休眠一秒钟...\\n\"); sleep(1); } return(0); } void sighandler(int signum) { printf(\"捕获信号 %d，跳出...\\n\", signum); exit(1); } 这将产生以下结果，且程序会进入无限循环，需使用 CTRL + C 键跳出程序。 开始休眠一秒钟... 开始休眠一秒钟... 开始休眠一秒钟... 开始休眠一秒钟... 开始休眠一秒钟... 捕获信号 2，跳出... 其中signal()的第二个参数，可以是SIG_DFL(默认的信号处理程序)和SIG_IGN(忽视信号) 参考资料","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"","slug":"#define和const的区别","date":"2022-09-09T07:13:36.276Z","updated":"2022-09-09T07:13:36.276Z","comments":true,"path":"2022/09/09/define-he-const-de-qu-bie/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/define-he-const-de-qu-bie/","excerpt":"","text":"","categories":[{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C++编译错误笔记","slug":"[error]C++编译错误笔记","date":"2022-09-09T07:13:36.270Z","updated":"2022-09-09T07:13:36.270Z","comments":true,"path":"2022/09/09/error-c-bian-yi-cuo-wu-bi-ji/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/error-c-bian-yi-cuo-wu-bi-ji/","excerpt":"","text":"开发C++项目中遇到的一些问题1. Process finished with exit code -1073741819 (0xC0000005)问题描述应该是属于空指针错误，我在类中定义的是 QSerialPort *serial; QTimer *timer; 这时候只是声明了一个指向这种类型的指针变量，但是这个指针变量一开始指向的是空指针，还需要进行实例化，如果没有进行实例化，而将该指针变量作为参数传入其他调用函数中，就会发生空指针错误 解决办法serial = new QSerialPort(); timer = new QTimer(); 为什么QT工程中都是定义对象指针而不是直接定义对象 参考资料 2. Process finished with exit code -1073741515 (0xC0000135)问题描述缺少dll 解决办法看用到什么库，就把相应的dll移入运行目录，同时修改cmakelist 3. Process finished with exit code -1073741701 (0xC000007B)问题描述64位操作系统使用了32位的dll 解决办法找到正确的dll，移入运行目录","categories":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"error","slug":"error","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/error/"}]},{"title":"C++中调用C语言","slug":"[C++进阶知识]C++中调用C语言","date":"2022-09-09T07:13:36.261Z","updated":"2022-09-09T07:13:36.262Z","comments":true,"path":"2022/09/09/c-jin-jie-zhi-shi-c-zhong-diao-yong-c-yu-yan/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-jin-jie-zhi-shi-c-zhong-diao-yong-c-yu-yan/","excerpt":"","text":"[C++进阶知识]——C++和C相互调用在C++开发中，有时候会需要用到C语言写的一些库，尤其在嵌入式开发中经常可以看到这样的代码 #ifdef __cplusplus #if __cplusplus extern \"C\" { #endif #endif /* End of #ifdef __cplusplus */ ...... #ifdef __cplusplus #if __cplusplus } #endif #endif /* End of #ifdef __cplusplus */ __cplusplus是cpp中自定义的一个宏 毕竟C语言才是更接近底层的，调用起底层硬件资源更加快捷，extern \"C\" {}里面的代码就是用C语言写的代码 按道理来说，C语言算是C++的老大哥了，这两个语言应该是兼容的才对，为什么还要用这种写法呢？因为这两种语言的编译规则是不一样的，但是因为这两个语言的关系太密切了，C++的编译器也是懂得编译C语言的，只需要使用extern \"C\"{}告诉编译器，这部分的代码用C语言的方式编译它们 1. C++调用CC语言中不能使用extern \"C\" //test.c #include &lt;stdio.h&gt; void mytest() { printf(\"mytest in .c file ok\\n\"); } //main.cpp extern \"C\" { void mytest(); } int main() { mytest(); return 0; } 2. C调用C++C++的函数或变量要定义在extern \"C\"{}里 //test.cpp #include &lt;stdio.h&gt; extern \"C\" { void mytest() { printf(\"mytest in .cpp file ok\\n\"); } } //main.c void mytest(); int main() { mytest(); return 0; } 3. 综合使用由于无法确定所写的函数是否会被C或者C++调用，因此就有了开头的那段代码 #ifdef __cplusplus #if __cplusplus extern \"C\" { #endif #endif /* End of #ifdef __cplusplus */ ...... #ifdef __cplusplus #if __cplusplus } #endif #endif /* End of #ifdef __cplusplus */ 这样所写的函数既可以被C语言调用，也可以被C++调用","categories":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++进阶知识","slug":"C-进阶知识","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}]},{"title":"C++多线程","slug":"[C++多线程编程]C++多线程","date":"2022-09-09T07:13:36.255Z","updated":"2022-09-09T07:13:36.255Z","comments":true,"path":"2022/09/09/c-duo-xian-cheng-bian-cheng-c-duo-xian-cheng/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-duo-xian-cheng-bian-cheng-c-duo-xian-cheng/","excerpt":"","text":"[C++多线程编程]——多线程多线程是多任务处理的一种特殊的形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。 基于进程的多任务处理是程序的并发执行 基于线程的多任务处理是同一程序的片段的并发执行 参考资料 C++ 多线程 | 菜鸟教程 (runoob.com)","categories":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++多线程编程","slug":"C-多线程编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"}]},{"title":"：：和：的意义","slug":"[C++基础知识]：：和：的意义","date":"2022-09-09T07:13:36.248Z","updated":"2022-09-09T07:13:36.248Z","comments":true,"path":"2022/09/09/c-ji-chu-zhi-shi-he-de-yi-yi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-ji-chu-zhi-shi-he-de-yi-yi/","excerpt":"","text":"[C++基础知识]——::和:的意义1. 意义::： 类作用域操作符 Student::study(); 表示study()是类Student的成员函数 引用成员函数及变量 Student::id; id是类Student的变量 :： 表示机构内位域的定义（即该变量占几个bit空间） typedef struct _XXX{ unsigned char a:4; unsigned char c; }; XXX 构造函数后加冒号是初始化表达式 #include &lt;iostream&gt; #include &lt;string&gt; class Student { public: int _age; std::string _name; Student(int age, std::string p):_age(age),_name(p){} }; int main() { Student stu(18,\"jf\"); std::cout&lt;&lt;stu._age&lt;&lt;\"name\"&lt;&lt;stu._name&lt;&lt;std::endl; } public:和private:后面的冒号，表示后面定义的所有成员都是公有或私有的，直到下一个”public:”或”private:”出现为止。”private:”为默认处理。 类名冒号后面的是用来定义类的继承 class 派生类名 : 继承方式 基类名 { 派生类的成员 }; 参考资料 (70条消息) c++中“::”和“:”啥意思_魏波-的博客-CSDN博客_c++中:是什么意思","categories":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"类的构造函数","slug":"[C++基础知识]类的构造函数","date":"2022-09-09T07:13:36.242Z","updated":"2022-09-09T07:13:36.242Z","comments":true,"path":"2022/09/09/c-ji-chu-zhi-shi-lei-de-gou-zao-han-shu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-ji-chu-zhi-shi-lei-de-gou-zao-han-shu/","excerpt":"","text":"[C++基础知识]——类的构造函数每个类都定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数 构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。 1. 默认构造函数如果类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。这个由编译器创建的构造函数称为默认构造函数 1）编译器不能为某些类创建默认构造函数的情况 如果类中包含一个其它类类型的成员且这个成员的类型没有默认构造函数，则编译器无法初始化该成员 编译器创建的默认构造函数可能执行错误的操作，含有内置类型或复合类型（如数组和指针）的对象被默认初始化，则它们的值将是未定义的，这些未定义的值可能会执行错误的操作 不具有灵活性，假如在某种情况下需要控制对象初始化，那么这个类很可能在所有情况下都需要控制 2. 定义构造函数#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Student { public: string m_name; int m_age; float m_score; public: Student(); //~Student();//析构函数 }; //定义构造函数 Student::Student() { m_name = \"jf\"; m_age = 19; m_score = 100; } int main() { Student student; cout&lt;&lt;student.m_name&lt;&lt;endl; cout&lt;&lt;student.m_age&lt;&lt;endl; cout&lt;&lt;student.m_score&lt;&lt;endl; } 3. 带参数的构造函数默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示： #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Student { public: string m_name; int m_age; float m_score; public: Student(string name,int age,float score); //~Student();//析构函数 }; //定义带参数的构造函数 Student::Student(string name,int age,float score) { m_name = name; m_age = age; m_score = score; } int main() { Student student(\"jf\",19,100); cout&lt;&lt;student.m_name&lt;&lt;endl; cout&lt;&lt;student.m_age&lt;&lt;endl; cout&lt;&lt;student.m_score&lt;&lt;endl; } 4. 使用构造函数初始值列表来初始化字段#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Student { public: string m_name; int m_age; float m_score; public: Student(string name,int age,float score); //~Student();//析构函数 }; //使用构造函数初始值列表来初始化字段 Student::Student(string name,int age,float score):m_name{name},m_age{age},m_score{score} { } int main() { Student student(\"jf\",19,100); cout&lt;&lt;student.m_name&lt;&lt;endl; cout&lt;&lt;student.m_age&lt;&lt;endl; cout&lt;&lt;student.m_score&lt;&lt;endl; } 把新出现的部分称为称为初始值列表，构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来（或者在花括号内的）的成员初始值，不同成员的初始化通过逗号分隔开 5. 析构函数类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。 析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Student { public: string m_name; int m_age; float m_score; public: Student(); ~Student();//析构函数 }; //定义构造函数 Student::Student() { m_name = \"jf\"; m_age = 19; m_score = 100; } Student::~Student() { cout &lt;&lt; \"Object is being deleted\" &lt;&lt; endl; } int main() { Student student; cout&lt;&lt;student.m_name&lt;&lt;endl; cout&lt;&lt;student.m_age&lt;&lt;endl; cout&lt;&lt;student.m_score&lt;&lt;endl; }","categories":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"类的定义和使用","slug":"[C++基础知识]类的定义和使用","date":"2022-09-09T07:13:36.234Z","updated":"2022-09-09T07:13:36.235Z","comments":true,"path":"2022/09/09/c-ji-chu-zhi-shi-lei-de-ding-yi-he-shi-yong/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-ji-chu-zhi-shi-lei-de-ding-yi-he-shi-yong/","excerpt":"","text":"[C++基础知识]——类的定义和使用1. 定义类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；创建对象的过程也叫类的实例化。每个对象都是类的一个具体实例（Instance），拥有类的成员变量和成员函数。与结构体一样，==类==只是一种复杂数据类型的声明，==不占用内存空间==。而==对象==是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以==占用内存空间==。 代码形式： class 类名{ 访问范围说明符： 成员变量1 成员变量2 成员函数声明1 成员函数声明2 访问范围说明符： 更多成员变量 更多成员函数声明 ... }; 1.访问范围说明符: public：表示类的成员变量或成员函数具有“公开”的访问权限 private：表示类的成员变量都是私有的，不能在类外通过类的对象直接访问 protected：类的成员变量在类外也不能通过对象访问，但是在它的派生类内部可以访问 在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员 使用访问范围说明符起到了封装类的作用 例子： #include &lt;iostream&gt; using namespace std; //类的声明 class Student{ private: //私有的 char *m_name; int m_age; float m_score; public: //共有的 void setname(char *name); void setage(int age); void setscore(float score); void show(); }; //成员函数的定义 void Student::setname(char *name){ m_name = name; } void Student::setage(int age){ m_age = age; } void Student::setscore(float score){ m_score = score; } void Student::show(){ cout&lt;&lt;m_name&lt;&lt;\"的年龄是\"&lt;&lt;m_age&lt;&lt;\"，成绩是\"&lt;&lt;m_score&lt;&lt;endl; } int main(){ //在栈上创建对象 Student stu; stu.setname(\"小明\"); stu.setage(15); stu.setscore(92.5f); stu.show(); //在堆上创建对象 Student *pstu = new Student; pstu -&gt; setname(\"李华\"); pstu -&gt; setage(16); pstu -&gt; setscore(96); pstu -&gt; show(); return 0; } 运行结果： 小明的年龄是15，成绩是92.5 李华的年龄是16，成绩是96 若想修改类的私有成员变量，可以通过类中对外开放的（public）的成员函数接口，来对类的私有变量进行修改，也就是set()和get()方法，这样体现了类的封装特性。（如果既不写 private 也不写 public，就默认为 private） 2. 成员函数定义方法 内联函数 指在类声明中包含类成员函数的定义，这样的函数称为内联函数. 内联函数提供了在类声明中包含函数信息的便捷方式，但只能在函数体非常短（通常是单行）时使用。 #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; //Circle class declaration class Circle { private: double radius; public: void setRadius(double r) { radius = r; } double getArea() { return 3.14 * pow(radius, 2); } }; 定义为常规函数 使用作用域解析运算符（:: 符号）指示这些是类成员函数，并且告诉编译器它们属于哪个类，这样就可以将类成员函数的定义放在类的声明外面 void Circle::setRadius(double r) { radius = r; } double Circle::getArea() { return 3.14 * pow(radius, 2); } 1. 内联函数详解 在设计一个类时，将需要确定哪些成员函数在类声明中作为内联函数来编写，哪些函数在类之外定义。编译器对内联函数的处理方式与常规函数完全不同，了解这种差异将有助于程序员决定使用这两种函数的时机。 每次调用常规函数时，都会在幕后进行许多操作。一些特殊的项目，如函数执行完成时返回的地址和函数实参的值，都必须存储在名为栈（Stack）的内存部分中；另外，还需要创建局部变量并保留一个位置来保存函数的返回值。所有这些函数调用阶段的设置开销都会占用 CPU 时间，虽然所需的时间很小，但是如果一个函数被调用多次（例如在某个循环中），那么它是会被累加的。 另一方面，内联函数根本不是传统意义上的内联，相反，在所谓内联扩展的过程中，编译器将使用函数本身的实际代码替换对函数的每次调用。这意味着，如果从程序中的多个地方调用该函数，则其代码的整个主体将被多次插入，从而增加程序的大小，这就是为什么只有寥寥几行代码的函数才能写成一个内联函数。 实际上，如果函数太大而使得内联扩展不可行，那么编译器将忽略以这种方式处理函数的请求。但是，当一个成员函数很小的时候，把它写成一个内联函数确实可以提高性能，因为当没有进行实际的函数调用时，它的开销更少。 2. this指针类的每个成员函数中都有一个隐藏的参数this，成员函数通过this指针访问调用它的那个对象，因此在成员函数内部可以直接使用this指针指向的对象的成员，无需通过成员访问运算符来实现 对象在调用成员函数的时候将自身的地址传入this指针中 #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; //Circle class declaration class Circle { private: double radius; public: void setRadius(double r) { radius = r; } double getArea() { return 3.14 * pow(radius,2); } double getRadius() { //返回调用对象的radius成员变量 return this-&gt;radius; } }; int main() { Circle circle; circle.setRadius(3); cout&lt;&lt;circle.getRadius(); } 3. const成员函数常量成员函数 不懂它的作用在哪，先不学了 4. 定义一个返回this对象的函数 不懂它的作用在哪，先不学了 5. 定义类相关的非成员函数","categories":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"基本数据类型","slug":"[C++基础知识]基本数据类型","date":"2022-09-09T07:13:36.226Z","updated":"2022-09-09T07:13:36.228Z","comments":true,"path":"2022/09/09/c-ji-chu-zhi-shi-ji-ben-shu-ju-lei-xing/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-ji-chu-zhi-shi-ji-ben-shu-ju-lei-xing/","excerpt":"","text":"[C++基础知识]——基本数据类型在C语言的学习过程中，我们知道C语言中有int、float、double、char还有空类型void，以及无符号数的标识unsigned和有符号数的标识signed，还有声明数据空间的长类型long和短类型short 1. C++作为C语言的高级语言，在数据类型上和C语言相比之下有什么区别？实际上C++也就是在C的基础上增加了bool表示布尔值的数据类型，以及wchar_t表示宽字符，char16_t和char32_t表示Unicode字符只是一个表示16个位另一个表示32个位。 为什么除了char之外还要引入这些数据类型？因为这些数据类型是用于扩展字符集而产生的，wchar_t可以存放机器最大扩展字符集中的任意一个字符，char16_t和char32_t则是为unicode字符集服务的 而且在C语言和C++中char可以分为：char,unsigned char,signed char三种，需要注意的是char和signed char是不一样的，因为尽管字符型有3种表现形式，但是字符的表现形式只有两种：unsigned char和signed char，char会表现为这两种中的某一种，具体是哪一种需要由编译器来决定 2. C++数据类型的内存C++和C作为一门对内存有严格要求的语言，那就要说说数据类型的字节大小，在C++或C中int类型的字节大小都会随着计算机的位数的不同字节数也会不相同，C++规定一个int至少和一个short一样大小，一个long至少和一个int一样大，一个long long至少和一个long一样大，所以每种类型都会有最小尺寸的说法： 类型 最小尺寸 bool 未定义 char 8位 wchar_t 16位 char16_t 16位 char32_t 32位 short 16位 int 16位 long 32位 long long 64位 float 6位有效数字 double 10位有效数字 long double 10位有效数字","categories":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"动态内存分配","slug":"[C++基础知识]动态内存分配","date":"2022-09-09T07:13:36.221Z","updated":"2022-09-09T07:13:36.221Z","comments":true,"path":"2022/09/09/c-ji-chu-zhi-shi-dong-tai-nei-cun-fen-pei/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-ji-chu-zhi-shi-dong-tai-nei-cun-fen-pei/","excerpt":"","text":"[C++基础知识]——动态内存分配C++ 程序中的内存分为两个部分： 栈：在函数内部声明的所有变量都将占用栈内存 堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存 1. 为什么需要动态内存分配？在C++程序中，所有内存需求都是在程序执行之前通过定义所需的变量来确定的。但是很多时候，你无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。例如：当需要的内存取决于用户输入。 在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。 如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存 2. new和delete抽象格式： new data-type; 在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作： double* pvalue = NULL; if( !(pvalue = new double )) { cout &lt;&lt; \"Error: out of memory.\" &lt;&lt;endl; exit(1); } new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。 3. 数组的动态内存分配一维数组： char* pvalue = new char[20]; // 为变量请求内存 delete [] pvalue; // 删除 pvalue 所指向的数组 二维数组： int **array // 假定数组第一维长度为 m， 第二维长度为 n // 动态分配空间 array = new int *[m]; for( int i=0; i&lt;m; i++ ) { array[i] = new int [n] ; } //释放 for( int i=0; i&lt;m; i++ ) { delete [] array[i]; } delete [] array; 4. 对象的动态内存分配对象和内置数据类型没什么不同，对象可以是类或结构在内的用户自定义的任何数据类型或包括数组在内的任意内置的数据类型 下面以类作为对象举例： class Object { …… …… } int main() { Object *myObject = new Object(); return ; } 顺便说一下对象指针的使用，在开发C++项目的时候，你会经常看到对象指针的出现，但是除了定义对象指针之外还是可以直接定义对象： class Object { …… …… } int main() { Object myObject; return ; } 使用动态分配的对象与直接定义的对象的区别？两种分配对象方式的主要区别在于对象的生存期。 通过 Object myObject 方式定义对象，对象的生存期是在其作用域内自维护（automatic storage），这个意味着程序离开对象的作用域之后，对象将被自动销毁。 当通过 new Object() 方式分配对象时，对象的生存期是动态的，这个意味着若不显式地 detete 对象，对象将一直存在。你应该只在必要的时候使用动态分配对象。换句话说，只要有可能，你应该首选定义可自维护的对象。 需要动态分配对象的情况： 分配不限制作用域的对象 对象存储在其特定的内存中，而不是在内存中存储对象的拷贝。如果对象是可以拷贝/移动的，一般情况下你应该选择使用定义对象的方式。 定义的对象会消耗大量内存，这时可能会耗尽栈空间。 如果我们永远不需要考虑这个问题那该多好（实际大部分情况下，我们真不需要考虑），因为这个本身已经超出 C++ 语言的范畴，但不幸的是，在我们实际的开发过程中却不得不去处理这个问题。 使用引用语义（reference semantics）的情况 使用多态的情况 对于入参对象可选的情况 通过解耦编译类型依赖减少编译时间的情况 与C库或C风格的库交互的情况 上面几种情况都需要将对象定义为对象指针的形式在进行动态分配，既动态分配new返回的是一个指针 Object *myObject = new Object(); 用对象指针的好处？ 可以动态创建和删除控件 可以动态申请和释放内存 可以把声明和定义分开（头文件和源文件） 参考资料： C++ 动态内存 | 菜鸟教程 (runoob.com) [(68条消息) 【C++】动态内存分配详解（new/new]和delete/delete[]）_GeekBuilding的博客-CSDN博客_c++动态内存分配","categories":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"explicit关键字","slug":"[C++关键字]explicit关键字","date":"2022-09-09T07:13:36.214Z","updated":"2022-09-09T07:13:36.214Z","comments":true,"path":"2022/09/09/c-guan-jian-zi-explicit-guan-jian-zi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-guan-jian-zi-explicit-guan-jian-zi/","excerpt":"","text":"[C++关键字]——关键字1. explicit基本概念将构造函数显示声明出来，表示该构造函数是显式的而不是隐式的，即该构造函数不能用于隐式转换和复制初始化 注意： explicit修饰的构造函数只对一个实参的构造函数有效，如果构造函数有多个参数，则不可以用explicit修饰 explicit修饰的构造函数只能直接初始化 explicit只能出现在类内的构造函数中 class Student { public: char *_name; int _age; int _id; //第一个构造函数 Student(int age) { _age = age; } //第二个构造函数 Student(char *p) { _name = p; } //第三个构造函数 Student(char *p, int age, int id) { _age = age; _name = p; _id = id; } }; int main() { Student stu1(18);//调用的是第一个构造函数，成功 Student stu2(\"jf\");//调用的是第二个构造函数，成功 Student stu3(\"jf\",18,2100720205);//调用的是第三个构造函数，成功 //Student stu4;//失败，因为没有默认的构造函数 stu1 = 19; stu2 = \"lbl\"; } 当然对象的初始化有不同的方式，但是在这里暂时不深入讲解，接下来我们有请出今天的主角explicit，对代码进行修改一下 class Student { public: char *_name; int _age; int _id; //第一个构造函数 explicit Student(int age) { _age = age; } //第二个构造函数 explicit Student(char *p) { _name = p; } //第三个构造函数 Student(char *p, int age, int id) { _age = age; _name = p; _id = id; } }; int main() { Student stu1(18);//调用的是第一个构造函数，成功 Student stu2(\"jf\");//调用的是第二个构造函数，成功 Student stu3(\"jf\",18,2100720205);//调用的是第三个构造函数，成功 //Student stu4;//失败，因为没有默认的构造函数 //stu1 = 19;//失败，因为explicit修饰的函数只能直接初始化也就是上面的情形，这种属于拷贝初始化 //stu2 = \"lbl\";//失败，因为explicit修饰的函数只能直接初始化也就是上面的情形，这种属于拷贝初始化 } 但是, 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数, 例子如下: 2. 为什么需要explicit？Effective C++中也写道: 被声明为explicit的构造函数通常比其 non-explicit 兄弟更受欢迎, 因为它们禁止编译器执行非预期 (往往也不被期望) 的类型转换. 除非我有一个好理由允许构造函数被用于隐式类型转换, 否则我会把它声明为explicit. 我鼓励你遵循相同的政策. 由此可见explicit是用来防止类发生我们不期望的隐式类型转换，而导致的一些难以预料的错误，所以对于类而言，你想构造什么类，就需要在开发的时候想好，然后使用 explicit 修饰起来","categories":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++关键字","slug":"C-关键字","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"constexpr关键字","slug":"[C++关键字]constexpr关键字","date":"2022-09-09T07:13:36.207Z","updated":"2022-09-09T07:13:36.207Z","comments":true,"path":"2022/09/09/c-guan-jian-zi-constexpr-guan-jian-zi/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/c-guan-jian-zi-constexpr-guan-jian-zi/","excerpt":"","text":"[C++关键字]——constexpr关键字1. constexpr关键字的概念constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。 C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。 注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。 2. constexpr关键字的作用constexpr 的主要用处有 拓宽「常量表达式」的范围 提供显式「要求」表达式编译时（compile-time）求值的方法 目前还无法理解 3. constexpr关键字的使用1） constexpr修饰普通变量C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。 值得一提的是，使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子： #include &lt;iostream&gt; using namespace std; int main() { constexpr int num = 1 + 2 + 3; int url[num] = {1,2,3,4,5,6}; couts&lt;&lt; url[1] &lt;&lt; endl; return 0; } //程序执行结果为： //2 如果不加 constexpr 的话，会发生编译报错提示“url[num] 定义中 num 不可用作常量” 此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。 2) constexpr修饰函数constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。 换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件： 整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句 错误代码： constexpr int display(int x) { int ret = 1 + 2 + x; return ret; } 正确代码： constexpr int display(int x) { //可以添加 using 执行、typedef 语句以及 static_assert 断言 return 1 + 2 + x; } 该函数必须有返回值，即函数的返回值类型不能是 void 因为通过类似的函数根本无法获得一个常量。 函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。 #include &lt;iostream&gt; using namespace std; //普通函数的声明 int noconst_dis(int x); //常量表达式函数的声明 constexpr int display(int x); //常量表达式函数的定义 constexpr int display(int x) { return 1 + 2 + x; } int main() { //调用常量表达式函数 int a[display(3)] = { 1,2,3,4 }; cout &lt;&lt; a[2] &lt;&lt; endl; //调用普通函数 cout &lt;&lt; noconst_dis(3) &lt;&lt; endl; return 0; } //普通函数的定义 int noconst_dis(int x) { return 1 + 2 + x; } //程序执行结果为： //3 //6 return 返回的表达式必须是常量表达式 #include &lt;iostream&gt; using namespace std; int num = 3; constexpr int display(int x) { return num + x; } int main() { //调用常量表达式函数 int a[display(3)] = { 1,2,3,4 }; return 0; } 常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。 注意，在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的，感兴趣的读者可自行尝试编码测试。 3) constexpr修饰类的构造函数对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。 错误代码： #include &lt;iostream&gt; using namespace std; //自定义类型的定义 constexpr struct myType { const char* name; int age; //其它结构体成员 }; int main() { constexpr struct myType mt { \"zhangsan\", 10 }; cout &lt;&lt; mt.name &lt;&lt; \" \" &lt;&lt; mt.age &lt;&lt; endl; return 0; } 正确代码： #include &lt;iostream&gt; using namespace std; //自定义类型的定义 struct myType { constexpr myType(char *name,int age):name(name),age(age){}; const char* name; int age; //其它结构体成员 }; int main() { constexpr struct myType mt { \"zhangsan\", 10 }; cout &lt;&lt; mt.name &lt;&lt; \" \" &lt;&lt; mt.age &lt;&lt; endl; return 0; } //程序执行结果为： //zhangsan 10 当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数 注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。 constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件 #include &lt;iostream&gt; using namespace std; //自定义类型的定义 class myType { public: constexpr myType(const char *name,int age):name(name),age(age){}; constexpr const char * getname() { return name; } constexpr int getage() { return age; } private: const char* name; int age; //其它结构体成员 }; int main() { constexpr struct myType mt { \"zhangsan\", 10 }; constexpr const char * name = mt.getname(); constexpr int age = mt.getage(); cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; age &lt;&lt; endl; return 0; } //程序执行结果为： //zhangsan 10 注意，C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。 4) constexpr修饰模板函数C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。 针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。 #include &lt;iostream&gt; using namespace std; //自定义类型的定义 struct myType { const char* name; int age; //其它结构体成员 }; //模板函数 template&lt;typename T&gt; constexpr T dispaly(T t) { return t; } int main() { struct myType stu{\"zhangsan\",10}; //普通函数 struct myType ret = dispaly(stu); cout &lt;&lt; ret.name &lt;&lt; \" \" &lt;&lt; ret.age &lt;&lt; endl; //常量表达式函数 constexpr int ret1 = dispaly(10); cout &lt;&lt; ret1 &lt;&lt; endl; return 0; } //程序执行结果为： //zhangsan 10 //10 模板函数的内容还没了解过 示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求： 当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的； 模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。 参考资料: C++：constexpr - 知乎 (zhihu.com) (5 封私信 / 80 条消息) constexpr究竟有什么用？ - 知乎 (zhihu.com)","categories":[{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++关键字","slug":"C-关键字","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"Atlas200DK环境部署","slug":"[环境部署]Atlas200DK环境部署","date":"2022-09-09T07:13:36.199Z","updated":"2022-09-09T07:13:36.200Z","comments":true,"path":"2022/09/09/huan-jing-bu-shu-atlas200dk-huan-jing-bu-shu/","link":"","permalink":"https://selamangit.github.io/ZaNot.github.io/2022/09/09/huan-jing-bu-shu-atlas200dk-huan-jing-bu-shu/","excerpt":"","text":"Atlas 200 DK环境部署(1.0.12.alpha)操作步骤： 准备一台Atlas200dk所需的配件和一台PC机 SD卡烧录Atlas 200 DK可用的操作系统及固件 配置Atlas 200 DK的网络连接，使得Atlas 200 DK可与用户PC机通信，同时可通过相关配置将Atlas 200 DK接入互联网 安装CANN相关软件，部署好开发运行环境 CANN软件有两种部署场景： 1. 准备配件和PC机及开发环境的搭建配件的话就要看个人需求了，但是SD卡和USB-typeC的串口线是必须要有的 准备一个操作系统为Ubuntu X86架构的PC机，版本可以为：18.04.4、18.04.5，我选择的是Ubuntu18.04.4通过Vmware安装虚拟机，下载链接如下： http://old-releases.ubuntu.com/releases 这是为了制作Atlas 200 DK的系统启动盘以及通过该PC用SSH连接Atlas 200 DK，用该PC机作为开发环境，用于进行应用程序的开发及编译 接下来是环境的一些软件的准备 1）安装开发环境依赖这里就不介绍虚拟机的安装的相关操作了，重点关注在虚拟机系统的用户权限配置和源配置 用户权限配置 切换为root用户 su root 给sudoer文件配置写权限，并打开该文件 chmod u+w /etc/sudoers 打开/etc/sudoers，加入下面的内容 hispark处填写你的用户名 系统源配置（这里就不过多阐述） 建议配置中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse pip源配置 exit，切换为普通用户 创建.pip mkdir $HOME/.pip/ 打开.pip/pip.conf文件 sudo vi $HOME/.pip/pip.conf 填写下面的内容 [global] timeout = 6000 index-url = http://mirrors.aliyun.com/pypi/simple/ trusted-host = mirrors.aliyun.com 安装相关apt依赖 普通用户下安装 sudo apt-get install -y gcc make cmake unzip zlib1g zlib1g-dev libsqlite3-dev openssl libssl-dev libffi-dev pciutils net-tools g++-5-aarch64-linux-gnu MindStudio所需的依赖 sudo apt-get install -y gcc g++ make cmake zlib1g-dev libbz2-dev libsqlite3-dev libssl-dev libffi-dev unzip pciutils net-tools libblas-dev gfortran libblas3 liblapack-dev openssh-server xterm firefox xdg-utils libdbus-glib-1-dev gdb 安装python环境 进入普通用户家目录 cd $HOME 下载python3.7.5源码包并解压 wget https://www.python.org/ftp/python/3.7.5/Python-3.7.5.tgz tar -zxvf Python-3.7.5.tgz 进入解压后的文件夹，执行配置、编译和安装命令 cd Python-3.7.5 ./configure --prefix=/usr/local/python3.7.5 --enable-shared make -j8 sudo make install 设置python3.7.5环境变量 #用于设置python3.7.5库文件路径 export LD_LIBRARY_PATH=/usr/local/python3.7.5/lib:$LD_LIBRARY_PATH #如果用户环境存在多个python3版本，则指定使用python3.7.5版本 export PATH=/usr/local/python3.7.5/bin:$PATH 执行以下命令将so拷贝到lib中，并设置软链接 sudo cp /usr/local/python3.7.5/lib/libpython3.7m.so.1.0 /usr/lib sudo ln -s /usr/local/python3.7.5/bin/python3 /usr/bin/python3 sudo ln -s /usr/local/python3.7.5/bin/pip3 /usr/bin/pip3 sudo ln -s /usr/local/python3.7.5/bin/python3 /usr/bin/python3.7 sudo ln -s /usr/local/python3.7.5/bin/pip3 /usr/bin/pip3.7 sudo ln -s /usr/local/python3.7.5/bin/python3 /usr/bin/python3.7.5 sudo ln -s /usr/local/python3.7.5/bin/pip3 /usr/bin/pip3.7.5 注意：有可能你的系统已经下载过python3.X的版本，此时你的pip3和python3的已经链接到之前的python3.X的版本上，你需要先rm删除掉原本的软链在重新链接 查看一下python3和pip3的版本 python3 --version pip3 --version 执行以下命令，安装环境所需的相关pip依赖 pip3 install attrs psutil decorator numpy protobuf==3.11.3 scipy sympy cffi grpcio grpcio-tools requests --user 安装前建议pip3 install –upgrade pip进行升级，避免因pip版本过低导致安装失败，更新之后的pip3下载过程是真的好看 2） 安装toolkit开发工具包下载开发环境所需要的两个toolkit包： Ascend-cann-toolkit_5.0.5.alpha001_linux-x86_64.run（X86_64） Ascend-cann-toolkit_5.0.5.alpha001_linux-aarch64.run(ARM) 去找到相应版本的安装包安装之后，通过直接拖入虚拟机的方式上传到虚拟机的/home/hispark/ascend/ascend-toolkit文件夹（用户名要换成自己的） （这个图显示是错误的，我后面换toolkit包了） 给run包加可执行权限 chmod +x *.run 校验安装包的一致性和完整性 ./Ascend-cann-toolkit_{version}_linux-x86_64.run --check ./Ascend-cann-toolkit_{version}_linux-aarch64.run --check 执行以下命令，安装toolkit包 ./Ascend-cann-toolkit_{version}_linux-x86_64.run --install --chip=Ascend310-minirc ./Ascend-cann-toolkit_{version}_linux-aarch64.run --install --chip=Ascend310-minirc –chip=Ascend310-minirc：指定芯片型号为Ascend310 Soc芯片（RC模式启动，作为主控CPU）配置了此参数，则会部署Ascend310RC形态的AI CPU软件包 –blacklist=nnae：安装时屏蔽离线推理、在线推理、训练及IR构图的部分特性，即不安装FwkACLlib组件 使用自定义路径安装 ./Ascend-cann-toolkit_{version}_linux-x86_64.run --install --install-path={path} ./Ascend-cann-toolkit_{version}_linux-aarch64.run --install --install-path={path} 其中{path}为指定的安装路径，请用户先创建文件夹自行替换 如果要删除的话，使用删除指令 ./Ascend-Toolkit-{你的包版本}.run --uninstall ./Ascend-Toolkit-{你的包版本}.run --uninstall 如果你安装失败的话，在这里你可能需要改一下python3和pip3的软链，总的来说需要见招拆招，根据报错去修改 rm -rf /usr/bin/pip3 ln -s /usr/local/python3.7.5/bin/pip3.7 /usr/bin/pip3 (82条消息) 【问题解决】subprocess.CalledProcessError: Command ‘(‘lsb_release‘, ‘-a‘)‘ returned non-zero exit status 1_丨匿名用户丨的博客-CSDN博客_subprocess.calledprocesserror 配置交叉编译环境，因为开发环境与运行环境的架构不同，所以需要在开发环境安装交叉编译工具 先在开发环境执行如下指令，看看是否已安装g++交叉编译器 aarch64-linux-gnu-g++ --version 若未出现回显，则执行 sudo apt-get install g++-aarch64-linux-gnu CANN软件提供进程级环境变量设置脚本，供用户在进程中引用，以自动完成环境变量设置。用户进程结束后自动失效（1.0.12） . /home/HwHiAiUser/Ascend/ascend-toolkit/set_env.sh 用户也可以通过修改~/.bashrc文件方式设置永久环境变量 用户也可以通过修改~/.bashrc文件方式设置永久环境变量，在文件最后一行后面添加上述内容 执行**:wq!**命令保存文件并退出 执行source ~/.bashrc命令使其立即生效 3） 安装Media 模块若你需要使用Atlas 200 DK外接摄像头采集的数据作为AI应用数据源，需要额外在开发环境中部署应用程序编译所依赖的头文件与库文件 开发者板驱动包:A200dk-npu-driver-{software version}-ubuntu18.04-aarch64-minirc.tar.gz 其中包含OS外围软件、AI软件栈、维测相关软件及驱动固件信息，制作SD卡时，会从驱动包中获取固件信息，不需要单独获取固件包。 操作步骤： “产品系列”请选择“AI开发者套件” “产品型号”请选择“Atlas 200 DK开发者套件” “固件与驱动版本”：选择“1.0.12.alpha” 可以看到驱动固件的版本配套说明 4） 安装mindstudio下载链接：MindStudio下载-昇腾社区 (hiascend.com) 同样的，下载好之后直接拖入虚拟机的文件夹中 因为采用的是纯开发场景部署 该场景下纯开发环境需要安装MindStudio和Ascend-cann-toolkit 要求MindStudio安装服务器环境下的Ascend-cann-toolkit开发套件包版本需要和运行环境下的CANN软件包版本保持一致 MindStudio安装服务器环境的gcc版本不能高于运行环境的gcc版本，否则有可能影响功能正常运行 准备安装用户 检查root用户的umask 如果umask不等于0022，请执行如下操作配置，在该文件的最后一行添加umask 0022后保存 vi ~/.bashrc 执行source ~/.bashrc命令使其立即生效 安装MindStudio 进入存放tar.gz压缩包的目录，并解压 tar -zxvf {安装包名字} 解压jbr至MindStudio安装根目录 推荐使用11_0_10b1341.35版本的jbr，下载链接请根据操作系统架构选择 x86_64链接：https://cache-redirector.jetbrains.com/intellij-jbr/jbr_dcevm-11_0_10-linux-x64-b1341.35.tar.gz aarch64链接：https://cache-redirector.jetbrains.com/intellij-jbr/jbr-11_0_10-linux-aarch64-b1341.35.tar.gz 进入bin目录，运行MindStudio ./Mindstudio.sh 导入设置选择Do not import settins 要求选择toolkit路径，选择对应路径即可 2. 搭建运行环境我选择读卡器制作，但是Atlas 200 DK也提供了无读卡器下的方案 1）软件准备Ubuntu操作系统镜像包：ubuntu-18.04.xx-server-arm64.iso 注意：为ARM版本的Server软件包。 去Index of /releases/18.04.4 (ubuntu.com)找到相应的镜像下载 2）制卡 在用户PC机中执行如下命令安装qemu-user-static、binfmt-support、yaml、squashfs-tools与交叉编译器，执行如下指令： sudo pip3 install pyyaml sudo apt-get install qemu-user-static binfmt-support python3-yaml squashfs-tools gcc-aarch64-linux-gnu g++-aarch64-linux-gnu 创建制卡工作目录 mkdir $HOME/mksd 将软件包准备获取的Ubuntu操作系统镜像包、开发者板驱动包上传到制卡工作目录中（例如：“$HOME/mksd”） 在制卡工作目录下，获取制卡脚本，make_sd_card.py 从gitee下载: wget https://gitee.com/ascend/tools/raw/master/makesd/generic_script/make_sd_card.py 从github下载： wget https://raw.githubusercontent.com/Ascend/tools/master/makesd/generic_script/make_sd_card.py 在制卡工作目录下，获取制作SD卡操作系统的脚本，make_ubuntu_sd.sh 从gitee下载： wget https://gitee.com/ascend/tools/raw/master/makesd/generic_script/make_ubuntu_sd.sh 从github下载： wget https://raw.githubusercontent.com/Ascend/tools/master/makesd/generic_script/make_ubuntu_sd.sh 执行制卡脚本 先将插有SD卡的读卡器插入PC，使用fdisk -l来查找SD卡所在的USB设备名称 例如，SD卡所在USB设备名称为“/dev/sda”，可通过插拔SD卡的方式确定设备名称 运行SD制卡脚本“make_sd_card.py” sudo python3 make_sd_card.py local /dev/sda “local”表示使用本地方式制作SD卡 “/dev/sda”为SD卡所在的USB设备名称 制卡成功后，将SD卡从读卡器取出并插入Atlas 200 DK开发者板卡槽 上电Atlas 200 DK开发者板 插上Atlas上电后，一会亮两个灯，一会亮三个灯，一会亮两个灯闪两个灯，一会亮一个灯，过一段时间（大概五分钟左右）会四个灯全亮，四个灯全亮就说明启动成功了。 检查指示灯的状态，确保Atlas 200 DK开发者板上电正常（主板名称为IT21VDMB） 注意： Atlas 200 DK制卡后，首次上电启动过程中会进行固件的升级，升级完成后会自动进行重启的操作，重启后再进行其他组件的安装。 首次启动Atlas 200 DK开发者板时不能断电，以免对Atlas 200 DK开发者板造成损害，再次上电需与上次下电时间保持2S以上的安全时间间隔。 3）配置网络连接Atlas 200 DK提供了USB网卡和NIC网卡，其中USB网卡的默认IP地址为“192.168.1.2”，NIC网卡的默认IP地址为“192.168.0.2”，用户可以通过这两个网卡实现与PC机的通信，并把Atlas 200 DK接入互联网 Atlas 200 DK的网络连接配置有以下两种方式： 通过NIC接口连接路由器 使用USB方式将Atlas 200 DK连接用户PC机，使得可以在PC机上SSH登录到Atlas 200 DK；使用网线将Atlas 200 DK接入路由器的网口，通过配置NIC网卡将Atlas 200 DK接入互联网 通过网络共享方式接入互联网 通过USB-typeC的串口线连接Atlas 200 DK和PC Atlas 200 DK的USB网卡的默认IP地址为192.168.1.2，所以需要修改Ubuntu虚拟机的USB虚拟网卡的IP地址为192.168.1.x（x取值范围为01，3254)，使Atlas 200 DK与Ubuntu虚拟机可以通信 说明: 您可以通过修改“make_sd_card.py”中的如下参数配置Atlas 200 DK的USB网卡IP与NIC网卡IP。 “NETWORK_CARD_DEFAULT_IP”：NIC网卡的IP地址，默认值“192.168.0.2”。 “USB_CARD_DEFAULT_IP”：USB网卡的IP地址，默认值“192.168.1.2”。 因为我的Ubuntu系统是通过Windows主机上的虚拟机进行安装的场景，需要在Windows主机上安装USB网卡驱动，否则虚拟机上的Ubuntu系统无法识别Atlas 200 DK的USB网卡，参考：如何安装windows的USB网卡驱动 假设您已经通过USB连接线将Atlas 200 DK与PC机的USB接口进行连接，操作步骤如下： 通过脚本配置 新建一个config_usb_ip目录： mkdir config_usb_ip 从gitee下载： wget https://gitee.com/ascend/tools/raw/master/configure_usb_ethernet/for_20.1/configure_usb_ethernet.sh 须知： 通过脚本配置仅针对首次配置USB网卡对应IP地址的场景。USB网卡IP已经配置，若需要修改其IP地址，请参考手工配置修改USB网卡的IP地址 以root用户执行如下命令进行USB网卡IP地址的配置，以指定的IP地址配置Ubuntu虚拟机中USB网卡的静态IP地址 bash configure_usb_ethernet.sh -s ip_address 如果直接执行bash configure_usb_ethernet.sh，则以默认IP地址“192.168.1.166”进行配置。 手工配置 切换到root用户 su 获取USB网卡名，可通过插拔来确定 ifconfig -a 在“/etc/netplan/01-netcfg.yaml”文件中添加USB网卡的静态IP vim /etc/netplan/01-netcfg.yaml 在ethernets层下增加USB网卡网络配置，例如USB网卡名为enp0s20f0u4，配置静态IP为192.168.1.223，配置方法如下： ethernets: ... enp0s20f0u4: dhcp4: no addresses: [192.168.1.223/24] gateway4: 192.168.0.1 nameservers: addresses: [255.255.0.0] 保存后退出，执行重启网络服务 netplan apply 再用ifconfig查看USB网卡的IP地址是否生效 虚拟机通过SSH登录开发板（密码为Mind@123）串口方式 ssh HwHiAiUser@192.168.1.2 网口方式 ssh HwHiAiUser@192.168.3.3 修改HwHiAiUser用户密码 passwd 同样方法，进入root用户来修改用户密码 给HwHiAiUser配置权限，进入root用户 su 修改/etc/sudoer vim /etc/sudoers 加入 HwHiAiUser ALL=(ALL:ALL) ALL （推荐）使用网线通过路由器连接Ubuntu服务器 Atlas 200 DK通过网线接入路由器的场景下，需要开启路由器的DHCP功能，然后使用DHCP的方式自动分配Atlas 200 DK的IP地址，所以需要修改Atlas 200 DK的NIC网卡的IP地址获取方式为DHCP 假如您已经将Atlas 200 DK通过网线接入路由器，并开启了路由器的DHCP功能，后续操作步骤如下： 使用USB连接线将Atlas 200 DK与Ubuntu服务器连接，并参考上面的通过USB接口直连Ubuntu服务器（虚拟机）配置Ubuntu服务器的USB网卡的IP地址，使其可与Atlas 200 DK通信 配置Atlas 200 DK的NIC网卡IP地址获取方式为DHCP 通过USB端口登录Ubuntu虚拟机 ssh HwHiAiUser@192.168.1.2 进入root用户，打开网络配置文件 vi /etc/netplan/01-netcfg.yaml 修改eth0网卡的IP地址获取方式为DHCP，保存退出 eth0: dhcp4: true addresses: [] optional: true 执行如下命令重启网络服务 netplan apply 执行ifconfig命令获取eth0网卡的IP地址，您可以使用此IP地址与Ubuntu服务器通信，当然，您也可以继续使用USB网卡的IP地址与Ubuntu服务器通信 这时可以使用MobaXterm工具通过SSH连接上开发板 电脑一定要和开发板连接同一个路由器 至此，您可以在Atlas 200 DK开发者板上访问网络了 4）安装CANN运行软件包 下载软件包 软件包：Ascend-cann-nnrt_*{software version}*_linux-aarch64.run 里面包含AI CPU安装包、PyACL安装包与AscendCL安装包 获取链接 软件包安装 将下载软件包中获取到的CANN运行软件包“Ascend-cann-nnrt_*{software version}*_linux-aarch64.run”以HwHiAiUser用户存放到开发者板的任一目录下，直接使用MobaXterm打开文件夹，然后直接拖进去 执行如下命令为安装包增加可执行权限。 chmod +x \\*.run 执行如下校验安装包的一致性和完整性 ./Ascend-cann-nnrt_{software version}_linux-aarch64.run --check 执行如下命令进行离线推理引擎包的安装 ./Ascend-cann-nnrt_{software version}_linux-aarch64.run --install --chip=Ascend310-minirc –chip=Ascend310-minirc（可选）：指定芯片型号为Ascend310 Soc芯片（RC模式启动，作为主控CPU） 配置了此参数，则会只部署Ascend310RC形态的AI CPU软件包 配置环境变量 . /home/HwHiAiUser/Ascend/nnrt/set_env.sh CANN软件提供进程级环境变量设置脚本，供用户在进程中引用，以自动完成环境变量设置。用户进程结束后自动失效 用户也可以通过修改~/.bashrc文件方式设置永久环境变量，在文件最后一行后面添加上述内容 执行**:wq!**命令保存文件并退出 执行source ~/.bashrc命令使其立即生效 3. 环境搭建验证1）Atlas200DK运行环境验证采用samples仓中的黑白图像上色工程作为验证，但是想要使用samples仓中的工程必须先配置好Atlas200DK的运行环境、Ubuntu虚拟机的开发环境、以及samples仓所需要的一些第三方依赖 CANN的开发环境和运行环境上面已经有了介绍，需要注意的是CANN的版本对应的开发环境和运行环境的配置，这个可以在参考资料找到相应的文档跳转进入，自行配置 然后根据你的CANN版本下载对应的samples仓库的代码 cd ${HOME} git clone https://gitee.com/ascend/samples.git 使用下面的语句切换到其他的tag版本 git checkout v0.5.0 在进行推理之前，还需要配置第三方依赖，我选择的是非昇腾AI设备上安装开发环境场景下的第三方依赖安装 模型转换 cd${HOME}/samples/cplusplus/level2_simple_inference/6_other/colorization/model wget https://modelzoo-train-atc.obs.cn-north-4.myhuaweicloud.com/003_Atc_Models/AE/ATC%20Model/colorization/colorization.prototxt wget https://modelzoo-train-atc.obs.cn-north-4.myhuaweicloud.com/003_Atc_Models/AE/ATC%20Model/colorization/colorization.caffemodel atc --input_shape=\"data_l:1,1,224,224\" --weight=\"./colorization.caffemodel\" --input_format=NCHW --output=\"colorization\" --soc_version=Ascend310 --framework=0 --model=\"./colorization.prototxt\" Atlas200DK运行推理（黑白图像上色sample） 如果出现成功successfully的话，说明你的运行环境是没有什么问题的，并且可以在/out/output目录下找到推理结果 原图： 2）MindStudio开发环境验证4. 遇坑总结1）制卡时Atlas200DK无法正常启动 [问题描述] 安装官方文档制卡，显示制卡成功，但是Atlas200DK的指示灯还是没有4盏全亮，说明无法正常启动 [解决方案] 经过论坛求助，通过更换了一张SD成功启动，听说可以直接烧录合设环境的img来解决此问题（但是我没试过） 2）在Atlas200dk（运行环境）中运行./sample_run.sh的时候报错找不到running [问题描述] sh文件中，在running函数调用，但是报错找不到running [解决方案] 通过查看这个./sample_run.sh文件发现它包含了. ${common_script_dir}/sample_common.sh 从而去找了这个文件查看其中根本就没有running函数的声明，而是running_picture ，从而修改./sample_run.sh中的running为running_picture 这就要求我们不能只懂得一味照着文档去配环境，对于一些问题的定位我们需要有自己的见解，先看是代码问题还是版本问题，写代码也不能照着CSDN写， 参考资料 Atlas200DK_separate_MD/environment.md · lovingascend/quick_start - Gitee.com 开发环境与运行环境分设-安装CANN软件-环境部署-1.0.12-Atlas 200 DK开发者套件-文档首页-昇腾社区 (hiascend.com) 《MindStudio安装指南》 Atlas200DK制卡问题梳理_Atlas 200 DK_昇腾_华为云论坛 (huaweicloud.com) Mindstudio工程样例参考 [黑白图像上色(C++)（CANN20.1）（Atlas200DK） - Wiki - Gitee.com](https://gitee.com/ascend/samples/wikis/基于Atlas 200DK的黑白图像上色实验(C++)?sort_id=3411938)","categories":[{"name":"Atlas200DK开发笔记","slug":"Atlas200DK开发笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Atlas200DK%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"}]}],"categories":[{"name":"论文阅读理解笔记","slug":"论文阅读理解笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络学习笔记","slug":"计算机网络学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"算法学习笔记","slug":"算法学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"深度学习笔记","slug":"深度学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习笔记","slug":"机器学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构学习笔记","slug":"数据结构学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据库学习笔记","slug":"数据库学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学建模学习笔记","slug":"数学建模学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学学习笔记","slug":"数学学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数字电路学习笔记","slug":"数字电路学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"操作系统学习笔记","slug":"操作系统学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"嵌入式单片机学习笔记","slug":"嵌入式单片机学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图像处理学习笔记","slug":"图像处理学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"华为生态学习笔记","slug":"华为生态学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"亮牛开发笔记","slug":"亮牛开发笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/%E4%BA%AE%E7%89%9B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"name":"Tensorflow框架学习笔记","slug":"Tensorflow框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Tensorflow%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"socket网络编程学习笔记","slug":"socket网络编程学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"ROS学习笔记","slug":"ROS学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/"},{"name":"Pytorch框架学习笔记","slug":"Pytorch框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Pytorch%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MindSpore框架学习笔记","slug":"MindSpore框架学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/MindSpore%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Linux操作系统学习","slug":"Linux操作系统学习","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"},{"name":"JAVA学习笔记","slug":"JAVA学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Hispark开发学习笔记","slug":"Hispark开发学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Hispark%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Git学习笔记","slug":"Git学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言学习笔记","slug":"C语言学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++学习笔记","slug":"C-学习笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Atlas200DK开发笔记","slug":"Atlas200DK开发笔记","permalink":"https://selamangit.github.io/ZaNot.github.io/categories/Atlas200DK%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Jlink","slug":"Jlink","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Jlink/"},{"name":"socket网络编程","slug":"socket网络编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Qt配置","slug":"Qt配置","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E9%85%8D%E7%BD%AE/"},{"name":"Qt组件","slug":"Qt组件","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E7%BB%84%E4%BB%B6/"},{"name":"Qt工具类","slug":"Qt工具类","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Qt多线程编程","slug":"Qt多线程编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"},{"name":"Qt信号与槽","slug":"Qt信号与槽","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"},{"name":"Qt串口编程","slug":"Qt串口编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Qt%E4%B8%B2%E5%8F%A3%E7%BC%96%E7%A8%8B/"},{"name":"error","slug":"error","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/error/"},{"name":"脚本","slug":"脚本","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"包管理","slug":"包管理","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"},{"name":"Python常用库","slug":"Python常用库","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%B8%B8%E7%94%A8%E5%BA%93/"},{"name":"Python学习","slug":"Python学习","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/Python%E5%AD%A6%E4%B9%A0/"},{"name":"C++进阶知识","slug":"C-进阶知识","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"},{"name":"C++多线程编程","slug":"C-多线程编程","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"},{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"C++关键字","slug":"C-关键字","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/C-%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"环境部署","slug":"环境部署","permalink":"https://selamangit.github.io/ZaNot.github.io/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"}]}