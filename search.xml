<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/ZaNot.github.io/2022/09/08/yolo-v3/"/>
      <url>/ZaNot.github.io/2022/09/08/yolo-v3/</url>
      
        <content type="html"><![CDATA[<h2 id="YOLO-V3"><a href="#YOLO-V3" class="headerlink" title="YOLO-V3"></a>YOLO-V3</h2><ul><li>YOLO-V3是比较完善的一个目标检测的框架，它经过一代一代的发展，一步步地完善，接下来介绍一些YOLO-V3在V2的基础上进行了哪些的改进，下图为我训练出来模型的检测效果<div align="center"></div></li></ul><h4 id="先验框的更新"><a href="#先验框的更新" class="headerlink" title="先验框的更新"></a>先验框的更新</h4><p>在V2中，先验框是由K-mean聚类算法得出的5种不同尺寸的先验框，在V3中考虑到Darknet-53会输出三种尺寸的预测，因此选取先验框时应该选取的是3的倍数，最终选择了9种先验框，每种尺寸都有三种不同形状的先验框。</p><p>先验框的选择仍然是通过K-mean聚类出9种，这9种聚类得出的先验框之间不是没有关系的，其中每种尺寸的特征图都有其专属的三种基本相同大小的先验框用来预测，例如：13×13尺寸的特征图中会有三种较大的先验框用来预测，26×26的特征图会有较中等的三种先验框用来预测，52×52的特征图则会有三种较小的先验框用来预测</p><p>K-mean聚类的距离度量方法仍然是利用IOU来计算，这些先验框都是根据groundtruth的数据聚类出来的</p><h4 id="正负样本分配"><a href="#正负样本分配" class="headerlink" title="正负样本分配"></a>正负样本分配</h4><p>在前面的学习，我们已经知道除了要计算有物体的网格的损失，还要计算不含物体的网格的损失，因此就有了正负样本的说法</p><p>根据上面聚类出来的9种先验框，计算出三个尺寸所对应的三个先验框与groundtruth的IOU，具体做法为：每个尺寸用对应的三种大小的先验框去与这个尺寸的groundtruth计算IOU，如果计算出来的先验框的IOU值存在大于阈值，就标记这个先验框为这个尺寸下的正样本，并设该尺寸下IOU大于阈值的先验框的置信度为1；如果计算出来的IOU都不大于阈值，那就选取计算出来IOU最大的先验框作为正样本</p><p>以上的两种方法就是筛选正样本的方法，如果不满足这两种方法，剩下的先验框就标记为负样本。标记正负样本只会参与到置信度损失的计算中，不会参与到预测类别以及bbox位置预测的损失计算中</p><p>正负样本分配也需要遵循一些准则，那就是尽量使得正样本数和负样本数基本相等，这是为了让模型在预测时不会出现大量漏检的现象，按照我的理解就是：先验框计算出来的IOU只要大于阈值，就说明这个先验框是能检测到物体的，正样本数越多就说明这个区域内存在物体的概率更大，也就不至于出现大量漏检的现象</p><h4 id="网络结构上的改进"><a href="#网络结构上的改进" class="headerlink" title="网络结构上的改进"></a>网络结构上的改进</h4><p>首先来看看它的主体网络：<strong>Darknet-53</strong>的结构图</p><div align="center"><img src="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220908213903872.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220908213903872.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></div><p>网络结构的改变是YOLO-V3中比较大改进的地方</p><p>在YOLO-V2中使用的主体网络结构为： <strong>Darknet-19</strong>，在Darknet-19中使用卷积层来提取特征图，通过池化层来获取降低了特征维度后的特征图（具体结构请去看YOLO-V2），在经过Darknet-19全部提取完特征图之后，再将上一层池化之前的结果经过<strong>reorg</strong>之后再合并到一起，来实现特征融合，将感受野较小的特征图融合到感受野较大的特征图上面，可以使得较少的目标不至于丢失</p><p>在YOLO-V3中的<strong>Darknet-53</strong>不同于V2中的网络，它除了使用卷积层来提取特征图之外，还使用了卷积层来降低特征图的维度，而不是池化层。仔细想想确实可以用卷积层来代替池化层来实现特征的降维，而且这个网络的主要成分还是残差块$\left(\text{resn}\right)$，残差块是由一层特征降维的卷积层和 $\text{2n}$ 个提取特征图的卷积层组成，但是在每 $\text{2}$ 个提取特征图的卷积层之后，都要将输出的 $\text{conv}$ 和输入的 $\text{conv}$ 相加</p><div align="center"><img src="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220908213910272.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220908213910272.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></div><p>在Darknet-53的卷积降维中会提取出大小不同的特征图，以输入图片大小为416×416为例，网络会将其降维为13×13、26×26、52×52等尺寸。若是像V2的做法，会将尺寸较大的特征图拆分之后融入尺寸较大的特征图中去，但想想V2的做法真的合适吗？将检测小物体（感受野较小）的特征图融合到检测大物体（感受野较大）的特征图中去，可能会将本来检测大物体的功能减弱或者检测小物体的功能减弱</p><p>那么V3中是怎么做的呢？它将最后提取出来的三种不同尺寸的特征图进行处理，将尺寸小的特征图进行<strong>上采样</strong>，还原到上一层的尺寸大小，然后将该特征图拼接到上一层的特征图中去，例如：将13×13的特征图经过上采样变为26×26大小的特征图，然后拼接到26×26尺寸的特征图中去。</p><blockquote><p>我的理解是：在Darknet-53中通过残差块提取的特征图中已包含了前面的信息，小物体的信息也提取出来了，经过参数的优化小物体的检测会得到一定效果，此时应该向感受野大的特征图获取一些全局信息（<strong>个人理解仍待考证</strong>）</p></blockquote><h4 id="decode解码"><a href="#decode解码" class="headerlink" title="decode解码"></a>decode解码</h4><p>由于网络输出的预测值的范围是0~1之间，也就是说每一个网格输出的bbox的位置预测都是都被限制在这个网格内，这正是YOLO的划分，每个网格都来预测是否有物体中心点。而decode就是用来将特征预测值都还原到相应尺寸下的尺寸，具体做法就是：将坐标预测值（0 ~ 1之间）与网格左上角的坐标相加获得该bbox在相应尺寸下的坐标，以及将预测的宽高乘上相应的尺寸，从而获得bbox的宽高，这样就可以计算出bbox与groundtruth的IOU，那么bbox的置信度就得出来了，就可以预测此处是否存在物体了</p><h4 id="处理解码后的bbox"><a href="#处理解码后的bbox" class="headerlink" title="处理解码后的bbox"></a>处理解码后的bbox</h4><p>网络输出的预测值经过解码之后，会获取所有尺寸下的网格所输出三个预测框bbox的信息，这些预测出来的bbox有可能存在左上角的坐标比右下角坐标大的情况，或者bbox不存在的情况，在检测目标时需要将这些预测出来的bbox信息去除先，保留下那些bbox信息存在且不异常的</p><h4 id="NMS筛选bbox（在预测阶段）"><a href="#NMS筛选bbox（在预测阶段）" class="headerlink" title="NMS筛选bbox（在预测阶段）"></a>NMS筛选bbox（在预测阶段）</h4><p>NMS（Non-Maximum Suppression）抑制不是极大值的元素，说白了就是去除哪些重叠率较高并且score评分较低的bbox</p><p>处理了解码后的bbox，会保留下一些bbox的信息，但是不是每个bbox都去负责呢？仔细想想每个网格（对应尺寸下）会输出三个bbox，假如处理后的bbox信息都被保留下来了，那么一个物体就会有三个预测框去框住它，这样的展示效果就不太好了。</p><p>对于一个网格内的bbox，需要的是保存下那个能最好地检测出物体的那个bbox，就要用到NMS方法了<br>方法就是：</p><ol><li>首先判断边界框的数目是否大于0，如果不是大于0，说明没有bbox的信息被保留下来，就去检测下一个网格，直到所有尺寸下的网格都被检测完</li><li>在保留bbox时，会给每个bbox一个评分，对于一个网格内的bbox，根据评分，为这些bbox排序，（不放回的取）取出评分最大的那个bbox</li><li>把这个评分最高的bbox与同一网格下的其他bbox计算IOU，这是为了判断评分最大的bbox与同一网格下的其他bbox的重叠率，去除那些重叠率过高的，取到剩下的bbox为0为止<h4 id="GIOU（广义IOU）"><a href="#GIOU（广义IOU）" class="headerlink" title="GIOU（广义IOU）"></a>GIOU（广义IOU）</h4>这是一种优化边界框的方法，GIOU是衡量bbox与实际框之间对齐和重叠情况的一个指标<br>IOU计算公式：<br>$$ \text{IOU }= \left|\frac{A \cap B}{A\cup B}\right|$$<br>GIOU的计算公式：<br>$$\text{GIOU }= \left| \frac{C/(A\cup B)}{C} \right|$$</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划理论</title>
      <link href="/ZaNot.github.io/2021/10/21/dong-tai-gui-hua/"/>
      <url>/ZaNot.github.io/2021/10/21/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h4 id="1-什么是动态规划"><a href="#1-什么是动态规划" class="headerlink" title="1. 什么是动态规划"></a>1. 什么是动态规划</h4><p>在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。</p><p>这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法。</p><h4 id="2-动态规划的思想"><a href="#2-动态规划的思想" class="headerlink" title="2. 动态规划的思想"></a>2. 动态规划的思想</h4><p>动态规划与分治法类似，都是==把大问题拆分成小问题==，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在==新问题里需要用到的子问题可以直接提取，避免了重复计算==，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于==填表==，表填写完毕，最优解也就找到。</p><p>所谓的最优性原理是指：<br>多阶段决策过程的最优决策序列具有这样的性质：不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言（当前出发点），其后各阶段的决策序列必须构成最优策略。</p><h4 id="3-动态规划的作用"><a href="#3-动态规划的作用" class="headerlink" title="3. 动态规划的作用"></a>3. 动态规划的作用</h4><p>动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间</p><blockquote><p>Questions<br>动态规划怎么保证每个子问题的决策都是对最优结果的最好的决策呢？<br>动态规划记住的状态一定是最优的吗？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/ZaNot.github.io/2021/10/21/di-yi-pian-wen-zhang/"/>
      <url>/ZaNot.github.io/2021/10/21/di-yi-pian-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h3 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h3><p>I Love You</p><p><img src="/ZaNot.github.io/../image/1.png" class="lazyload" data-srcset="/ZaNot.github.io/../image/1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="alt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> First </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/ZaNot.github.io/2021/10/20/hello-world/"/>
      <url>/ZaNot.github.io/2021/10/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
