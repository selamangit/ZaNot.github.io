<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TOPSIS法（优劣解距离法）</title>
      <link href="/ZaNot.github.io/2022/09/09/shu-xue-jian-mo-topsis-fa/"/>
      <url>/ZaNot.github.io/2022/09/09/shu-xue-jian-mo-topsis-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="TOPSIS法（优劣解距离法）"><a href="#TOPSIS法（优劣解距离法）" class="headerlink" title="TOPSIS法（优劣解距离法）"></a>TOPSIS法（优劣解距离法）</h2><ul><li>TOPSIS法是一种常用的综合评价方法，其能充分利用原始数据的信息，其结果能精确地反映各评价方案之间的<strong>差距</strong>，这种方法==通过构造评价问题的正理想解和负理想解，即各指标的最优解和最劣解，通过计算每个方案到理想方案的相对贴近度，即靠近正理想解和远离负理想解的程度，来对方案进行排序==，从而选出最优方案。</li></ul><h3 id="方法和原理"><a href="#方法和原理" class="headerlink" title="方法和原理"></a>方法和原理</h3><p>设多属性决策方案集为$\boldsymbol{ D={d_1,d_2,…,d_m } }$，衡量方案优劣的属性变量为$\boldsymbol{ \ x_1\ ,\ x_2\ ,…\ ,x_n }$，这时方案集$\boldsymbol{D}$中的每一个方案$\boldsymbol{\ d_i(i=1…m)}$的$\boldsymbol{n}$个属性值构成的向量是$\boldsymbol{ { a_{ i1 },…,\ a_{ in }} }$，它作为$\boldsymbol{n}$维空间中的一个点，能唯一表征方案$\boldsymbol{\ d_i }$，这些方案的属性共同构成决策矩阵。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>正理想解</strong><br>正理想解$\boldsymbol{C^*}$是一个方案集$\boldsymbol{D}$中不存在的虚拟的最佳方案，它的每个属性值都是决策矩阵中该属性值的最优解。<br><strong>负理想解</strong><br>负理想解$\boldsymbol{C^0}$则是虚拟的最差方案，它的每个属性值都是决策矩阵中该属性的最差值。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>在$\boldsymbol{n}$维空间中，将方案集$\boldsymbol{D}$中的各备选方案$\boldsymbol{d_i}$与正理想解$\boldsymbol{\ C^*}$和负理想解$\boldsymbol{\ C^0}$的距离进行比较，既靠近正理想解又远离负理想解的方案就是方案集$\boldsymbol{D}$中的最优方案；并可以据此来排定各备选方案的优先序。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>用TOPSIS法求解多属性决策问题的概念简单，只要在属性空间==定义适当的距离测度==就能通过欧氏距离来计算备选方案与理想解的距离。<br>即用正理想解，又用负理想解的原因是仅仅使用正理想解时有时会出现某两个备选方案与正理想解的距离相同的情况，为了区分这两个方案的优劣，引入负理想解，并计算这两个方案与负理想解的距离，与正理想解距离相同的方案离负理想解远的为优。</p><h3 id="TOPSIS算法步骤"><a href="#TOPSIS算法步骤" class="headerlink" title="TOPSIS算法步骤"></a>TOPSIS算法步骤</h3><ol><li>用向量规划化的方法求得规范决策矩阵。设多属性决策问题的决策矩阵$\boldsymbol{A=(a_{ij})<em>{m\times n}}$，规范化决策矩阵$\boldsymbol{B=(b</em>{ij})<em>{m\times n}}$，其中$$\boldsymbol{b</em>{ij}=\frac{a_{ij}}{\sqrt{\sum_{i=1}^ma_{ij}^2}}(i=1,2,…,m;j=1,2,…,n)}$$</li><li>构成加权规范阵$\boldsymbol{C=(c_{ij})<em>{m\times n}}$，设由决策人给定各属性的权重向量为$\boldsymbol{w=[w_1,w_2,…,w_n]^T}$，则$$\boldsymbol{c</em>{ij}=w_j\cdot b_{ij}(i=1,2,…,m;j=1,2,…,n)}$$</li><li>确定正理想解的第$\boldsymbol{j}$个属性$\boldsymbol{C^*_j}$和负理想解的第$\boldsymbol{j}$个属性$\boldsymbol{C^0_j}$</li><li>计算各方案到正理想解与负理想解的距离，备选方案$\boldsymbol{d_i}$到正理想解的距离为$$\boldsymbol{s^*<em>i=\sqrt{\sum</em>{j=1}^n(c_{ij}-c_j^*)^2},(i=1,2,…,m)}$$<br>备选方案$\boldsymbol{d_i}$到负理想解的距离为$$\boldsymbol{s_i^0=\sqrt{\sum^n_{j=1}(c_{ij}-c_j^0)^2}(i=1,2,…,m)}$$</li><li>计算各方案的排队指标值（即综合评价指标），即$$\boldsymbol{f_i^*=\frac{s_i^0}{s_i^0+s_i^*}}$$</li><li>按$\boldsymbol{f_i^*}$由大到小排列方案的优劣次序</li></ol><h3 id="属性值的规范化"><a href="#属性值的规范化" class="headerlink" title="属性值的规范化"></a>属性值的规范化</h3><h4 id="属性值规范化处理的目的"><a href="#属性值规范化处理的目的" class="headerlink" title="属性值规范化处理的目的"></a>属性值规范化处理的目的</h4><p>在进行决策是，一般要进行属性值的规范化处理，主要有三个作用：</p><ol><li>属性值有多种类型，不同类型类型的属性放在同一个表中不便于直接从数值大小判断方案的优劣，因此需要对数据进行预处理，使得表中任意属性下性能越优的方案变换后的属性值越大。</li><li>非量纲化，多属性决策方法与评估的困难之一是属性间的不可公度性，即在属性值表中的每一类数具有不同的量纲，在用各种多属性决策方法进行分析评价时，需要排除量纲的选用对决策或评估结果的影响，这就是非量纲化。</li><li>归一化，属性值表中不同指标的属性值的数值差别很大们为了直观，更为了便于采用各种多属性决策ui评估方法进行评价，需要把属性值表中数值归一化处理，即把表中数值均变换到$\boldsymbol{[0,1]}$区间上。</li></ol><h4 id="属性值类型"><a href="#属性值类型" class="headerlink" title="属性值类型"></a>属性值类型</h4><table><thead><tr><th align="center">属性值类型</th><th align="center">类型特点</th></tr></thead><tbody><tr><td align="center">效益型</td><td align="center">属性值越大越好</td></tr><tr><td align="center">成本型</td><td align="center">属性值越小越好</td></tr><tr><td align="center">区间型</td><td align="center">属性值在某个区间内最好</td></tr><tr><td align="center">中间型</td><td align="center">属性值在中间的时候最好</td></tr></tbody></table><h4 id="规范化处理方法"><a href="#规范化处理方法" class="headerlink" title="规范化处理方法"></a>规范化处理方法</h4><h5 id="1-线性变换"><a href="#1-线性变换" class="headerlink" title="1.线性变换"></a>1.线性变换</h5><p>原始的决策矩阵$\boldsymbol{A=(a_{ij})<em>{m\times n}}$，变换后的决策矩阵$\boldsymbol{B=(b</em>{ij})<em>{m\times n}(i=1,…,m;j=1,…,n)}$设$\boldsymbol{a_j^{max}}$是决策矩阵第$\boldsymbol{j}$列中的最大值，$\boldsymbol{a_j^{min}}$是决策矩阵第$\boldsymbol{j}$列中的最小值，若$\boldsymbol{x_j}$为效益性属性，则$$\boldsymbol{b</em>{ij}=\frac{a_{ij}}{a_j^{max}}}$$此时最差属性值不一定为0，最优属性值为1<br>若$\boldsymbol{x_j}$为成本型属性，则$$\boldsymbol{b_{ij}=1-\frac{a_{ij}}{a_j^{max}}}$$</p><h5 id="2-标准0-1变换"><a href="#2-标准0-1变换" class="headerlink" title="2.标准0-1变换"></a>2.标准0-1变换</h5><p>为了是每个属性变换后的最优解为1，且最差值为0，可以进行标准0-1变换。对效益性属性$\boldsymbol{x_j}$，令$$\boldsymbol{b_{ij}=\frac{a_{ij}-a^{min}_j}{a_j^{max}-a^{min}<em>j}}$$<br>对成本型属性$\boldsymbol{x_j}$，令$$\boldsymbol{\frac{a_j^{max}-a</em>{ij}}{a_j^{max}-a_j^{min}}}$$</p><h5 id="3-区间型属性的变换"><a href="#3-区间型属性的变换" class="headerlink" title="3.区间型属性的变换"></a>3.区间型属性的变换</h5><p>设给定的最优属性区间为$\boldsymbol{[a_J^0,a_j^*]}$，$\boldsymbol{a’<em>j}$为无法容忍下限，$\boldsymbol{a’’<em>j}$为无法容忍上限，则<br>$$\boldsymbol{<br>b</em>{ij}=\left{\begin{array}{l}<br>    1-\frac{(a_j^0-a</em>{ij})}{a_j^0-a_j’}&amp;,&amp;a’<em>j\le a</em>{ij} \le a^0_j\<br>    1&amp;,&amp;a_j^0\le a_{ij}\le a_j^<em>\<br>    1-\frac{a_{ij}-a_j^</em>}{a’’<em>j-a_j^*}&amp;,&amp;a_j^*&lt;a</em>{ij}\le a’’<em>j\<br>    0&amp;,&amp;其他<br>\end{array}<br>\right.<br>}<br>$$<br>变换后的属性值$\boldsymbol{b</em>{ij}}$与原属性值$\boldsymbol{a_{ij}}$之间的函数图形为一般梯形，当属性值最有区间的上下限相等时，最优区间退化为一个点时，函数图形退化为三角形</p><h5 id="4-向量规范化"><a href="#4-向量规范化" class="headerlink" title="4.向量规范化"></a>4.向量规范化</h5><p>规范化后，各方案的同一属性值的平方和为1，常用于计算各种方案与某种虚拟方案的欧氏距离，一般要先将属性值正向化，即利用上面的变换来实现，正向化后再规范化就能直观从属性值上表示出各方案再某一属性下的情况</p><h5 id="5-标准化处理"><a href="#5-标准化处理" class="headerlink" title="5. 标准化处理"></a>5. 标准化处理</h5><p>在实际问题中，不同变量的测量单位往往是不一样的。为了消除变量的量纲效应，使每个变量都具有同等的表现力，数据分析中常对数据进行标准化处理，即$$\boldsymbol{b_{ij}=\frac{a_{ij}-\bar{a}<em>j}{s_j},i=1,2…,m;j=1,2,…,n}$$<br>其中：$\boldsymbol{\bar{a}<em>j=\frac{1}{m}\sum^m</em>{i=1}a</em>{ij}\ ,s_j=\sqrt{\frac{1}{m-1}\sum^m_{i=1}(a_{ij}-\bar{a})^2},j=1,2,…,n}$</p><p>代码实现：</p><pre class="line-numbers language-none"><code class="language-none">import numpy as npimport proces_dataimport mathdef create_array(dic,require,require1,require2):#,require3    array_of_A = []    name = []    for i in dic.items():        temp = []        temp.append(i[1][require])        temp.append(i[1][require1])        temp.append(i[1][require2])        #temp.append(i[1][require3])        array_of_A.append(temp)        name.append(i[0])    array_of_A = np.array(array_of_A)    return array_of_A,namedef Normalzation(stand_of_b):    molecular = stand_of_b    Denominator = np.sum(np.square(stand_of_b),axis=0)    normal_of_b = molecular / np.sqrt(Denominator)    return normal_of_bdef Entropy_method(array_of_a):    a = array_of_a    molecular = a - np.min(a,axis=0)    Denominator = np.max(a,axis=0) - np.min(a,axis=0)    Positive_index = molecular / Denominator    p = Positive_index / np.sum(Positive_index,axis=0)    k = (1 / math.log(len(a)))    result = np.zeros(shape=p.shape)    for i in range(len(p)):        for j in range(len(p[i])):            if p[i][j] == 0:                result[i][j] = 0            else:                result[i][j] = p[i][j] * math.log(p[i][j])    Entropy = - k * (np.sum(result,axis=0) )    diff_Enr = 1 - Entropy    weight = diff_Enr / np.sum(diff_Enr)    #weight = weight[np.newaxis,:]    return weightdef weighted_array(weight,array_of_n):    return array_of_n * weightdef calculate(weighted_array):    max = np.max(weighted_array,axis=0)    min = np.min(weighted_array,axis=0)    molecular = np.sqrt(np.sum(np.square(weighted_array-min)))    Denominator = molecular + np.sqrt(np.sum(np.square(weighted_array-max),axis=1))    result = molecular / Denominator    return result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学建模学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO-V3</title>
      <link href="/ZaNot.github.io/2022/09/08/yolo-v3/"/>
      <url>/ZaNot.github.io/2022/09/08/yolo-v3/</url>
      
        <content type="html"><![CDATA[<h2 id="YOLO-V3"><a href="#YOLO-V3" class="headerlink" title="YOLO-V3"></a>YOLO-V3</h2><ul><li>YOLO-V3是比较完善的一个目标检测的框架，它经过一代一代的发展，一步步地完善，接下来介绍一些YOLO-V3在V2的基础上进行了哪些的改进，下图为我训练出来模型的检测效果<div align="center"><img src="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220909010954747.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220909010954747.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" width="300" height="200" alt="检测前" align="top"><img src="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220909010958328.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220909010958328.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" width="300" height="200" align="top"></div></li></ul><h4 id="先验框的更新"><a href="#先验框的更新" class="headerlink" title="先验框的更新"></a>先验框的更新</h4><p>在V2中，先验框是由K-mean聚类算法得出的5种不同尺寸的先验框，在V3中考虑到Darknet-53会输出三种尺寸的预测，因此选取先验框时应该选取的是3的倍数，最终选择了9种先验框，每种尺寸都有三种不同形状的先验框。</p><p>先验框的选择仍然是通过K-mean聚类出9种，这9种聚类得出的先验框之间不是没有关系的，其中每种尺寸的特征图都有其专属的三种基本相同大小的先验框用来预测，例如：13×13尺寸的特征图中会有三种较大的先验框用来预测，26×26的特征图会有较中等的三种先验框用来预测，52×52的特征图则会有三种较小的先验框用来预测</p><p>K-mean聚类的距离度量方法仍然是利用IOU来计算，这些先验框都是根据groundtruth的数据聚类出来的</p><h4 id="正负样本分配"><a href="#正负样本分配" class="headerlink" title="正负样本分配"></a>正负样本分配</h4><p>在前面的学习，我们已经知道除了要计算有物体的网格的损失，还要计算不含物体的网格的损失，因此就有了正负样本的说法</p><p>根据上面聚类出来的9种先验框，计算出三个尺寸所对应的三个先验框与groundtruth的IOU，具体做法为：每个尺寸用对应的三种大小的先验框去与这个尺寸的groundtruth计算IOU，如果计算出来的先验框的IOU值存在大于阈值，就标记这个先验框为这个尺寸下的正样本，并设该尺寸下IOU大于阈值的先验框的置信度为1；如果计算出来的IOU都不大于阈值，那就选取计算出来IOU最大的先验框作为正样本</p><p>以上的两种方法就是筛选正样本的方法，如果不满足这两种方法，剩下的先验框就标记为负样本。标记正负样本只会参与到置信度损失的计算中，不会参与到预测类别以及bbox位置预测的损失计算中</p><p>正负样本分配也需要遵循一些准则，那就是尽量使得正样本数和负样本数基本相等，这是为了让模型在预测时不会出现大量漏检的现象，按照我的理解就是：先验框计算出来的IOU只要大于阈值，就说明这个先验框是能检测到物体的，正样本数越多就说明这个区域内存在物体的概率更大，也就不至于出现大量漏检的现象</p><h4 id="网络结构上的改进"><a href="#网络结构上的改进" class="headerlink" title="网络结构上的改进"></a>网络结构上的改进</h4><p>首先来看看它的主体网络：<strong>Darknet-53</strong>的结构图</p><div align="center"><img src="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220909011000848.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220909011000848.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></div><p>网络结构的改变是YOLO-V3中比较大改进的地方</p><p>在YOLO-V2中使用的主体网络结构为： <strong>Darknet-19</strong>，在Darknet-19中使用卷积层来提取特征图，通过池化层来获取降低了特征维度后的特征图（具体结构请去看YOLO-V2），在经过Darknet-19全部提取完特征图之后，再将上一层池化之前的结果经过<strong>reorg</strong>之后再合并到一起，来实现特征融合，将感受野较小的特征图融合到感受野较大的特征图上面，可以使得较少的目标不至于丢失</p><p>在YOLO-V3中的<strong>Darknet-53</strong>不同于V2中的网络，它除了使用卷积层来提取特征图之外，还使用了卷积层来降低特征图的维度，而不是池化层。仔细想想确实可以用卷积层来代替池化层来实现特征的降维，而且这个网络的主要成分还是残差块$\left(\text{resn}\right)$，残差块是由一层特征降维的卷积层和 $\text{2n}$ 个提取特征图的卷积层组成，但是在每 $\text{2}$ 个提取特征图的卷积层之后，都要将输出的 $\text{conv}$ 和输入的 $\text{conv}$ 相加</p><div align="center"><img src="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220909011003829.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/selamangit/GithubPic/main/20220909011003829.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></div><p>在Darknet-53的卷积降维中会提取出大小不同的特征图，以输入图片大小为416×416为例，网络会将其降维为13×13、26×26、52×52等尺寸。若是像V2的做法，会将尺寸较大的特征图拆分之后融入尺寸较大的特征图中去，但想想V2的做法真的合适吗？将检测小物体（感受野较小）的特征图融合到检测大物体（感受野较大）的特征图中去，可能会将本来检测大物体的功能减弱或者检测小物体的功能减弱</p><p>那么V3中是怎么做的呢？它将最后提取出来的三种不同尺寸的特征图进行处理，将尺寸小的特征图进行<strong>上采样</strong>，还原到上一层的尺寸大小，然后将该特征图拼接到上一层的特征图中去，例如：将13×13的特征图经过上采样变为26×26大小的特征图，然后拼接到26×26尺寸的特征图中去。</p><blockquote><p>我的理解是：在Darknet-53中通过残差块提取的特征图中已包含了前面的信息，小物体的信息也提取出来了，经过参数的优化小物体的检测会得到一定效果，此时应该向感受野大的特征图获取一些全局信息（<strong>个人理解仍待考证</strong>）</p></blockquote><h4 id="decode解码"><a href="#decode解码" class="headerlink" title="decode解码"></a>decode解码</h4><p>由于网络输出的预测值的范围是0~1之间，也就是说每一个网格输出的bbox的位置预测都是都被限制在这个网格内，这正是YOLO的划分，每个网格都来预测是否有物体中心点。而decode就是用来将特征预测值都还原到相应尺寸下的尺寸，具体做法就是：将坐标预测值（0 ~ 1之间）与网格左上角的坐标相加获得该bbox在相应尺寸下的坐标，以及将预测的宽高乘上相应的尺寸，从而获得bbox的宽高，这样就可以计算出bbox与groundtruth的IOU，那么bbox的置信度就得出来了，就可以预测此处是否存在物体了</p><h4 id="处理解码后的bbox"><a href="#处理解码后的bbox" class="headerlink" title="处理解码后的bbox"></a>处理解码后的bbox</h4><p>网络输出的预测值经过解码之后，会获取所有尺寸下的网格所输出三个预测框bbox的信息，这些预测出来的bbox有可能存在左上角的坐标比右下角坐标大的情况，或者bbox不存在的情况，在检测目标时需要将这些预测出来的bbox信息去除先，保留下那些bbox信息存在且不异常的</p><h4 id="NMS筛选bbox（在预测阶段）"><a href="#NMS筛选bbox（在预测阶段）" class="headerlink" title="NMS筛选bbox（在预测阶段）"></a>NMS筛选bbox（在预测阶段）</h4><p>NMS（Non-Maximum Suppression）抑制不是极大值的元素，说白了就是去除哪些重叠率较高并且score评分较低的bbox</p><p>处理了解码后的bbox，会保留下一些bbox的信息，但是不是每个bbox都去负责呢？仔细想想每个网格（对应尺寸下）会输出三个bbox，假如处理后的bbox信息都被保留下来了，那么一个物体就会有三个预测框去框住它，这样的展示效果就不太好了。</p><p>对于一个网格内的bbox，需要的是保存下那个能最好地检测出物体的那个bbox，就要用到NMS方法了<br>方法就是：</p><ol><li>首先判断边界框的数目是否大于0，如果不是大于0，说明没有bbox的信息被保留下来，就去检测下一个网格，直到所有尺寸下的网格都被检测完</li><li>在保留bbox时，会给每个bbox一个评分，对于一个网格内的bbox，根据评分，为这些bbox排序，（不放回的取）取出评分最大的那个bbox</li><li>把这个评分最高的bbox与同一网格下的其他bbox计算IOU，这是为了判断评分最大的bbox与同一网格下的其他bbox的重叠率，去除那些重叠率过高的，取到剩下的bbox为0为止</li></ol><h4 id="GIOU（广义IOU）"><a href="#GIOU（广义IOU）" class="headerlink" title="GIOU（广义IOU）"></a>GIOU（广义IOU）</h4><p>这是一种优化边界框的方法，GIOU是衡量bbox与实际框之间对齐和重叠情况的一个指标<br>IOU计算公式：<br>$$\text{IOU }= \left|\frac{A \cap B}{A\cup B}\right|$$<br>GIOU的计算公式：<br>$$\text{GIOU }= \left| \frac{C/(A\cup B)}{C} \right|$$</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划理论</title>
      <link href="/ZaNot.github.io/2021/10/21/dong-tai-gui-hua/"/>
      <url>/ZaNot.github.io/2021/10/21/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h4 id="1-什么是动态规划"><a href="#1-什么是动态规划" class="headerlink" title="1. 什么是动态规划"></a>1. 什么是动态规划</h4><p>在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。</p><p>这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法。</p><h4 id="2-动态规划的思想"><a href="#2-动态规划的思想" class="headerlink" title="2. 动态规划的思想"></a>2. 动态规划的思想</h4><p>动态规划与分治法类似，都是==把大问题拆分成小问题==，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在==新问题里需要用到的子问题可以直接提取，避免了重复计算==，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于==填表==，表填写完毕，最优解也就找到。</p><p>所谓的最优性原理是指：<br>多阶段决策过程的最优决策序列具有这样的性质：不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言（当前出发点），其后各阶段的决策序列必须构成最优策略。</p><h4 id="3-动态规划的作用"><a href="#3-动态规划的作用" class="headerlink" title="3. 动态规划的作用"></a>3. 动态规划的作用</h4><p>动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间</p><blockquote><p>Questions<br>动态规划怎么保证每个子问题的决策都是对最优结果的最好的决策呢？<br>动态规划记住的状态一定是最优的吗？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
